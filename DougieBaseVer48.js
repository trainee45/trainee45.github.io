//DougieBaseVer48.js production version Mayb24 2023 Copy of backupSampleGlitchDougieBaseVer48backupSampleGlitchDougieBaseVer48 DougieBaseVer48.js last glitch-dataNotBackedUp = false;//flag for SAVE warning so backup option and save alert does not appear which if ok'd will mess up file! Date May 22 and line 7891-if(bkupAlertsFlag && !blockEdit && !newDBGuidance && !convertingOldFile) {reverted to original PUBLISHED April25 2023 sw April25 2023 workingOnDougieBaseVer48.js DougieBaseVer48.js DougieBaseVer47.js added this line from Bing to correct error if $ sign preceded number in summing TOTAL April 21 publish April 8 2023 removedAlertsscrollRESTOREDougieBaseVer47 scrollRESTOREDougieBaseVer47.js DougieBaseVer47.js removeAlertstemplateBlockedfixRepeatBudgetSheetDougieBaseVer47 for publishing Mar 25 2023 Mar 21 2023 improved scrolling a bit..fixed glitch where new table caused listing of 2 tables one that did not exist  templateBlockedfixRepeatBudgetSheetDougieBaseVer47 scroll to flashing restore btn now works!  Mar16 2023 if solved convert fixRepeat… fixRepeatBudgetSheetDougieBaseVer47.js index.html with this js now contains updated budget template Mar 6 2023 DougieBaseVer47.js Feb 27 2023mMar 2 2023 date highlight corrected (have to use 3 letter dates in conditionals) fixed some bkup warnings..disabled for create new db  tryAgainbackupClickDougieBaseVer46 fixed summing and averaging again FEB 27 2023 FixtryAgainbackupClickDougieBaseVer46 tryAgainbackupClickDougieBaseVer46 corrected errors in SUMMING and AVERAGING routines Feb26 2023 Feb24 Feb25  backupClickDougieBaseVer46 USE FIND '//alertbkup' and replace with 'alert' to restore for troubleshooting bkup warnings simulateClickDougieBaseVer46.js use latest fallBack -  fallBackFeb22simulateClickDougieBaseVer46 polishing CANCEL btns use fallBackFeb19simulateClickDougieBaseVer46 file.. looking good still testing Feb19 2023 deleteDataBase(dataBaseName);//added in getDataBaseName Feb18 to cover scenario where a reboot is done prior to a locked file being deleted, and so that when rebooted DougieBase knows to delete the file again after the browser releases its lock. Tested..seems to work. DougieBaseVer46.js Feb2 2023 tryAgainCreateNewDBDougieBaseVer45 Feb3 2023 fixed date highlight if day <10 Feb2 USE FIND '//alertflm' and replace with 'alert' to restore for troubleshooting file list management Feb1 2023  smoothCreateNewDBDougieBaseVer45.js tagNewDBDougieBaseVer45.js fallBack2Jan29tagNewDBDougieBaseVer45 tagNewDBDougieBaseVer45.js DougieBaseVer45.js fixed objectStore mess ! Jan 24 2023 Jan22 2023 needs updated css file!  fixRenameDbDougieBaseVer45 DougieBaseVer45.js Jan20 highlightDateDougieBaseVer45 DougieBaseVer45.js Jan18 savedOriginal = false;//to trigger updating saved table arrays removed two <form> in HTML which caused crashes with add contacts/ recordsJAN6 2023 scrollbtn in NOTES  goes to searched record in table blockedMESSED UPtrying3Copy of improveBudgetDougieBaseVer44.js Copy of improveBudgetDougieBaseVer44.js USE FIND '//alertblk' and replace with 'alert' to restore for troubleshooting blocked by browser USE FIND '//alertcm' and replace with 'alert' to restore for troubleshooting changeMonth code  improveBudgetDougieBaseVer44.js added code to keep table scrolled to view edited cell, sampleBudgetDougieBaseVer44.js DougieBaseVer44.js Dec4 2022 calculationAlertsrenameDBDougieBaseVer43.js DougieBaseVer43.js Date: Dec3 scrollBtn added scroll to last  edited record in NOTES  (scrollBtn.onclick) added preferences option to toggle calculation Alerts  Nov28;did adding delay(5000); in getManualContacts fix the plusContacts? Hope so ..NOPE STILL NOT FIXED IS IT Nov27 added blue color to TOTAL Nov26 2022 Nov22 2022 tested with create new db added info for Cost to date in notes made changes in both css files to accomodate reNAME FILEMAME retryisolateNumbersumAcrossDougieBaseVer43.js Nov21 2022 alerts for rename filename can be retrieved using alertrnf removing alerts in the keyword functions..USE FIND '//alertxy' and replace with 'alert' to restore for troubleshooting  experimentretryisolateNumbersumAcrossDougieBaseVer43.js corrects for space difference in main and new tables  retryisolateNumbersumAcrossDougieBaseVer43.js DATE: Nov16 IF THIS SCREWS UP REVERT BACK TO isolateNumbersumAcrossDougieBaseVer43.js Nov17 in editTDBtn.onclick addEventListener put in code to check if rowSummed and if so update sum across!  sumAcrossDougieBaseVer43.js sumAcross works and total of last column if rowSummed, works BUT TOTAL  in other DYNAMICfields is messed up because rowSummed is always true so will put conditional in summing() to exclude last field ..new rule TOALfor rowSummed only works in last field !  DougieBaseVer43.js Nov9 2022 from bugDatesdynamicTelephoneDougieBaseVer42.js FIXED Activation glitches? Nov7 fixed bug in dates when adding record (+) to a new table dynamicTelephoneDougieBaseVer42.js.. not yet published.. Oct29 2022 need to add code at moreTables and homescreenBtn2 and refresh..DONE .. telephoneDougieBaseVer42.js RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED Oct 22 2022 this version works WILL TEST SOME MORE added code for telephone similar to email at displayTable that was missing.  DougieBaseVer42.js Oct19 Oct16 2022 incorporating moreTablesBtnDougieBaseVer42.js Oct11 2022 retryTOTALDougieBaseVer42.js Oct11 2022 AGE (TOTAL) if COST in header will add $ to result after adding now will add even if entry is NaN works if all items in column are numbers use search phrasex—for (let k = 4; k < numberOfFields; k++) { — TOTALDougieBaseVer42.js DougieBaseVer42.js Date Oct 5 .. use this to update github! Oct4 2022 from restoreFromLocalFileDougieBaseVer40.js fallBack2Sept29restoreFromLocalFileDougieBaseVer40.js restoreFromLocalFileDougieBaseVer40 Date Sept25 2022 WORKS! Added Scroll to bottom in manage window DougieBaseVer40.js fix!editSearchedNoteDougieBaseVer40.js Think this is fixed ? Sept 20 2022 editSearchedNoteDougieBaseVer40.js As of Sept 11 2022, can now edit the single record view obtained as a result of a record search. Still testing..seems to work change SW to ver 26 before sending to github! - from createNewDougieBaseVer40.js from eMailDougieBaseVer40.js email now active  fixContactsBugDougieBaseVer40.js Jun7 fixed dbl tap deleting instead of editing a new table ..deleteRecordNewTable = false; .. June6 fixed repeat record entry in contacts tables if repeating creating a contacts table DougieBaseVer40.js June4 saveBtn2 fixed and flashing displayTableBtn when CONVERT file format June3 fixed search bug May28 fixed tableLimit noAlertsplusContactshitsTablefixADDCONTACTSDougieBaseVer40 May18 fixed share data error May28 2022 tableLimit plusContactshitsTablefixADDCONTACTSDougieBaseVer40.js May17 May15 May 13 May9 hitsTablefixADDCONTACTSDougieBaseVer40.js May5  from fixADDCONTACTSDougieBaseVer40.js May1  testCancelsweetAlertnoAlertsmoreBlock+DougieBaseVer40.jsApri25 2022
//NOTE ALERTS REMOVED HAVE A x after alert SO USE FIND REPLACE SEARCH TO RESTORE THEM!! i.e. //alertx("message data…") can be restored by search and replace for //alertx and replace with alert
//moreBlock+DougieBaseVer40.js April17 April15 fallBackApril15moreBlock+DougieBaseVer40.js Copy of moreBlock+DougieBaseVer40.js fallBackApril14moreBlock+DougieBaseVer40.js moreBlock+DougieBaseVer40.js April10 for testing and when works back to block… from block+DougieBaseVer40.js DougieBaseVer40.js from shareDeleteRecordNewTableDougieBaseVer37.js WILL THIS FILE AUTOMATICALLY SYNC WITH ICLOUD.YES!deleteRecordNewTableDougieBaseVer37.js NOTE ALERTS REMOVED HAVE A > AFTER THE " SO USE FIND REPLACE SEARCH TO RESTORE THEM!! i.e. //alert("> message data…") can be restored by search and replace for //alert("> …) .. MUST PUT A SPACE AFTER THE> CHARACTER! fromNewTablehitsTableDougieBaseVer37.js pushContactsFormtableIndexaddContactsDougieBaseVer37 ADD CONTACTS number of dynamicfields = 1 now createnewDB resets newTableSpecificVariables and savedTablesArray to 0 savedTablesArray.length increases by 1 as each table is created fixed manal contact entry fields fixed + contacts deletingTableField variable added Marc19  contactsFormtableIndexaddContactsDougieBaseVer37.js manual contacts now works Mar13 tableIndexaddContactsDougieBaseVer37.js from deleteNTtableIndexaddContactsDougieBaseVer37.js Mar11 from delete last and first and middle tables works!  tableIndexaddContactsDougieBaseVer37.js Mar9 2022 deleteItemtableIndexaddContactsDougieBaseVer37.js from tableIndexaddContactsDougieBaseVer37 WORKS Mar8 FOR CRETION NEWBB BEFORE ANY DB LOADED MAR6 from createNewaddContactsDougieBaseVer37 from addContactsDougieBaseVer37 from Copy of addContactsDougieBaseVer37 based on date: Feb22 2022 worksKeepTestPlayWithNewTableContactsDougieBaseVer37 Feb 17 2022 Feb 13 2022 from testPlayWithNewTableContactsDougieBaseVer37 Feb10 from playWithSTRowsEditTDNewTableContactsDougieBaseVer37.js FEB6 FEB4 2022 from workingOnEditTDNewTableContactsDougieBaseVer37.js currentJan19ContactsDougieBaseVer37.js now adding newTable variables ..Jan11 go to fallBackJan11 if meeses up workingOnContactsDougieBaseVer37.js Jan2 THIS VERSION WORKS WITH SAFARI CONTACT PICKER!  contacts table working with search sort Dec24 Added whatsNew window  Working on retrieving contact info. See functions at bottom. ADD style="color:black" IN HTML  Dec22 moved getMemory function from html file to .js file from Dec10 2021 mobileFriendlyDougieBaseVer37.js from DougieBaseVer36.js Dec5 sw11 from messWith Dec2 DougieBaseVer36.js Dec1 from flashFileNameDougieBaseVer36.js from createNewDBDougieBaseVer36 Nov30 Nov28 added addToDynamicFields.setAttribute('class','borderBlink') to border in editMoreFields function and addNoteBtn.setAttribute('class','borderBlink'); in saveBtn.onclick for createNewDB renameBtn.setAttribute('class','borderBlink'); in preferences displayDataBtn.setAttribute('class','borderBlink'); in function renameTitle Nov28 borderBlink css is in the html file  Nov 27 fine tuned flow of createNewDB Nov24 fixed create newDB bug! Nov 22 edit notes displayed n real time Nov17 added tableScreenOptions to editTableTrigger to not mess up table display Nov14 from spDougieBaseVer36.js landscape table search and preview edid Date:Nov9 save preferences from Date:Nov4 added Easter egg and save settings preferencesDougieBaseVer36.js from fixEditDougieBaseVer35.js from 
//changed addEventListener to copy instead of dblclick Oct16 made default double click Oct31 2021  clearBkgrdDougieBaseVer34.js clear background and fixed crashes that occur if user makes illogical moves Oct12 2021 use to update workingCopy and Safarii etc
//Date:Oct5 2021 Removed Double tap to avoid magnification in Manage files view full screen search select filenames. iOS15 safari has no way to disable double tap for magnification. More cosmetics with dataBaseName titles
//removed alert in view full note ?hangs up sometimes? Cosmetic fixes Oct 3 2021 titleBanner in About db
//includesSubstringDougieBase Ver33.js in Textastic Sept 29 2021
//from tryAgainDougieBase Ver33.js in Textastic
//FIXED date:Sept9 2021 added code to prevent error if Backup without a file selected fixed cancel createNewDB so preferences still doesn't think you are creating a new db if you cancelledchanged tableArray declaration by making recordCounter = 1 added code for newDBGuidance to insure table created before adding new record .. cleaned up createTable screen goHomeBtn.disabled cleared add dynamic fieds input number disabled clearFileBtntn added HELP BTN (LOAD)
//fixRepeatCreatenewDBtutorialDougieBaseVer31.js
//tutorialDougieBaseVer31.js Aug 22
//copyOffixBkupRestoreDougieBaseVer31js
//from …CleanUpTableNotesVer30Copy2xSampleDb
//fixed viewSettingsBtn disabled locked after a user taps aboutDBBtn without there being a database loaded
//TableNotesVer30Copy2xSampleDb from -
//Yes this worked!
// AS OF AUG 16 2021:
// TableNotesVer30Copy2xSampleDb.html using TableNotesVer30Copy2xSampleDb.js and TableNotesVer30.css works! This version has a Load Sample database demo in it WITHOUT using copy and paste. Needs some dressing up to make its method use clearer to understand.
//TableNotesVer30.js from scrollPrefsTableNotesVer27.js USING THIS FILE IN DOUGIEBASE WORKINGCOPY TO COMMIT TO GITHUB REPOSITORY JULY 23 24
//chaged alert notice from version 1 to Installing DougieBase version 1 added alert to initialize table if necessary if edit note so table field headers are displayed correctly
//Added option in preferences to center record title Date: July 3 Added document.querySelector('#STforRows').children[matchedRecordIndex].scrollIntoView(true); july 8 to scroll to searched item
//from Added horizontal and vertical table scroll fallBackJune19xtraSaveBtnfoundRecordsListTableNotesVer26.js added xtraSaveBtn at bottom of table. Deleted recordList in Search if loading in a new db to prevent operational error in search if clicking on a now gone filename june19 improved colour guides flow in restoreDB fixed dbName successfully restored
//TableNotesVer26.js from Current June19 backupTableNotesVer26.js June15 2021 cleared foundRecordList in Search records if loading in a new database to prevent operational error if a user taps on the residual recoord list after loading i a new db June18
//TableNotesVer26.js from backupTableNotesVer26.js June1 2021
//disabled use link label btn in preferences until table initialized June15 made backup button from manage window more expedient. Added <br> to all links prefs window better positioned disabled DONEbtn in backup screen uuntil after click here is tapped June17
//fix2LabelLinkTableNotesVer25.js added STrecordTd.setAttribute('class','td_size') used in displayTable if(!linkLabel)
//added colon filter so any text added after a colon in notes will not appear in the pre or postLinkInfo text in the table June9 also added colour guided steps for buttons in the search window
//fixed disappearing postLinkInfo issue.const STlinkTdAfter=document.createElement('p');//to add the text after the link NOTE! Had to move the declaration of STlinkTdAfter here in the for number of fields loop to create separate elements for each td cell in each row, otherwise if declared only in the i record loop there is only one STlinkTdAfter p element for each row and that is why the postLinkInfo disappeared after creating another one in the same row!
//labelLinktryThisFixbetterAllowLinkjQueryTableNotesVer25.js fallBackJune4tryThisFixbetterAllowLinkjQueryTableNotesVer25is the fallBack if AllowLinkjQueryTableNotesVer25 gets messed up Jun 1
//allowLinkjQueryTableNotesVer25.js May28
//correction made May 30 that fixes https and www being ignored see check for linl in displayTable
//added error code if wrong format pasted in restoreDB May28 refined to catch both ends of copy May29
//added && !newDBflag to if setup = 0 which disabled Add Field .change label btn in preferences which therefore would not allow a second field if creating a new db from start
//linkrestorejQueryTableNotesVer24.js May18 2021 May22
//added css and code to change table background colors May21
//active links have been added to the table. Links can be edited and added to fixed OR dynamic fields BUT links are only active in the table. They are not active in notes. May 20 2021 fixed tableMenu banner
//restorejQueryTableNotesVer24.js May18 2021
//secondDeleteDBthirdTryrestoreBackupTableNotesVer23.js
//fine tuned restore works great! May19
//this version sort of works. Added close db in the still blocked section which seems to work?!!!!!., 
//May 8/9 fixed repeating db names in current file list. Cleared textarea for reuse of restore. Created new btns for easier navigation. Working on delete db ..need to remove name from list
//May7 fixed viewSettings btn disabled and messed up field headers after a return from restore by removing resetVariables in getJsonBtn.onclick in restore code.
//this script also works with fallBackMay5thirdTryrestoreBackupTableNotesVer23
//May5 WORKS USE THIS FIX INITIAL TABLE FIELD HEADERS WHICH LATER CORRECT THEMSELVES. TRY RESETVAIABLES IN FINISHEDBTN.ONCLICK OF RESTORE TABLE
//USE THIS AS OF MAY1 2021
//REPLACED recordCounter =50 with tableTitle.length. WATCH!!!!!Apr25 did not work
//commented out line 906 recordCounter =50 Apr25 put back in if messed up. In aid of not creating all the null blanks in tableArray!!!!?replace with numberOfRecords? Or tableTitle.length
//Apr16 USE THIS FOR NOW SORT OF WORKS!updated Apr17 testAddFieldconvertToFileNamesTableNotesVer21from TableNotesVer21.js which already cotains the promise method for loadingnotes_os. So will add the fileNames code to this. Fixed dbTableName and disabled SUBMIT btn in edit for more reliable action.Apr12 2021
//Copy of TableNotesVer21.js from anotherTryreWritetestNewDBTableNotesVer21 from/TableNotesVer21.js Mar31 after recoding using promise method to retrieve notes_os
//fileNamesTableNotesVer21.js from playWithnotesOSfileNamesTableNotesVer21.js
//gives unexpected end of script error! So now starting with TableNotesVer21.js and converting to fileNamesTableNotesVer21.js

//April 2 2021. Used new promise method for database retrieval. Seems to work better, and onupgradeneeded works too!
//March 22 Fixed bug in edit table field 0 data.title and tableArray[i][0] AND DYNAMIC FIELDS. Added failsafe if Search after an Added Record without having updated the table
//originalOrderredoSortTableNotesVer20.js
//added failsafes if display Table not initialized Mar 20 2021 plus some instructions (HTML)Mar 21
//March 19 : Added scroll buttons and on/off switch in preferences
//Mar16.After deleting a record, the sort restore to original reestablishes the deleted item feature or give option.?March 15 This messes up future display so fix. Fixed! Also fine tuned delete record window Mar 16 inactivated dynamic field # input in edit table to keep display from corrupting if user tries to enter # here in edit table. Added instructions in create table
//March 14 2021. warning to prevent overwrite of original table recod order which would be lost if reloading db, but not if staying within same database!
//TableNotesVer20.js ..derived from
//FixedFieldseditBtnTableNotesVer19.js Mar 7 2021
//CHANGES MADE SINCE MAR 7:
//fixed xtraFieldBtn accumulating. fixed field edits now auto persist in notes records. Note one time glitch of absent dynamic field headers afte edit fixed field table then added notes record then update refresh table showed the glitch of abseNny dynamic field headers. CAN'T SEEM TO REPRODUCE!
//added clear Btn to table edit
//TableNotesVer19.js Mar 3 2021
//testEditDateTableNotesVer19.js Mar 3
//March 2/trying to fix make changes. 2 field td's were added when I had make changes Btn visible for edit (but NOT New). There is code to show the make changes Btn after edit but not after New. Might work if I refine code around extraField number input..maybe clear data with ''?FIXED,not fixed! I removed edit = 1 in makeChanges to.onclick
//Feb 28 color coded the save changes Btn in edit decoder field to make a save after editing the second field
//fixed accumulating editFieldDecoder Btn. But note did I create a save glitch. After commit in editing xtraField you must tap save changes Btn in data.body section to save the changes in the decoder field! This works the first time but if you go back and edit decoder field again it does not work! So reverted back. editFieldDecoder Btn still might accumulate?
//Date:Feb 27 2021 added editTableBtn to table sereen
//Feb26 troubleshooting...made this change in .HTML:To edit date or dynamic cell contents double tap the cell...buildRecordsP.textContent = ' Enter titles of '+ numberOfDynamicFields + ' dynamic..in HTML-createTableWin
//keeping track of SAVE Btn class Done!
//WORKING ON EDITdate in table and preserving in notes Feb13.Fixed So far works Feb 14 2021
//TableNotesVer19.js
////trying to erase record rows for editing new table Feb12
//still testing..think it works OK FEB 12
//while (rows.firstChild) {
  // rows.removeChild(rows.firstChild);
//}//end while
//REMOVE ABOVE IF MESSED UP FEB 12
//FIXED: showExtraField Btn label in preferences now is correct for initial load.
//DatemessWithTableNotesVer18.js DATE: FEB 9 2021 fixed edit table DATE-TIME
//fixed edit table being messed up after a call to deleteField because numberOfDynamicFields is saved in OtherVariablesArray. For this reason future testing requires use of dB dated Feb 5 or later as otherwise the numberOdAdditionalFields variable will not have been adjusted properly after a deleteFImelda!!
//fixingDeleteFieldmessWithTableNotesVer18.js
//messWithTableNotesVer18.js Feb 2 2021Jan30 2021 This version has deleteField!
//working on deleteField ALL CHANGES HERE MUST BE ADDED TO TableNotesVer18.js
//Jan25.Added space after >in tableTitle and now works for search and delete. Keep trouble shooting. Start ver18 with ability to delete fields!
//FIXED CASE SENSITIVE AND REPEAT REGISTERING OF addEventListener in search!! Jan24
//been working on repeat registration of addEventListener which I am trying to stop. Keep resultList.appendChild(addP); for asthetics reasons left off here Jan 22
//Things to work on:1.Try changing addEventListener to object.ondblclick in displayTable edit TD cell to avoid repeating alerts..As of Jan 18 issue ?fixed? But I DON't think I did anything???NOT FIXED..look at removeEventHandler method 2.Increase height and width of add new note screen and table display screen to look better in Safari 3.In edit table recode to avoid appearance of scrambled table during input of changes to tableJan18 Fixed 3!and fixed issue of non-responding search screen when coming from first view of table
//Still to do: 1. In EDIT, remove field. 2. Investigate remove addEventListener method to prevent repeats of alerts3. Adjust height of add new record window 4. Fix double tap bug that repeats input screen if you dbl tap twice 5. Add option for case sensitive search...to lowerCase()
//noteIDSearchTableNotesVer16 derived from
//Copy of SearchTableNotesVer16.js Jan 8 2020 Dec29 fixed delete record and table record bug by adding noteId to each record
//Creates a found record list as history. Double tap on list item to see full view of record notes. Next work on highlight entry in table Jan 9 2020 DONE! Jan 9 Jan10 when trying to preload searchRecordInput from title in viewFullItem I get a crash of program..just stops running FIXED JAN11 2021 UPDATED Table if notes edited Jan12
//fudgeFactor to unworkable try appendinG noteID to tableTitle!!! Jan7 
//in refreshBtn.onclick code I added:refreshed = 0; //ADDED JAN 2 2021
//derived from .. in Taio tryThisdeleteRecordTableNotesVer15
//add note deleted indicator and option not to delete record from table and continue deburging edit etc
////if refreshed not set to 1 then field headings will repeat when going to display table, but if at 0 a rerun will recreate the field headings which is what you want. So maybe add line refresh = 0 on return from displayTable .see below. Changed NoteId-2 to counter in displayData, and used tableTitle.indexOf in deleteItem for record table delete to properly find record in tableTitle array. Left off here Dec 18 FIND WHERE DISPLAYDATA NEEDED AFTER RETURN TO HOME SCREEN,!! I put a call to preferences window in code after saveVariables call from displayTable. There would sometimes be a blanK screen when returning to Home Screen after a savETable Btn press when viewing the table after a deleteRecord
//deleteRecordTable toes er15.js
//experiment2TableNotesVer15.js
//this version successfully deletes a record and then recreates the table..but then if adding a new record after that it screws up!
//TableNotesVer15.js
//in delete record frame add option to delete record in table if table exists.try just going to refreshTable()?
//fixDisplayTableOnTableNotesVer14.js
//added title secondField Nov 25 2020

//write a function to edit first and second data field contents to make suitable for table display working on this now Nov 28 DONE! Uses : to demarcate the default table entry. Nov 29 2020
//refine the input for edit table to add additional fields..DONE NOV 26
//getThisToWorkingOnTableNotesVer14.js and fall back to: THIS CODE SAVED AS fallBackNov15TableNotesVer14.js
//fixed displayTable to show fields correctly  after an edit table Nov 15
//workingOnTableNotesVer14.js
//makeChanges WORKS! So make edit follow the makeChanges code path.. If tappinG on createTableWindow.onclick make two paths depending on tableExists
//fixed adjustment of tableArray to allow creating any number of records from the start
//this version requires 3 records entered first then a refreshTable call redefines the tableArray for adding additional records. Ver12 fixes this!Now need to save originalNumberRecords variable so if you rerun and add a record table gets updated properly
//from :buildRecordRowsExperimentrefreshTableNotesVer11.js Date: Oct 28 2020
//dataVfromWorks!Oct18TableNotesVer10 copied from:
//fallBackKeep2Oct24TableNotesVer10.js
//derived from:
//dataVfromWorks!Oct18TableNotesVer10.js
//this version works for rerun prexisting db; onupgradeneeded not tested. tableDisplay code after a rerun not written yet in this version
//the one I am working on
//going to duplicate variables2 with dataV and put in notes_os. note have changed dataV to dataVobj to distinguish from dataV: in objectStore setup
//dataVobj compares to variable2Array, and dataV: compares to variable2:
//Copy of Works!Oct18TableNotesVer10.js
//this works..but dataV not put into notes_oss admin record yet. USE THIS FILEc TO FALL BACK ON IF HAVING TO START AGAIN FROM SCRATCH,!!!?,?,?!!!!!!

//getThisToWorkTableNotesVer10.js
//based on Use!ThisExperimentTableNotesVer10.js
//now trying to correct tableTitle.length is undefined in function buildRecordRows () 
//Use!ThisExperimentTableNotesVer10.js
// Create needed constants

//for testing in Textastic, ifnthe db is new and does not previously exist, then onupgradeneeded will run to set up a new db
//set the testing variable to true, otherwise false
//However if db-notes already exists, but an object store is missing (a version created before I wrote code for the notesVariables_os,) then set variable os to 0 to create both _os; set os = 1 to create just the notes_os; set os = 2 to create just the notesVariables_os

//All theories above dn't work. If lost, force onupgradeneeded by changing the db name to something else. I have changed notes_db to notes_dbx. use search and replace
//alert('deleteDB');

//var flashing;
//var flashYellow = true;

//these variables are experimental..belong to make contacts table code Dec29
//let namestr = "";
//will save a flag that indicates if new table derived from a searchmain db in aid of preventing + - icons appearing in such a table..aadding a record herevwould crash!
//let clickedMoreTables = false;//flag to fix undefined error in displayTable if coming from more notes after an add note procedure
// const createNew = document.querySelector("#createNew");
// const bodyInput = document.querySelector("#body");
//  bodyInput.addEventListener('focus', function () {createNew.setAttribute('class','borderBlinkGrn')});
//let fromcreatingNewDb = false;//flag used for auto clicks in creating new db added Feb 12 2023 not used
//let calculationAlerts = false;//flag options .. show or don't show alerts when calculating sums or averaging DON'T WANT THIS FLAG HERE BECAUSE EVERYTIME YOU TAP PREFERENCES FLAG IS MADE FALSE
let successCount = 0;//used to keep track of blocked and succeesful deletions of databases
let plusContactsEntered = false;//flag to stop home btn in table flashing after a plus contact added so user does not have to go to notes back to table to view his addition to a contacts table Mar21 2023//using this flag to prevent home btn from flashing after creating a + contact ..made false in saveTableBtn.onclick Date-Mar21 2023 also used in tdEdit and deleteRecordNewTableBtn
let mustTapRestore = false;//to force a scroll to bottom of fileNamesWindow to see flashing restore button
let backingMeUp = false;//flag to prevent erroneous new db creation vis backMeUp function which sometimes happened if creating a new budget sheet see backMeUp() Mar10 2023
let TEMPLATEblocked = false;//flag keeps notice about TEMPLATE BLOCKED from reappearing
let bkupAlertsFlag = true;//flag to set bkup warnings on in preferences//moved to top because called upon before this statement is read
let dataAltered = false;//flag to allow warning if edit not saved
let dataNotBackedUp = false;//flag for SAVE warning if changing a database
let fromDoneBtn = false;//flag used in simulating .click()
let ranOnce = false;//to prevent rerun used in create new db to strip off extension
let creationDONE = false;//flag for below
		//SHOULD I put flag to indicate createNew db is now finished so next getFileNames will initiate removing .createNewDB DATE: Jan28 2023
let creationDONEName = "";
let flashing = false;//flag toggle flashing tagged was default true filename ON or OFF
//let firstLOAD = false;//flag used in createDB SO FAR DOES NOT WORK 
let recordAdded = false;//flag to update tableArray to fix undefined error if going from more notes to displayTable
let originalDBName = "";//used in rename database deleting original file
// let blockedName = "";//trying to avoid glitch if attempting to delete a db more than once
// let blocked2Name = "";
// let blocked2 = false;
// let blocked3Name = "";
// let blocked3 = false;
// let blocked4Name = "";
// let blocked4 = false;
let blocked = [];
let blockedName = [];
let dbDeleted = [];
let dbDeletedName = [];
let deleteCount = 0;
let blockedCount = 0;
let pendingDeleteName = [];//used in delete(dataBaseName)
//RENAME DATABASE FILENAME
const previousTitlePara = document.createElement('p');
const cancelTableTitleBtn = document.createElement('button');//these made global because of can't find variable error
	const reNameDBWin = document.querySelector('#reNameDBWin');
	const dbFileName = document.querySelector('#dbFileName');
	const newDBFileName = document.querySelector('#newDBFileName');
	let renamedFileName = "";//the new filename
	let protocolFileName = "";//this is saved to the file in clipboard adding .bs to the name. See renameFileName function
	let reNamedDBFileName = false;//flag to tell backup to manipulate string for renaming filename
	let changeMonth = false;//flag so that renameDataBase function knows to set dbTitle to renamedFileName
	const saveRenamedFileNameBtn = document.createElement('button');//made
	//RENAME DATABASE FILENAME
	
//REFERENCES FOR BUDGET SHEET
let budgetSheet = false;//flag to indicate thedatabase loaded is a budget sheet
const changeMonthBtn1 = document.querySelector('#changeMonth1');
const changeMonthBtn2 = document.querySelector('#changeMonth2');
//REFERENCES FOR BUDGET SHEET
const backupBtn1 = document.querySelector('#backupBtn1');
const backupBtn2 = document.querySelector('#backupBtn2');
backupBtn1.setAttribute('class','borderBlink');
backupBtn2.setAttribute('class','borderBlink');
backupBtn1.style.display = "none";
backupBtn2.style.display = "none";
//references for TOTAL FIELD
let totalFieldNameListener = false;
let totalFieldNameIndex;////not sure this is used anymore? Date Nov13 2022
let addField = 0;
let fieldSUM = 0;
let totalActive = false;
let sumField;
let strippedOff = ""//used in summing()
//references for TOTAL FIELD
//references for summing td cells in record row
let rowSUM = 0;//used for summing horizontal row
let rowSummed = false;//flag (false) to tell edit td cell routine to update row total. Also used by summing function to trim off txt to leave a true number for summing. Function summing () ..May have to save this variable!?currently app checks summed td cell for includes sumRowTxt and if so sets rowSummed to true…works
//let sumRowTxt = "Sum across = ";
let sumRowTxt = "Total to date = $";
//let sumRowTxt = "Spent to date = $";//what ever txt is here becomes txt in sum of row td. In future may allow user to enter this by input and save in variables of the specific database?
let showRULEonce = false;//flag for alert notice to be displayed once on first initializing sumAcross
let scrollHere = false;//scroll to edited record from table in displayData
let scrollAmount = 0;//see scrollBtn.onclick
//references for summing td cells in record row

//references for RESTORE FROM LOCAL FILE
let restoreFromLocalFile = false;
let selectedFileData = "";
// const continueFromFileSelectionBtn = document.createElement('button');//this btn is in HTML script
// const cancelFromFileSelectionBtn = document.createElement('button');//in HTML SCRIPT
const restoreFromFilesWin = document.querySelector('#restoreFromFilesWin');
const restoreFromFileBtn = document.querySelector('#restoreFromFile');//made global
const restoreFromClipboardBtn = document.querySelector('#restoreFromClipboard');//made global
const finishedRestoreBtn = document.createElement('button');//made global
const cancelRestoreBtn = document.createElement('button');//made global
//const cancelFromFileSelectionBtn = document.createElement('button');//made global in HTML script

//references the file input selector if you need it?
const fileSelector = document.querySelector('#fileSelector');
const getJsonBtn =  document.querySelector('#getJson');//made global so finished btn could change its attribute
//const fileData = document.querySelector('#fileData');//the p on restoreFromFilesWin that shows the backup data
//references for RESTORE FROM LOCAL FILE

//to ACTIVATE EMAIL ADDRESS
let refreshing = false;//flag for reset during createNewDB
let eMailFieldNameIndex = 0;
let eMailActive = false;//flag to indicate if email set to active
let eMailAlertFlag = false;
let eMailAlertFlag2 = false;
let STsecondDataNameTdListener = false;//flag to indicate remove listener in returnToHomeScreen

//to ACTIVATE EMAIL ADDRESS

//to ACTIVATE Telephone number
//let refreshing = false;//flag for reset during createNewDB
let telephoneNumberFieldNameIndex = 0;
let telephoneActive = false;//flag to indicate if email set to active
let telephoneAlertFlag = false;
let telephoneAlertFlag2 = false;
let STfirstDataNameTdListener = false;//flag to indicate remove listener in returnToHomeScreen

//to ACTIVATE telephone number

let mainDBArray = [];//for error check savedOriginal
let fromEditFieldLabels = false;//to force a simple contacts list with just 4 fields
let fromAddContacts = false;//flag to tell editNewTableFieldNames to flash and return to ADD CONTACTS
let addContactsBtnTapped = false;//to add ADDRESS field if using ADD CONTACTS
const finishedShareBtn = document.querySelector('#finishedShare');
let hitsTable = false;//flag to relabel CONTACTS btn to create a searched hits table set in highlightTable function
let makeHitsTable = false;//flag indicates a press of the make hits table btn
let deletingTableField = false;//field headers get messed up after a delete field

let renameNewTableFlag = false;//used in renameNewTable function
let fromNewTable = false;//flag for preventing fields layout mess up
let resetFields = false;//flag fields layout mess up see editItem()
let fromAddingMoreContacts = false;//forcing a resetFields when displayTableBtn is tapped
const tableNameText = document.querySelector('#tableName');
const editTDTriggerBtn = document.querySelector('#editTDTrigger');//this is the btn in preferences used to switch between copy and dblclick for edit table data cells. The trigger variable is declared at start of prgm AND THE tdEditTriggerP var is also made global because it is used in tableScreenOptions..not just in the function options
// const printBtn = document.querySelector("#print");

//variable references for promptBox date April25 2022
const promptBox = document.querySelector('#promptBox');
const tableNameTxt = document.querySelector('#tableNameTxt');
const actionLoadBtn = document.querySelector('#actionLoad');
const actionRenameBtn = document.querySelector('#actionRename');
const actionDeleteBtn = document.querySelector('#actionDelete');
const actionCancelBtn = document.querySelector('#actionCancel');
//variable references for promptBox

//const manualContactsForm = document.querySelector('#contacts');form.onsubmit is used for addData so any other form with any kind of submit btn will divert program flow to addData and this caused the crash when adding contacts with the + btn! SO REMOVED THE FORM WITH ID =CONTACTS IN HTML AND AL REFERENCES TO IT IN JS I.E. manualContactsForm.BLUR ,!!?,?,?,
const emailBtn = document.querySelector('#email');//made global because referenced by tableScreenOptions Mar7
const newTableFieldsBtn = document.querySelector('#newTableFields');
const displayTableBtn = document.querySelector('#displayTable');
 const renameNewTableBtn = document.createElement('button');//made global..see emailBtn	
//flag to correct messed up fieldHeaders from a newTable edit
 const returnToNotesBtn = document.querySelector('#returnToNotes');//made global because referenced in renameNewTable function

//flag to correct messed up fieldHeaders from a newTable edit

const clearTableWindowEditBtn = document.querySelector('#clearTableWindowEditBtn');//made global from tableScreenOptions because of null is not an object error
let numberOfPlusContacts = 3;//code input for  a user selected number
let plusContacts = false;//flag indicating we are adding contacts to a pre-existing table
let mainDBedit = false;//flag that indicates the main db was edited..editBtn.onclick	
let doThis = false;//works with mainDBedit
let adjustFields = false;
let cleared = false;//used for clearHeadRow function
let test=false;//flag for contactsPicker API see emailBtn.onclick
//let contacts=[];
let contactsTable=[];//contactsTable array and contactsArray are different things.contactsTable is used in the allContactInfo(selectedContact);function but not used outside this in the mainline code because I could not figure out how to pass itoutside this function. contactsArray holds the contacts table data created in the emailBtn.onclick (CONTACTS) function. I will remove this code and variable references to save memory AND REPLACE WITH contactsArray
for (var i = 0; i < 50; i++) {

contactsTable[i] = new Array(4);

}//number of fields means all fields


let contactsArray = [];//made 2D in emailBtn.onclick as per selectedContact.length
//for (var i = 0; i < 50; i++) {

//contactsArray[i] = new Array(4);

//}//number of fields is 4 name,date,email

let newTableContactsTitleLength;//made global for use in sort when sorting a contacts table
let makeContactsTable = false;//flag to create table from seleted contacts
let loadFromTableOptions = false;//flag indicating source of tableArray data is from loading a newTable from the tableOptionsScrn//**
let newTableEdit = false;//flag to tell displayTable to create added field names in a newTableEdit
let blockEdit = false;//flag to prevent dblClick edit of td cell if just finished editing layout of table via editBtn.onclick..because otherwise tableArray will no longer be in newTable mode and savedTablesArray will get messed up
let deleteFromTableOptions = false;//flafpg indicating deleted newTable see tableScreenOptions
let convertingOldFile = false;//flag to fudge a correction in tableScreenOptions to prevent a refresh request. tableTitle.length came out as 4 when there were only 2 records in the testingPreferences db file. This may be related to the fact that testingPreferences file had 2 deleted records? And cursor iterated up to 4 when there are only 2??????
let savedOriginal = false;//flag to prevent repeated contactsTables from overwriting the original. See emailBtn.onclick
let saveOriginaltableTitleLength;
let saveNumberOfOriginalFields;
let saveNumberOfAdditionalFields;
let contactsFieldNames= [];
let tableIndex = -1;//-1 so newTableNames array starts out at 0 see emailBtn.onclick Jan9 2022
let loadTableIndex = 0;//tableScreenOptions .. load in a table
let tableID = 0;//so saveVariables is saving data to the correct array element in newTablesSpecificArray
let saveTableTitle = [];
let saveTableArray =[];
let saveCopyOfTableArray = [];//**
let saveCopyOfTableTitle = [];//**
let saveFieldNamesArray=[];
let saveDbName = "";
let newTableNames =[];//keep track of newly created tables Jan1
let tableNamed = "";
let deleteTableIndex = 0;
const liMatchedRecord = document.querySelector('#matchedRecord');//made global used in outside function clearFoundRecordListFunc seachRecords see Contacts code
//contacts table variables are listed above
let findRecord="";//record title found used in search made global

//let selectedContact = [];//used in table email
let contactsCounter = 10;//analogous to recordCounte..to create seletedContt array on the fly. Referenced in allContactInfo function as per contacts.length
let selectedContact = [];//used in table email
//	var selectedContact = new Array(contactsCounter);//Allows 50 contacts to be imported

//for (var i = 0; i < recordCounter; i++) {
	
//for (var i = 0; i < contactsCounter; i++) {

//selectedContact[i] = new Array(3);//contactsTable has 4 fields

//}//number of fields means 4 in case of seletedContacts array this will be 4 if browser can get address and will only use 3 if browser does not get address

let saveheadNameTextContent = "";//not sure what this regerences? Caused error ReferenceError: Can't find variable: saveheadNameTextContent Date: Jan 23 when running getNewTableName function
let tableScreenBtnGrn = false;//flag used to let the table btn flash when createNewDB
let testing = false; 
let os = 2; 
let noteNumber;
let deleteRecord = 0;//flag to indicate a record has been deleted so as to avoid going to buildRecordRows in refeshTable() Dec 6
let linked = false;//flag to indicate link in table data
let fromHELP = false;//flag that keeps aboutDBwindow from opening if documentation reached by HELP btn Sept17 2021
//SyntaxError: Unexpected token '['. Expected ';' after variable declaration.
//let keepTableNote = [];//keep data preceding the : so it can be prexappended to the link ..not used? So should erase
let preLinkInfo = "";//used to prePend data to link in table
let postLinkInfo = "";//used to postPend data to link in table
//let keepPreLinkInfo = true;//flag to keep pre link info see displayTable
let theLink = "";//used to hold the link in displayTable
let linkLabel = false;//flag to allow using trailing text as link label instead of actual link .. see displayTableCHANGED TRUE JUNE8
let scrollTable = true;//horizontal Table scroll is default
//new code for managing databases and database names for loading Mar 23
let bkgrdImage = true;//flag for clearing background image in preterences
const toEditTableScrBtn = document.querySelector('#toEditTableScr');
const plusContactsBtn = document.querySelector('#plusContactsBtn');//hidden until new table mode see displayTable
const deleteRecordNewTableBtn = document.querySelector('#deleteRecordNewTableBtn');//hidden until new table mode see displayTable
let deleteRecordNewTable = false;//set flag for record deletion new table to run delete code in display table
const dbNameInfo = document.createElement('p');//used in about db manage files
const dbFileNameInfo = document.createElement('p');//used in about db manage files
dbNameInfo.setAttribute('class','titleBanner');
dbFileNameInfo.setAttribute('class','titleBanner');

const fileNamesWindow = document.querySelector('#fileNames');
//const dataBaseList = document.querySelector('#dataBaseList');//declared twice kept one below at 654?Dec20
const createNewDBWindow = document.querySelector('#createNewDBWin');//referenced this earlier because it is used onwindow open
const manageFilesWindow = document.querySelector('#manageFilesWin');
const deleteFileButton = document.querySelector('#deleteFileBtn');
const renameDbFileNameButton = document.querySelector('#renameDbFileNameBtn');
const clearFileButton = document.querySelector('#clearFileBtn');
//temporarily disable clearFileButton this button until clear is supported
clearFileButton.disabled = true;
//temporarily disable clearFileButton button until clear is supported

const backupFileButton = document.querySelector('#backupFileBtn');
const cancelDeleteDataBaseButton = document.querySelector('#cancelDeleteDataBaseBtn');
const backupRestoreFileBtn = document.querySelector('#backupRestoreFileBtn');
const backupFilesWin = document.querySelector('#backupFilesWin');
const selectedDBNameP = document.querySelector('#selectedDBName');
const backupBtn = document.querySelector('#backupBtn');
const restoreFileBtn = document.querySelector('#restoreFileBtn');
const loadSampleDbBtn = document.querySelector('#loadSampleDbBtn');
const loadTutorialDbBtn = document.querySelector('#loadTutorialDbBtn');
const loadSampleBudgetBtn = document.querySelector('#loadSampleBudgetBtn');
//create sample db declarations
const copySampleDbWin = document.querySelector('#copySampleDb');
const copySampleDbData = document.querySelector('#copySampleDbData');
const continueBtn = document.querySelector('#continueBtn');

//const declaration above was spelled continu instead of continue but program did not notice. WHY.? Corrected to continue Dec20
//start tutorial example of Sample database# declaration  references

const tutorialSampleDbWin = document.querySelector('#tutorialSampleDb');
const tutorialSampleDbData = document.querySelector('#tutorialSampleDbData');
const tutorialContinueBtn = document.querySelector('#tutorialContinueBtn');

//end tutorial example of Sample database references

//start example of SampleBudget database# declaration  references

const sampleBudgetWin = document.querySelector('#sampleBudgetDb');
const sampleBudgetDbData = document.querySelector('#sampleBudgetDbData');
const sampleBudgetContinueBtn = document.querySelector('#sampleBudgetContinueBtn');
const flashBtn = document.querySelector('#flash');

//end sampleBudget database references

const restoreDBWinTitle = document.querySelector('#restoreDBWinTitle');
const restoreInfoP = document.querySelector('#restoreInfoP');
const restoreInfo1P = document.querySelector('#restoreInfo1P');
const restoreInfo2P = document.querySelector('#restoreInfo2P');
const nowDo = document.querySelector('#nowDo');

//new code for managing databases and database names for loading Mar 23

const flipMenu = document.querySelector('#flip');//reference for table menu bar to allow it to turn yellow May17
$("#flip").css({"background-color": "lightgrey", "border-color": "black"});//these don't work
$("#bottom").css({"background-color": "darkblue", "color": "white", "border-color": "red", "border-radius": "10px"});
const main = document.querySelector('main')
const list = document.querySelector('ul');
const cvValues = document.querySelector('#cvValues');//ul for settings screen
const record = document.querySelector('section.note-display');
const editWindow = document.querySelector('#editWin');
//reference the xtraFied window for editing
const displayDataBtn = document.querySelector('#displayData');//made global because used in createNewDB
const addFieldBtn = document.querySelector('#newField');//made global because used in createNewDB
//+reference the deleteWindow here
const deleteWindow = document.querySelector('#deleteWin');
//reference the search window
const searchWindow = document.querySelector('#searchWin');
const searchLandscapeP = document.querySelector('#searchLandscape');
const displayFullNote = document.querySelector('#displayFullNote');
const settingsScreen = document.querySelector('#settingsScreen');
const addNoteWindow = document.querySelector('#new-note');

const titleInput = document.querySelector('#title');
const bodyInput = document.querySelector('#body');
//the form element in the new note section of the HTML which contains 2 input elements
const form = document.querySelector('form');
//the button titled Create new note is the only button without id in the form section of the HTML and so the submitBtn references the Create new note button. but not used because form.onsubmit does its job
// const submitBtn is mentioned twice must be a conflict. submitBtn.onclick only occurs in the create table section.
//!!!!!!!!!
//const submitBtn = document.querySelector('form button');
//!!!!!!!!!!
const notifyP = document.createElement('p');//declared here so variable is recognized by clear preferences function=
notifyP.setAttribute('class', 'attentionBtn');
notifyP.setAttribute('style', 'text-align: center');
//instruction p in create new note for the xtraField..see section.form new-note HTML
//const dateP = document.createElement('p.date');//made global so recognized in preferences dateColorBtn..but now does not show in each instance of displayData..only the last iteration!!
const instructionPxtraFieldData = document.querySelector('#instructionP');
const inputXtraFieldData = document.createElement('input');

const creationDateBtn = document.querySelector('#creationDate');
creationDateBtn.setAttribute('class', 'attentionBtn');
const dateColorBtn = document.createElement('button');//see function viewCreationDate
//references for new, tables, manage, search
const newDBBtn = document.querySelector('#new');//HTML button in menu
	newDBBtn.disabled = false;
const addContactsBtn = document.querySelector('#addContacts');
const newDBGuideP = document.createElement('p');//for guidance info during create newDB
newDBGuideP.setAttribute('class','attentionBtn');
	
const xtraFieldBtn = document.createElement('button');//make this a global variable? See editItem
const NotesEditBtn = document.createElement('button');//made global because referenced in multiple functions needs to be here so EDIT btn is attention mode in createNewDB Nov27 2021
	
const tableScreenBtn = document.querySelector('#tableScreenBtn');//HTML button in menu to go to tableScreen window
const tableScreen = document.querySelector('#tableScrn');//reference the create a table window
const tableChosenP = document.querySelector('#tableChosen');
const showTable = document.querySelector('#tableWin');//div HTML section id="tableWin" should this be referenced earlier because clearTableWin useS it at line 3003

//newTableName window references below
const newTableNameWin = document.querySelector('#newTableNameWin');
const newTableTitle = document.querySelector('#newTableTitle');

const newTableNameInput = document.querySelector('#newName');
const newTableNameSubmitBtn = document.querySelector('#newTableNameSubmitBtn');
let newTableName = "";
const showNewTableNameP = document.querySelector('#showNewTableName');
//newTableName window references above


const tableLandscapeP = document.querySelector('#tableLandscape');

const sortWindow = document.querySelector('#sortWin');//declared as global see sort function
const viewSortBtn = document.createElement('button');//scope includes the sort function
//const selectedSortInput = document.querySelector('#sortType');
//const sortTypeDataList = document.querySelector('#sortTypeList');
const chosenSortInfo = document.querySelector('#chosenSort');
const submitSortTypeSelectionBtn =  document.querySelector('#submitSortTypeSelection');
const cancelToNotesFromSortBtn = document.querySelector("#cancelToNotesFromSort");
let chosenSortType = '';
let fromViewSort = false;//flag to disable SAVE Btn in table if from view soTrack12 to preventing permanent loss of original displayTable order not yet added to table code March 10
let sortW3 = false;//flag for alpha sort
let originalOrder = true;//flag used to prevent accidental loss of original table order by a save after a sort
const manageBtn = document.querySelector('#manage');//HTML button in menu to go to manage window
	manageBtn.disabled = false;
const searchBtn = document.querySelector('#search');//HTML button in menu to go to search window
//SyntaxError: Cannot declare a let variable twice: 'searchBtn'. so I removed let
	//searchBtn.disabled = false;
const searchTitleInput = document.querySelector('#inputSearchRecord');//input for what record to search for in searchRecord function
let caseSensitive = false;	//make global
let includesSubstring = false;//flag to make search inclusive of search phrase NOT IMPLEMENTED as probably not necessary. Code left in place and flag set to true to default to inclusive
let searchCaseSensitive = 0;	//make global
let searchIncludesSubstring = 0; //make global

let tableDateTime=true;//flag show time in DATE cell of table
let showScroll = true;//flag to show or hide scroll buttons via preferences setting see options March 19 2021
let centerTitle = false;//flag set in preferences to center the record title in notes display
let highlightDoneBtn = false;//flag used in addField function preferences
let doneRelabelBtn = document.createElement('button');//made global see addField function ?should be const ?
let trigger = 'dblclick'; //was 'copy' set the addEventListener in edit td cell of table. The other option is dblclick Oct 20 2021

const tdEditTriggerP = document.querySelector('#tdEditTrigger');//made global because it is used in tableScreenOptions as well as function options (preferences Dec20 2021)
const totalInfoP = document.querySelector('#totalInfoP');//made global because it is used in tableScreenOptions as well as function options (preferences Dec20 2021)
const sumAcrossInfoP = document.querySelector('#sumAcrossInfoP');//made global

let dbName;//global variable for database name..currently notes_dbx replaced with dataBaseName
let dataBaseName = "";//make global variable so can use in viewSettings
let newDBflag = false; //signify from createNewDataBase
let newDBGuidance; // so not made false on rerun = false;//flag to force display of createNewDB instructions
let prefBtnGreen = false;// Aug25 flag for resetting prefBtn and add note btn back to status quo after creating new db
 let defaultDBName = "";//used in restore database
 let loadSampleDb = false;//used in restore database to force load sample code Aug 12 2021
 let loadTutorialDb = false;//used in restore database to force load tutorial sample code Aug 22 2021
 let loadSampleBudget = false;//used in restore database to force load sample budget TEMPLATE
//let blocked = false;//flag used in deleteDB and getFileNames to indicate a faile deleteDB
 
let noteListItemColour;
let noteTitleColour;
let bodyColour;
let xtraFieldColour;
let fontColour;
let toggle = 0;

let savedCurrentnoteListItemColour;
let savedCurrentnoteTitleColour;
let savedCurrentbodyColour;
let savedCurrentxtraFieldColour;
let savedCurrentfontColour;
// let restoredCurrentnoteListItemColour;
// let restoredCurrentnoteTitleColour;
// let restoredCurrentbodyColour;
// let restoredCurrentxtraFieldColour;
const enterButton = document.querySelector('#submit');//make scope wider ..variable not found..in editItem
const chooseColoursWin = document.querySelector('#chooseColoursWin');
const noteFrameColor = document.querySelector('#noteFrame');
const noteTitleColor = document.querySelector('#noteTitle');
const firstDataFieldColor = document.querySelector('#firstDataField');
const secondDataFieldColor = document.querySelector('#secondDataField');
const notesFontColor = document.querySelector('#notesFontColor');

const doneChooseColorsBtn = document.querySelector('#doneChooseColors');
let restoreSavedBtn = document.createElement('button');//made global so disable works in getFileNames
restoreSavedBtn.disabled = true;//gets enabled in change colors if you save current colors	


let boggle = true;//used instead of toggle in viewCreationDate because it messed up fontColor (I had toggle changing from NUM to Boolean)
let togglex = 0;
let toggley = false;//only works everyothertime
let toggleTdInputBtn = false;//to allow edit table to clear input enary
let showExtraField = 0;//in options to hide or show extra field
//let counter = 0;
let counter;
let date;
let noteDate = false;
let viewDateWritten = false;
let dateShade = "black";//see viewCreationDate and displayData
let newField = false;//not sure this is used?
let newFieldCounter = 0;
let xtraField = 0;//might this just have to be let xtraField so all is controlled by having run addField section..otherwise starts from scratch if reloading db???
//let xtraFieldButton = false; fix did not work!
let xtraFieldBtnExists = false;//flag to fix xtraFieldBtn bug Date: Mar 6 2021
let newFieldName;
let ver = 1; //changed version variable from 1 to 2 to trigger onupgradeneeded event in order to create the 'notesVariables_os' object store
let newItem;
let xtraFieldData;
//CHANGED SETUP = 0 to setup = NULL see getDataBaseName
let setup = 0;//in displayData if no first note for admin. used to hide display of first note
let viewedThis = 0;//to show on first run notice only once .. line 327Also prevent getDataBaseName from re-running
let doneOnce = 0;//in viewCreationDate to remove extra dateColorBtn
let upgraded;//for first run of notes db guide on upgrade needed and save and get database name
let renewed = 0;//variable in refreshTable()to create header row in displayTable when coming from refrehTable
let editNote = false;//flag to force update table if notes edited
let numberOfCVtoList=7;//view settings increase for more CVs to list
//if further trouble, REMOVE THE LINE BELOW !! it causes 'attempting to assign to a readonly property error!!'.OR remove line below and replace instances of dbTableName.value or .textContent with simply dbTableName!!???..but then I don't know where dbTableName variable is declared? i forgot ;
let tableExists = 0;//to enable or disable display table button .. TO TEMPORARILY DISABLE THE tableExist variable remove it from the variable2Array. changed tableExists variable to disabledTableExists in load and get dataBaseName so Add3TableNotesVer9.5 would run correctly. Change back when needed

let 
   	variable2Array = [setup,noteListItemColour, noteTitleColour, bodyColour, xtraFieldColour, fontColour, tableExists];
	let disabledTableExists = 0;//remove when needed!!!!!!
	
	//THESE VARIABLES FOR TABLE SECTION

	//ReferenceError: Can't find variable: nextFieldName
	//bring these variables upfront to declare
	
	//let newFieldName;//title of 2nd field
	let nextFieldName;//title of subsequent fields as determined by input in a for loop
	let numberOfFields;//the counter to use in the for loop
	let numberOfDynamicFields;//number of new required fields
	let moreFields = 0;//add more dynamic fields in edit table
// 	let tableTitle;
// let paraBody;
// let displayXtraFieldData;
// 	//ReferenceError: Cannot access uninitialized variable.
// let otherVariablesArray = [tableExists,showExtraField,nextFieldName,numberOfFields,numberOfDynamicFields,tableTitle,paraBody,displayXtraFieldData];
// let variable3 = "more variables here";
//TABLE SECTION VARIABLES
//let recordCounter = 50;//MUST BE SET TO 50 or more..OTHERWISE TABLE ARRAY IS NOT CREATED. To try and reduce space in tableArray will try messing with the redefineTableArray function? April 30 2021
let recordCounter = 1;//TO REDUCE NUMBER OF NULLS IN DB DATA .. SEPT12 2021 .. to declare tableArray with a fixed number of records. Hoping to correct error in buildRecordRows re tableArray[][] undefined is not an object?? ALSO NOTE i iteration variable for savedTablesArray is set to 10, as is newTableSpecificVariables counter. Should this be changed to a variable numberOfTables ? See redefine savedTablesArray function Date: Feb5 2022
let tableTitle = [];
let copyOfTableTitle = [];
let copyOfTableArray = [];
let searchedRecordTitle = [];
//let tableTitle = ['CN6035', 'CN3205', 'CN6700'];//tableTitle array needs to be created in dbNotes?
let hits = [];//hits array used in display - highlight table has to be global

	let XtableTitle;//remove when tables fixed!!!!
//let paraBody;
//let XparaBody;
//let displayXtraFieldData;
//let XdisplayXtraFieldData;
let paraBody = [];

//let paraBody = ['Y2Trk2','Y3Trk2','Y3Trk8'];
let displayXtraFieldData = [];
//let displayXtraFieldData = ['TSU-1100','Econami-PNP','TSU-1100'];
	//all above will be variables from IndexedDBNotes
	//create the 2D array tableArray
	var tableArray = new Array(recordCounter);

//for (var i = 0; i < recordCounter; i++) {
	
for (var i = 0; i < recordCounter; i++) {

tableArray[i] = new Array(numberOfFields);

}//number of fields means all fields
//assume 10 tables?
//var savedTablesArray = new Array(10);
let savedTablesArray = [];
//for (var i = 0; i < recordCounter; i++) {

for (var i = 0; i < 10; i++) {

savedTablesArray[i] = new Array(4);

}//number of fields means all fields for savedTablesArray there are 4 fields maybe should change back to numberOfFields????
//savedTablesArray.length = 10;//tried to force length of 10 to fix tableLimit error but did not work savedTablesArray.length still 3 or whatever in Test New Table!!!!
//Create a new array for searched hits
//SearchedHitsTableArray :

var searchedHitsTableArray = new Array(recordCounter);
for (var i = 0; i < recordCounter; i++) {
searchedHitsTableArray[i] = new Array(numberOfFields);
}//number of fields means all fields

let isVariablePassed = "Yes";
//create fieldNamesArray
let fieldNamesArray = [];
	//ReferenceError: Cannot access uninitialized variable.
let newTableFieldsArray = [];
let fieldOption = [];	
let fieldDeleted = false;//flag to make displayTable show the field header with the field removed Feb 2 2021
let buildingTableArrays = 0;//this variable enables displayData to construct the tableTitle and paraBody and displayXtraFieldData arrays ? May not need???
let dateTable = [];//date array used in creating table. Note how this array is declared variable array name = []
let originalNumberRecords;//used to give option of refreshTable
let saveOriginalNumberRecords;//for reset after contactsTable

//variables used in refreshTable	
let	originalNumberOfFields = numberOfFields;
let	addedNumberOfRecords = tableTitle.length-originalNumberRecords;
let	currentNumberOfFields = fieldNamesArray.length;
let fromMakeTable = 0;//to prevent warning in displayData from popping up if displayTable btn tapped after a table has been creates..see displayTable
let displayedTable = 0;//to prevent fieldNames repeating after repeat calls to displayTable via displayTableBtn
let darkMode = null;//switch for table background color
let tableConstructed = 0;
let changeDB = false;//flag for making sure table headers display right when changing tables
let DTBtnTappedOnce = 0;//flag to disable or enable edit and deleteField buttons also used in displayTable
let editCurrentTable = 0;//so displayTable workS correctly when editing a table that pre-exists
let deleteTableRecord = 0;
let numberOfNewTableAddedFields = 0;//for edit new tables..stored in otherVariablesArray

let otherVariablesArray = [tableExists,originalNumberRecords,nextFieldName,numberOfFields,numberOfDynamicFields,tableTitle,paraBody,displayXtraFieldData];
let variable3 = showExtraField;
//pref variables
let prefVariablesArray = [viewDateWritten,dateShade,showExtraField,showScroll,centerTitle,tableDateTime,linkLabel,scrollTable,bkgrdImage,trigger,caseSensitive,includesSubstring];
//pref variables
//let savedTablesArray = [];allows 5 new tables?
//let savedTablesArray = [
//["name","date","tel","email"],[],[],[],[]
//];
//let savedTablesArray = [];//decalared globally to store saved table arrays.. this is an array of arrays
/*
//***********************
// set array length var arrayLength = 3;
let arrayLength = 4;
var savedTablesArray = [];
 var savedTablesArray = new Array(arrayLength); 
 for (var i = 0; i < savedTablesArray.length; i++) { savedTablesArray[i] = new Array(arrayLength); }
savedTablesArray[0]=["name","DATE","tel","email"];
//***********************
*/
//alert("savedTablesArray[0] = " + savedTablesArray[0]);
//var savedTablesArray = new Array(recordCounter);
//savedTablesArray[0] = ["name","DATE","tel","email"];
//savedTablesArray[1] = ["name2","DATE","tel2","email2"];
//for (var i = 0; i < recordCounter; i++) {
	//alert("savedTablesArray[0] = " +savedTablesArray[0]);
	//alert("savedTablesArray = " +savedTablesArray);
//for (var i = 0; i < recordCounter; i++) {
//var variablePassed = "YES";//this is just for testing savedTablesArray being global and available in saveNewTable function. REMOVE LATER
//savedTablesArray[i] = new Array(numberOfFields);

//}//number of fields means all fields
let newTableVariablesArray = [];//stores variablescontrolling the newtable list for a database
let newTableSpecificVariables = [];//newTableSpecificVariables[] have variables that apply to each particular newTable connected with the main db.This will contain newTableFieldsArray for each specific newTable, and the numberOfNewTableAddedFields for each newTable, ? Should it also contain the tableIndex?

let key;//can remove if myKey works
let myKey = 1;
let keyPath;
let searchNote = 0;//searchRecord code
let fromSearchRecord = false;
let noteId;
//let RecordId;//used in displayTable editing TD cell
let recordId;//used in displayTable editing TD cell and scroll btn
let editedTDchange;//used in displayTable editing TD cell
let fudgeFactor = 1;//to correct for adding record after a delete when doing search may not need MiGht eraseh
let matchedRecordIndex;
let fromFullViewItem = false;//used for proper creation of table view after a fullItemView
let fromDeleteField = false;//to add field headers back on if going to displayTable from deleteField
let fromNew = false;//flag to not show make changes Btn if New table being created
let foundRecordsList = false;//flag to clear a prexisting foundRecordsList so that a fresh loaded db does not use an old foundRecordList June 18 2021
//let json;//used in restore DB Made global variable Aug 12 2021
let sampleDbData = "";//used in restore DB if loading in sample db
const resultList = document.querySelector("#result-list");	//declared as global variable so flag above will work!!!BUT DOES ALL THIS SLOW DOWN PROGRAM FLOW??????June 18 2021
//add tableArray here

//dataVobj will compare to variable2Array, and dataV: will compare to variable2:

//tableArray = [["CN7035", "Oct 20 2020 22:21","Y2Trk2","TSU-1100","5","128","255"],["CN3205", "Oct 20 2020 22:21","Y3Trk2","Econami PNP","15","128","255"],["CN6700","Oct 20 2020 22:21","Y3Trk8","TSU-1100","77","130","190"]];	


if(setup===3) {
let	dataVobj = {
  tableArray: tableArray,
  fieldNamesArray: fieldNamesArray,
  otherVariables: otherVariablesArray,
  prefVariables: prefVariablesArray,
  variable3: variable3,
  savedTables: savedTablesArray,
  newTableVariables: newTableVariablesArray,
  tableSpecific: newTableSpecificVariables};
 } else { 
let	dataVobj = {
  tableArray: tableArray,
  fieldNamesArray: fieldNamesArray,
  otherVariables: otherVariablesArray,
  prefVariables: prefVariablesArray,
  variable3: variable3,
  savedTables: savedTablesArray,
  newTableVariables: newTableVariablesArray,
  tableSpecific: newTableSpecificVariables};//end declaration of dataV object
}//end if setup=3
//THESE VARIABLES ABOVE FOR TABLE SECTION	
	//THESE VARIABLES ABOVE FOR TABLE SECTION	
	
const dbTableName = document.querySelector('#dbTableName');//global variable for database table name title..currently NOTES references h2 in note-display section of main HTML

dbTableName.value = "Notes";
//preferences section. preferences.onclick takes you to the preferences function that in turn contains functions for each option

//the menu section nav element above main

const settingsBtn = document.querySelector('#settings');
	const aboutDBWindow = document.querySelector('#aboutDBWin');//see line 631 for aboutDBWindow code
const whatsNewWindow = document.querySelector('#whatsNewWin');
  const newUpdatesBtn = document.querySelector('#newUpdates');
	const closeUpdateWindow = document.querySelector('#closeUpdateWindow');
	const whatsNewInfoP = document.querySelector('#whatsNewInfoP');
	const newVersionInfoP = document.querySelector('#newVersionInfoP');
	const viewSettingsBtn = document.querySelector('#viewSettings');
	const numberNotes = document.createElement('p');//made global see whatsNew function
	
const prefWindow = document.querySelector('#prefWin');
//see 535 lines for continuation of preferences code
const timeDateFlagP = document.querySelector('#timeDateFlag');//this made global so both timeDate and linkLabel can use it in preferences June9
//add note code
const addNoteBtn = document.querySelector('#add');
//addNoteBtn.onclick references the Add Note button in the NAV menu, which takes you to the create note screen. the create note button is referenced by the form button in html, this being the only button in the html form section. so tapping create new note button means form.onsubmit which takes you to add data function.
const aboutDBBtn = document.querySelector('#aboutDB');
//disable aboutDBBtn until there is a file loaded so as to prevent aboutDB being locked if user taps aboutDB before a file is loaded re-enables via aboutDBBtn.onclick = choices;


//load and save

const loadBtn = document.querySelector('#loadDB');
const saveBtn = document.querySelector('#saveDatabase');

//disable SAVE if in a newTable ? Is this good or bad? Will you need this save btn to edit newTables??Date: Jan30 2022
if(makeContactsTable || loadFromTableOptions) {
	saveBtn.style.backgroundColor = "lightgrey";
	saveBtn.disabled = true;	
	} else {
	saveBtn.style.backgroundColor = "rgb(240, 248, 255)";
	saveBtn.disabled = false;
}//end if makeContactsTable || loadFromTableOptions

//-xxxx-xxx
//loadBtn.disabled = false;
//saveBtn.disabled = true;//change back to false if messed up
addNoteBtn.setAttribute('class','attentionBtn');
let today = new Date();
let todayS = today.toString();
let todayString = todayS.slice(3, 21);//21
//alert("todayS = " + todayS + ". todayString = " + todayString);
//let todayDate = today.slice(1,20);
let currentDate = todayS.slice(3, 10);
//const scrollBtn = document.querySelector('#scrollBtn');
const scrolling = document.querySelector('#scrolling');
const scrollBtn = document.createElement('button');
const bottomBtn = document.createElement("button");
bottomBtn.textContent = 'Bottom';
bottomBtn.setAttribute('class','bottomBtn');
scrollBtn.textContent = 'Scroll ⬇️';
scrollBtn.setAttribute('class','scrollBtn');
const mybutton = document.createElement("button");
mybutton.textContent = 'Top';
mybutton.setAttribute('class','myBtn')

//references for manualContacts entry code
let manualContacts = [];//array to hold manually entered contacts
let manualContactsEntered = false;
const manualContactsWindow = document.querySelector('#manualContactsWin');
const editNewTableFieldNamesWindow = document.querySelector('#editNewTableFieldNamesWin');
const contactsNameInput = document.querySelector('#contactsName');
const firstFieldLabel = document.querySelector('#firstField');0
const thirdFieldLabel = document.querySelector('#thirdField');
const fourthFieldLabel = document.querySelector('#fourthField');
const fifthFieldLabel = document.querySelector('#fifthField');
//name of fifth field manual contacts data entry
const fieldFiveNameLabel = document.querySelector('#fieldFiveNameLabel');//statement instruction identifier of fifth field name in editNewTableFieldNamesWin-the other fields labels are not referenced because they are always shown
const firstFieldNameNTInput = document.querySelector('#firstFieldNameNT');
// const oneBtn = document.querySelector('#one');
// const twoBtn = document.querySelector('#two');
// const threeBtn = document.querySelector('#three');
// const fourBtn = document.querySelector('#four');
// const fiveBtn = document.querySelector('#five');

const telephoneInput = document.querySelector('#telephone');
const secondFieldNameNTInput = document.querySelector('#secondFieldNameNT');
const contactsEmailInput = document.querySelector('#contactsEmail');
const thirdFieldNameNTInput = document.querySelector('#thirdFieldNameNT');
const contactsAddressInput = document.querySelector('#contactsAddress');
const fourthFieldNameNTInput = document.querySelector('#fourthFieldNameNT');
const fithFieldNameNTInput = document.querySelector('#fithFieldNameNT');
const manualContactsInstructionP = document.querySelector('#manualContactsInstruction');
const editNewFieldNamesInstructionP = document.querySelector('#editNewFieldNamesInstruction');
const enterContactBtn = document.querySelector('#enterContactBtn');
const enterNewFieldNameBtn = document.querySelector('#enterNewFieldNameBtn');
const clearContactEntryBtn = document.querySelector('#clearContactEntry');
const clearFieldNameEntryBtn = document.querySelector('#clearFieldNameEntry');
const cancelAllBtn = document.querySelector('#cancelAll');
const cancelAllFieldNamesBtn = document.querySelector('#cancelAllFieldNames');
const statusContactEntryP = document.querySelector('#statusContactEntry');
const statusFieldNamesEntryP = document.querySelector('#statusFieldNamesEntry');
const finishedContactsEntryBtn = document.querySelector('#finishedContactsEntry');
const finishedFieldNamesEntryBtn = document.querySelector('#finishedFieldNamesEntry');
//NCJan10..below. If messed up go back to fallBackJan10
const tableNameLi = []; 
const newTableList = document.querySelector('#newTableList');//<ol> to contain li in html
let tableListExists = false;//flag to keep table list repeating
//let tableNamed = ""// got erroe can't declare const variable twice 'tableName' so changed this to let tableNamed and commented out let tableName DEC 24 2022!! Then get error 'SyntaxError: Cannot declare a let variable twice: 'tableNamed'.' SO COMMENTED THIS OUT TOO!
let tableName = "";//made global variable ..maybe don't need this got error assigning to read only variable and corrected by changing to tableNamed ?? which is not even declared here??
//savedTablesArray = [];//decalared globally to store saved table arrays.. this is an array of arrays
// let newTableVariablesArray = [];
//ReferenceError: Can't find variable: tableNameLi
//references above for manualContacts entry code
//NCJan10.above.If messed up go back to fallBackJan10
//variables for TABLE SECTION
//let tableExists = 0;//to enable or disable display table button. this variable is declared ahead of otherVariable array to be recognized in otherVariables so can remove it here?


//determine which db to load
//leave this line in ?

//document.getElementById("dbTableName").innerHTML = dbTableName;//there was a } here why.??

if (!window.indexedDB) {
    console.log("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
}

if (window.indexedDB) {
    console.log("Your browser supports a stable version of IndexedDB. Should work.");
}
//alert("Running MESSED UPtrying3Copy of improveBudgetDougieBaseVer44.js");
//how to test if user using dark mode
var usingDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
console.log("At start 543 first reference User is using dark mode: " + usingDarkMode);
//Detect an Apple Browser 
const appleBrowser = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
let browserTest = (appleBrowser) ? "Yes":"No";//ternary operator
console.log("User is using an apple browser: " +browserTest + " " + appleBrowser);

let screenDark = false; //use as variable instead of usingDarkMode..which must be some special case? Because it won't maintain a setting? Const to var did not fix! Dec20 THIS WAS screenBlack screenDark still worked in code!
 
// Create an instance of a db object for us to store the open database in. A variable called db will be used to store an object representing our database. We will use this in a few places, so we've declared it globally here to make things easier.
let db; //global variables
let deletingDb;//global variable in delete db code section May10
let objectStoreName = "";
//let dataBaseName = ""; already declared above
let data;//I added this during testing? may not need ?
let tableNeedsUpdate = false;//flag to prevent error if returnToNotes Btn is tapped in create table window
let tableLimit = false;//flag to assess if room for more tables see checkTableLimit function
//let dataV;//see above
//let dbName;//global variable for database name..currently notes_dbx


//write all of our subsequent code inside this window.onload event handler function, called when the window's load event fires, to make sure we don't try to use IndexedDB functionality before the app has completely finished loading


//if(!newDBGuidance) {

	

window.onload = function() {

// let isDenied = false;
// let isConfirmed = false;
// let isDismissed = false;
// Swal.fire({
//   title: 'Tap LOAD to view table OTHERWISE Tap RENAME or DELETE' ,
//  // text: 'Do you want to continue',
//   icon: 'question',
//   confirmButtonText: 'LOAD TABLE',
//   showConfirmButton: true,
//   showDenyButton: true,
//   showCancelButton: true,
//   cancelButtonText: 'DELETE',
//   denyButtonText: 'RENAME'
  
// });
// if(isConfirmed) {
// alert("LOADING TABLE");
// } else if (isDenied) {
// alert("RENAMING TABLE");
// } else if (isDismissed) {
// alert("DELETING TABLE")	
// }//END IF ELSE CONFIRM DENY RENAME
// Swal.fire("Are you sure you want to do this?", {
//   buttons: ["Oh noez!", "Aww yiss!"],
// });	editWindow.setAttribute('class','hidden');
 promptBox.setAttribute('class','hidden'); deleteWindow.setAttribute('class','hidden');
displayFullNote.setAttribute('class','hidden');
prefWindow.setAttribute('class','hidden');
tableScreen.setAttribute('class','hidden');
tableScreen.setAttribute('style','background-color: red');
searchWindow.setAttribute('class','hidden');
createNewDBWindow.setAttribute('class','hidden');
manageFilesWindow.setAttribute('class','hidden');
copySampleDbWin.setAttribute('class',
'hidden');
tutorialSampleDbWin.setAttribute('class',
'hidden');


if(showScroll) {
	//ERROR TypeError: Argument 1 ('node') to Node.appendChild must be an instance of Node
scrolling.appendChild(scrollBtn);
scrolling.appendChild(mybutton);
// showTable.appendChild(bottomBtn);
scrolling.appendChild(bottomBtn);

scrollBtn.onclick = function () {
//alert("scrollBtn tapped! scrollHere = " + scrollHere);
//set up scrollBtn in NOTES to scroll to a searched record JAN 6 2023

//alert("recordId = " + recordId + ". scrollHere = " + scrollHere);
scrollBtn.textContent = "Scroll ⬇️";
if(scrollHere) {
//mybutton.click();//to start scroll from top
document.documentElement.scrollTop = 0;
//alert("recordId = " + recordId);
//alert(" recordId * 500 = " + 450*(recordId-1));
scrollAmount = 485*(recordId-2);//450!fudged amt I made to fit tried 500 480 475 450 
//alert("scrollAmount = " + scrollAmount);
window.scrollBy(0, scrollAmount);
scrollHere = false;	
} else {//end if(scrollHere)
//tableTitle[6].scrollIntoView();
window.scrollBy(0,500);
}//scrollWin();
}//end. ScrollBtn.onclick


//scroll to top button March 19 2021
//Get the button:
//const mybutton = document.getElementById("myBtn");

// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = function() {scrollFunction()};

function scrollFunction() {

  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
	if(showScroll) {bottomBtn.style.display = "block"};//necessary to have no show work why?
  } else {
    mybutton.style.display = "none";
	bottomBtn.style.display = "none";
  }//end else
}//end scroll function
mybutton.onclick = function () {document.documentElement.scrollTop = 0;}//Top
// When the user clicks on the button, scroll to the top of the document
// function topFunction() {
//   document.body.scrollTop = 0; // For Safari
 // document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
//}//end function topFunction
//showTable
// bottomBtn.onclick = function () {document.querySelector('#showTable').children[0].scrollIntoView(false);}//scrollWin();
bottomBtn.onclick = function () 
{window.scrollBy(0,3080);}//was 2080

// {document.querySelector('#scrolling').children[5].scrollIntoView(false);}//scrollWin();
}//end function if showScroll

if(!showScroll) {
	scrolling.removeChild(scrollBtn);
	scrolling.removeChild(mybutton);
	// showTable.removeChild(bottomBtn);
	//bottomBtn.style.display = "none";
	scrolling.removeChild(bottomBtn);//why does this btn not get removed?
	//$(".bottomBtn").hide();THIS CODE IS IN THE HTML jQuery section and it works
	// bottomBtn.setAttribute('style','display:none');
	}//end if !showScroll


// Open our database; it is created if it doesn't already exist
	//window.indexedDB.open('NAME OF DATABASE', version #);
// (see onupgradeneeded below)
//a request to open version 1 of a database called notes_dbx. The version number is important. If you want to upgrade your database. If this doesn't already exist, it will be created for you by subsequent code. Database operations are asynchronous.
//The call to the open() function returns an IDBOpenDBRequest object with a result (success) or error value that you handle as an event. Create a request object (which can be called anything you like — we called it request so it is obvious what it is for). You then use event handlers to run code when the request completes, fails, etc.
//code could look like this: const dbName = "the_name";  var request = indexedDB.open(dbName, 2);
//code for xtraField adds ver instead of 1

//code for managing file names of databases
//function to get database list of names
//THIS CODE FROM IDBFactory fetch database list
//variables and references for FileNames
//let dataBaseName = "";//make global variable so can use in viewSettings
let fileNameItem = [];
let numberOfDatabases = 0;
const fileNamesWindow = document.querySelector('#fileNames');
const dataBaseList = document.querySelector("#dataBaseList");
const databaseNameLi= []; 
const databaseNameMLi= []; //to distinguish between manage db list elements and load/available DBList element
const dataBaseBKUPNameLi = [];
const fileChosenP = document.querySelector('#fileChosen');

const newDBButton = document.querySelector('#newDBBtn');
//const createNewDBWindow = document.querySelector('#createNewDBWin');//referenced this earlier because it is used onwindow open
const newDBTitleInput = document.querySelector('#newDBTitle');
const submitNameButton = document.querySelector('#submitName');//Start Creating new DataBase
const cancelNewDBButton = document.querySelector('#cancelNewDBBtn');
const cancelFileNamesWindowBtn = document.querySelector('#cancelFileNamesWin');
const manageDataBaseList = document.querySelector('#manageDataBaseList');
const firstManageBtn = document.querySelector('#firstManageBtn');
const restoreDataBaseBtn = document.querySelector('#restoreDataBaseBtn');
let getFileNamesSwitch = true;//flag to aviod code running through getFileNames repeating
let dbListExists = false;//flag to act as a one time switch on first run of db to keep db list from repeating May 8
let manageDbListExists = false;//flag to prevent manageDbList from repeating
let dbDeleted1 = false;//flag to allow notice of db deletion in Current Database File Names
let dbDeleted2 = false;
let dbDeletedName1 = "";//to preserve name for deleted db notice in getFileNames May10
let dbDeletedName2 = "";
let dbDeleted3 = false;
let dbDeletedName3 = "";
let dbDeleted4 = false;
let dbDeletedName4 = "";
let dbFileNameRenamed = false;//flag to allow notice of db renaming in Current Database File Names
let dbFileNameRenamedName = "";//to preserve name for renamed db notice in getFileNames May10

let dbRestored = false;//flag to allow notification of db restored in getFileNames
let formatFailed = false;//flag indicating check failed. Used in restoreDataBase()
const cancelbackupDataBaseButton = document.querySelector('#cancelBackupDataBaseBtn');

const backupDataBaseList = document.querySelector('#backupDataBaseList');
const selectedDBinfoP = document.querySelector('#selectedDBinfo');
const backupFileNamesList = document.querySelector('#backupFileNamesList');
const backingUpDBWin = document.querySelector('#backingUpDBWin');
const backingUpBanner = document.querySelector('#backingUpBanner');
const textarea = document.querySelector('#textAreaClip');//made global
const restoreDBWindow = document.querySelector('#restoreDBWin');//made global
const restoreDBInstructions = document.querySelector('#restoreDBInstructions');//made global HTML DIV
const restoreInstructionsP = document.querySelector('#restoreInstructionsP');//made global
const restoreDBNameInput = document.querySelector('#restoreDBNameInput');
let restoredDBName = "";//made global variable
const restoreDBNameBtn = document.querySelector('#restoreDBNameBtn');
//const getJsonBtn =  document.querySelector('#getJson');//made global so finished btn could change its attribute
const restoreTextArea = document.querySelector('#restoreTextAreaClip');//HTML textarea to paste backup clip
const readyNotice = document.createElement('p');//in restoreDataBase announce job done
let fromRestore = false;//flag to indicate from restore to logically navigate the createNewDB code
let json ="";

//dark mode selected Dec18
checkScreenMode();
if(usingDarkMode) {
	showTable.style.backgroundColor = "black";
	showTable.style.color = "white";
	$("#flip").css({"background-color": "lightgrey", "color":"black", "border-color": "red"});//these don't work
	
	//bodyImage.setAttribute('class','showDark');
	//bodyImage.style.color = "white";
	
}//end if usingDarkMode
if (!usingDarkMode) {
	showTable.style.backgroundColor = "#eee";
	showTable.style.color = "black";
	$("#flip").css({"background-color": "lightgrey", "color":"black", "border-color": "black"});//these don't work
	
	//bodyImage.setAttribute('class','showLite');
	//bodyImage.style.backgroundColor = "white";
	//bodyImage.style.color = "black";
}//end if !usingDarkMode



//variables and references for FileNames^

function getFileNames(dataBaseName) {
//btn persists even if ignored after rescued save, but still seen here because save code unsets the btns..so in home clear table btn at leasr set btns to tdEdit or display none?
backupBtn1.style.display = "none";
 backupBtn2.style.display = "none";
 
 
	//alert("savedTablesArray[0] = " + savedTablesArray[0]);
	//restoreSavedBtn.disabled = true;//gets enabled in change colors if you save current colors	
	
	//flag that prevents dbList from repeating May 8. THIS WORKS!
console.log('At getFileNames. dbListExists = ' + dbListExists);
	if(dbListExists || loadSampleDb || loadTutorialDb) {
		while (dataBaseList.firstChild) {
   dataBaseList.removeChild(dataBaseList.firstChild);
		};//end while
loadSampleDb = false;
loadTutorialDb = false;
//loadSampleBudget = false;//not sure why this was added here but in doing so it voids flashing prompts at bottom of getFileNames screen … so COMMENTED OUT Date: Dec17 2023
	};//end if dbListExists
	
	loadSampleDb = false;//added Aug 20
	loadTutorialDb = false;//added Aug 22
	//loadSampleBudget = false;//not sure why this was added here but in doing so it voids flashing prompts at bottom of getFileNames screen … so COMMENTED OUT Date: Dec17 2023
	console.log('In getFileNames. Here from a re-run OR menu button..New/ChangeDB');
	getFileNamesSwitch = false;
fileNamesWindow.setAttribute('class','showing');
//date Mar27 2023 hide the blank p at start if empty
if(fileChosenP.textContent === "") {
	fileChosenP.style.visibility = "hidden";
	} else {
	fileChosenP.style.visibility = "visible";
	//fileChosenP.setAttribute('class','simulator');
	}//end if(fileChosenP.textContent === "")	
//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	fileNamesWindow.style.backgroundColor = "black";
	fileNamesWindow.style.color = "white";
	
	//dataBaseList.setAttribute('class','olDark');
	//fileNamesList.style.color = "white";//does not work
	// dataBaseList.style.color = "black";
	// dataBaseList.style.backgroundColor = "white";
	// dataBaseList.style.radius = "5px";
} else {
	fileNamesWindow.style.backgroundColor = "#eee";
	fileNamesWindow.style.color = "black";
	//dataBaseList.setAttribute("style","color:black,backgroundColor:white");
	//dataBaseList.style.color = "black";
}//end if else screenDarkv

//alertblk("Creating filenames list .. in getFileNames:  blockedName[0] = " + blockedName[0]  +" blockedName[1] = " +blockedName[1] + " blockedName[2] =  "+ blockedName[2] + " blockedName[3] = " +blockedName[3] +  " dbDeleted[0] = " + dbDeleted[0] + " dbDeleted[1] = " + dbDeleted[1] + " dbDeleted[2] = " + dbDeleted[2] + " dbDeleted[3] = " +dbDeleted[3]+ " blocked[0] = " + blocked[0] + " blocked[1] = " + blocked[1] + " blocked[2] = " + blocked[2] + " blocked[3] = " + blocked[3] + " dbDeletedName[0] = " + dbDeletedName[0] + " dbDeletedName[1] = " + dbDeletedName[1] + " dbDeletedName[2] = " + dbDeletedName[2] + "dbDeletedName[3] = " + dbDeletedName[3]);
//alert("In getFileNames - at very start promise about to run: mustTapRestore = " + mustTapRestore);

const promise = indexedDB.databases()
//A promise that resolves either to an error or a list of dictionaries, each with two elements, name and version.
//checkScreenMode();

promise.then(databases => {
 // console.log(databases);my code below
  for (let i = 0; i< databases.length; i++) {
	  
	  let dbNumber = i + 1;
	  // if(screenDark) {
	  // dbNumber.style.color = "white";
	  // } else {
	  // dbNumber.style.color = "black";
	  // }//end if else screenDark
	  console.log('databases = ' + databases)
	  console.log('databases.length = '+ databases.length);
	  console.log('Database # ['+ dbNumber +'] is ' + databases[i].name);
databaseNameLi[i] = document.createElement('li');

if(databases[i].name === "Monthly Expenses - TEMPLATE.bs") {
databaseNameLi[i].style.backgroundColor = "lightgreen";	databaseNameLi[i].setAttribute('class','borderBlink');
}//end if(databases[i].name === "Monthly Expenses - TEMPLATE.bs")

// if(databases[i].name.includes(".creatingDB") && newDBflag || databases[i].name.includes(".creatingDB") && newDBGuidance){
// databaseNameLi[i].style.backgroundColor = "lightgrey";	databaseNameLi[i].setAttribute('class','borderBlink');
// }//end if(databases[i].name.includes(".creatingDB" && newDBFlag
//IF COMING FROM RELOAD PAGE AFTER FIRST SEGMENT OF CREATENEWDB FLASH THE NEW DB FILENAME IN THE LIST
if(!newDBflag && newDBGuidance === undefined && databases[i].name.includes(".creatingDB")){
databaseNameLi[i].style.backgroundColor = "lightgreen";	databaseNameLi[i].setAttribute('class','borderBlink');

//databaseNameLi[i].textContent =  ". DELETE this" at this stage there is no textContent?? Does not work a yway?? Why?
 }//end if(!newDBflag && newDBGuidance === undefined && databases[i].name.includes(".creatingDB"))

// if(creationDONE) {
// //code to remove .creatingDB which maybe should be changed to -creatingDB in case js thinks its a method!	
// //code to rename db with tag removed
// //dataBaseName = databases[i].name;
// dataBaseName = dbTableName.value;//helps insure dataBaseName is not wiped out in creation new db process
// alert("dataBaseName = " + dataBaseName);
// //renameDataBaseFileName(dataBaseName);
// dbFileName.textContent = dataBaseName.substring(0, dataBaseName.length-11);//trim off .creatingDB
// renamedFileName = dbFileName.textContent; 
// reNamedDBFileName = true;
// dbTitle.textContent = renamedFileName;
// dbTableName.value = renamedFileName//dbTableName is stored in variable1 and represents the variable in view settings that reflects the table name 
// saveVariables();
// backupDataBase(dataBaseName);//go to backup with original name!! And new filename is now in variable 	 renamedFileName = dbFileName.textContent


// //NOW NEED TO RETURN TO FILE NAMES WITH RESTORE BTN BLINKING
// //code to rename db with tag removed

// //creationDONE = false;
// }//end if(creationDONE)
// if(databases[i].name.includes(".creatingDB") && !newDBFlag || databases[i].name.includes(".creatingDB") && !newDBGuidance) {
// alert("condition met");
// databaseNameLi[i].style.backgroundColor = "yellow";	//databaseNameLi[i].setAttribute('class','borderBlink');
// //code to rename db with tag removed
// dataBaseName = databases[i].name;
// //renameDataBaseFileName(dataBaseName);
// dbFileName.textContent = dataBaseName.substring(0, dataBaseName.length-11);//trim off .creatingDB
// renamedFileName = dbFileName.textContent; 
// reNamedDBFileName = true;
// dbTitle.textContent = renamedFileName;
// dbTableName.value = renamedFileName//dbTableName is stored in variable1 and represents the variable in view settings that reflects the table name 
// saveVariables();
// backupDataBase(dataBaseName);//go to backup with original name!! And new filename is now in variable 	 renamedFileName = dbFileName.textContent
// //string = manipulateString(string);
// //NOW NEED TO RETURN TO FILE NAMES WITH RESTORE BTN BLINKING
// //code to rename db with tag removed


// // }//end if(databases[i].name.includes(".creatingDB" && !newDBFlag)

//if(flashing && databases[i].name.includes("-tag"||"*" ||"!" || "✅" ||"♥️"||"🔴"||"❗️")) {

// 
if(flashing && databases[i].name.includes("*") || flashing && databases[i].name.includes("!") || flashing && databases[i].name.includes("-tag") || flashing && databases[i].name.includes("✅") || flashing && databases[i].name.includes("♥️") || flashing && databases[i].name.includes("🔴") || flashing && databases[i].name.includes("❗️")) {
databaseNameLi[i].style.backgroundColor = "yellow";	databaseNameLi[i].setAttribute('class','borderBlink');
}//end if(databases[i].name 

// if(screenDark) {
// 	databaseNameLi[i].style.color = "black";
// 	  } else {
// 	  databaseNameLi[i].style.color = "black";
// 	  }//end if else screenDark
//for (c = 0;c<blockedName.length;c++) {
//if(databases[i].name === blockedName[c]) {
	
//ON RETURN FROM LOAD(DATABASENAME) AFTER A REBOOT, blockedName[0] = Red Peppers

if(databases[i].name === blockedName[0]||databases[i].name === blockedName[1]||databases[i].name === blockedName[2]||databases[i].name === blockedName[3]||
databases[i].name === blockedName[4] ||
databases[i].name === blockedName[5] ||
databases[i].name === blockedName[6] ||
databases[i].name === blockedName[7] ||
databases[i].name === blockedName[8] ||
databases[i].name === blockedName[9] ||
databases[i].name === blockedName[10] ||
databases[i].name === blockedName[11] ||
databases[i].name === blockedName[12] ||
databases[i].name === blockedName[13] ||
databases[i].name === blockedName[14] ||
databases[i].name === blockedName[15]) {
//covers case where databases[i].name is not matched to name.blocked added Feb16 2023
//if(databases[i].name === blockedName) {
// if(!dbDeleted1) {dbDeleted1 = true;dbDeletedName1 = dataBaseName;}
// 	else if(dbDeleted1) {dbDeleted2 = true;dbDeletedName2 = dataBaseName;
// 	}else if(dbDeleted2) {dbDeleted3 = true;dbDeletedName3 = dataBaseName;
// 	}else if(dbDeleted3) {dbDeleted4 = true;dbDeletedName4 = dataBaseName;}
//CODE HERE TO AUTOMATICALLY DELETE ORIGINAL DB ?
//The filename that was supposed to be deleted but was blocked will still be in the browsers filelist
//NOTE THAT THE FILE NAMES LIST WILL NOT KNOW dataTableName.value for every file in the browser because it will not have opened any particular file yet. This info will only be available after the addEventListener is activated on a particular filename. So at this point .includes("blocked" won't work yet! This will only work in the addEventListener code section. That is why at this juncture we are using the blockedNames array.)
//A BLOCKED FILE WILL GREY OUT IF THE PROGRAM HAS NOT REBOOTED, BUT IF AFTER A REBOOT, blockedName[] IS NOT KNOWN SO YOU HAVE TO CHECK IN LOAD THE DATABASE (after addEventListener)

	 databaseNameLi[i].textContent = databases[i].name + " BLOCKED BY BROWSER! ";

 databaseNameLi[i].setAttribute('class','blocked');
	 databaseNameLi[i].style.backgroundColor = "lightgrey";//does not work ? It worked!
// } else if (databases[i].name.includes(".creatingDB") && !newDBflag) {//firstLOAD did not work
// 	 databaseNameLi[i].textContent = databases[i].name + "… DELETE this";//this does not work because reload sets all variables to default false
////covers case where databases[i].name is not matched to name.blocked added Feb16 2023, or case where a filename includes.blocked….raises the prospect of having the objectstore name changed to _os.blocked using manipulate string function??  then failsafe that the blocked file would be known..puut this code in the delete(dataBaseName) function and saveVariables? ..then you could just use .includes"blocked" instead of the blockedNames[] which I am suspicious of in terms of future screw ups with filenames??? Feb17 2023

//cover case where user repeats a sample budget while 	browser still has a lock on the budget template
// if(databases[i].name.includes("Monthly Expenses - TEMPLATE.bs") && loadSampleBudget && !TEMPLATEblocked) {//should mean a second budget sheet is being created before the previous template cleared
// alert("The browser has blocked the previous Budget TEMPLATE! To create another TEMPLATE you must wait for the browser to release its LOCK on the previous TEMPLATE…OR you can restart DougieBase and manually DELETE the (blocked) Template. CONTINUE CREATING YOUR NEW BUDGET SHEET BY TAPPING THE OK BUTTON! IF YOU ARE NOW TRYING TO CREATE ANOTHER BUDGET SHEET YOU HAVE TO WAIT FOR THE BROWSER TO RELEASE ITS LOCK ON THE PREVIOUS TEMPLATE. Tap CANCEL to RETURN TO HOME SCREEN.");
// TEMPLATEblocked = true;

// //loadSampleBudget = false;//don't change this variable because you might be in the process of creating a budget sheet
// //fromRestore = false;
// changeMonthBtn1.style.display = "none";
// 	changeMonthBtn2.style.display = "none";
// 	tableScreenBtn.setAttribute('class','tdEdit');
// 	selectedDBinfoP.textContent =  "The browser has temporarily blocked the previous TEMPLATE. Wait for the browser to release its LOCK before trying to create another budget sheet.";
// 	fileChosenP.textContent =  'The browser has temporarily blocked the previous TEMPLATE. Try again after the browser releases its LOCK!';
// 	//clear the list so no repeats in list
// 	for (let i = 0; i< databases.length; i++) { 
// 				dataBaseList.removeChild(databaseNameLi[i]);
// 			}//end for loop
// getFileNames();
// //return;
// }//end if databases[i].name.includes("blocked") && loadSampleBudget 
//I don't believe the filename ever includes blocked?on a reboot you only know if a file is blocked is by tapping on, loading and checking data.variable1(dbTableName.value)..so have to go through addEventListener code!
} else if (databases[i].name.includes("blocked")) {
databaseNameLi[i].setAttribute('class','blocked');
	 databaseNameLi[i].style.backgroundColor = "lightgrey";
	 } else {
	 databaseNameLi[i].textContent = databases[i].name;
	 }//end if else (databases[i].name === blockedName)
	// }//end for c= 
	 //code to blink border if newDBGuidance = true Nov29 does not work?
	 console.log('At getFilenames - newDBGuidance = ' + newDBGuidance);
// if(databases[i].name === "Monthly Expenses - TEMPLATE.bs") {
// databaseNameLi[i].style.backgroundColor = "lightgreen";	databaseNameLi[i].setAttribute('class','borderBlink');
// }//end if(databases[i].name === "Monthly Expenses - TEMPLATE.bs")
 
	 //CODE BELOW YOU WANT IN THE EVENT LISTENER BLOCK OTHERWISE ALL FILENAMES WILL BE DECORATED FOR NEWDB whoops NO
	//  if (newDBGuidance) {
	// //	if(databases[i].name = newDBName) { databaseNameLi[i].setAttribute('class','borderBlink');//?can't style a li?
	// 	 databaseNameLi[i].style.backgroundColor = "lightgreen";
	// 	 //}//end if(databases[i].name = newDBName)
	//  }//end if newDBGuidance
	 
//changed dblclick to just click in addEventListener to avoid magnification Date: Oct5 2021	

//alert("In getFileNames bkupAlertsFlag = " + bkupAlertsFlag);//does not like this alert pgrm locks up

databaseNameLi[i].addEventListener('click', function () {

//BELOW CODE ADDED FEB24 to cover scenario where backup btn is ignored after initial save ignored and then rescued by first tap of changeDB, and return sends you direct to getfilenames without benefit of backup rescue code

//If messes up resort to fallBack2Feb24tryAgainbackupClickDougieBaseVer46
//alert("In addEventListener of getFileNames - bkupAlertsFlag = " + bkupAlertsFlag);
//at getFileNames..if selecting a new file after using or editing a previous one variables dataNotBackedUp and dbTableName.value are known. No point backing up a blocked file which is about to be deleted! Mar9 BUT REMBER DOUGIEBASE DOES NOT KNOW VALUE OF dbTableName until after it loads in the file and 
//alert("bkupAlertsFlag = " + bkupAlertsFlag + " loadSampleDb = " + loadSampleDb + " ");

if(bkupAlertsFlag && dataNotBackedUp && !(dbTableName.value.includes("blocked"))) {
	if (window.confirm("You have recently saved data to " + dbTableName.value + " that is not backed up! BACKUP RECENTLY SAVED DATA ? : \n" + "  CANCEL will continue without backup.")) {
	dataBaseName = dbTableName.value;
	//line above reverts dataBaseName back to dbTableName.value for the backup
	//alertbkup("After choice prompt…going to bkup - dataNotBackedUp = " + dataNotBackedUp + " dataBaseName = " + dataBaseName + " dbTableName.value = " + dbTableName.value);
//if renamedDBName = true dbTableName.value will have had its name stripped of .bs and then in the meantime renamedDBName has been made false manipulate string called in the backup code will not be called and so the opportunity to restore dataBaseName.bs is lost. So check before going to backup that if budgetsheet dataBaseName has .bs on the end otherwise you get a path taking you through onupgradeneeded	Date:Mar 11 2023
//should brackets be around !(dbTableName.value.includes("blocked"))??Date:Mar28 2023? Line 1386 addEventListener of getFileNames()
//this line gards against this situation Mar11
if(budgetSheet && !(dataBaseName.includes("bs"))) {
		dataBaseName = dataBaseName + ".bs";
	}//end if(budgetSheet && !(dataBaseName.includes("bs")))
//alert("in getFileNames going to backup after prompting if you want to backup, budgetSheet flag = " + budgetSheet + " dataBaseName = " + dataBaseName);

reNamedDBFileName = false;//this flag prevents backup routine from going to manipulateString Mar9 Mar 11 2023	
	backupDataBase(dataBaseName);
	dataNotBackedUp = false;
	} else {
		dataNotBackedUp = false;//has to be false as well otherwise you continually get backup warning and with the wrong database as dataBaseName will now become the tapped on filename
		//return;
	}//end confirm backup prompt

}//end if(dataNotBackedUp)

//ABOVE CODE ADDED FEB24 to cover scenario where backup btn is ignored after initial save ignored and then rescued by first tap of changeDB, and return sends you direct to getfilenames without benefit of backup rescue code

// //trigger SAVE warning if unsaved data in another database prior to loading in a new one. SHOULD THIS CODE BE IN THE NEW/CHANGE DB code section
// if(dataNotBackedUp) {
// 	if (window.confirm("You have recently saved data that is not backed up! BACKUP RECENTLY SAVED DATA ? : \n" + "  CANCEL will continue without backup.")) {
// 	backupDataBase(dataBaseName);
// 	dataNotBackedUp = false;
// 	} else {
// 		dataNotBackedUp = false;//has to be false as well otherwise you continually get backup warning and with the wrong database as dataBaseName will now become the tapped on filename
// 		//return;
// 	}//end confirm backup prompt

// }//end if(dataNotBackedUp)

		//put name of database in global variable dataBaseName
		checkIfBlocked = i;////IF DOING A DELETE THAT IS BLOCKED dbTableName (Variable1: is set to dataBaseName + .blocked..see deleteDataBase function and in loadDataBase the blocked name is returned and getFilenames is called again, and this time knows that the filename matches a blocked filename and acts accordingly
		
		dataBaseName = databases[i].name;
		
		//alert("In getFileNames after prompt for backup of previous unsaved database - dataBaseName = " + dataBaseName + " dataBaseName should not be the previous database at this point! It should be the file just tapped.");

if(dataBaseName.slice(-2) === "bs") {
//alert(dataBaseName + " is a Budget sheet!")	;
budgetSheet = true;
} else {
	budgetSheet = false;
}//end if else dataBaseName.slice(-2) === "bs"
		
	//code to clear head row so table is not messed up when switching between db	 
	// if (tableExists) {
	// 		//clearHeadRow();
	// 	//displayedTable = 0;
	// 	//tableConstructed = 0;
	// 	//removeFieldHeaders();
	// 	//clearHeadRow();
	// 	//trimHeadRow();
	// 	//addFieldHeaders();
	// }//end if tableExists
	
//To catch situation where wrong db is clicked on		
if(loadSampleBudget && dataBaseName !== "Monthly Expenses - TEMPLATE.bs") {
	alert("You have not tapped on Monthly Expenses - TEMPLATE.bs. Try again or CANCEL.");
	 //getFileNames();
	 return;
	}//end if(loadSampleBudget && dataBaseName !== "Monthly Expenses - TEMPLATE.bs")


//IF USER SELECTS A DATABASE FILE THAT HAD BEEN DELETED BY BROWSER AUTOMATICALLY AFTER A FILENAME CHANGE OR CREATING A NEW BUDGET SHEET FOR EXAMPLE, (THAT HAS JUST BEEN DELETED BY BROWSER BECAUSE BROWSER RELEASED ITS LOCK) THEN DOUGIEBASE ENDS UP TRYING TO LOAD A DATABASE THAT NO LONGER EXISTS AND SO IT THINKS A NEW DATABASE HAS TO BE CREATED…ONUPGRADE NEEDED IN LOADTHEDATABASE FUNCTION.!!! So its bad timing if user inadvertantly selects a file that the browser is waiting to delete, and that deletion has just occurred immediately prior to selecting that file to load…ERROR! So therefore will put code in deleteDataBase function that will call getFileNames to immediately refresh the list of available databases thus preventing the user from clicking on a file that is deadman walking!
// if (blocked[0] && blockedName[0] === dataBaseName || blocked[1] && blockedName[1] === dataBaseName || blocked[2] && blockedName[2] === dataBaseName || blocked[3] && blockedName[3] === dataBaseName) {


// for(c=0;c<5;c++) {
// alert("blockedName[" + c + "] = " + blockedName[c] + " databases[" + i + "].name = " + databases[i].name)
	
// }//end for loop

if(databases[i].name === blockedName[0]||databases[i].name === blockedName[1]||databases[i].name === blockedName[2]||databases[i].name === blockedName[3]||
databases[i].name === blockedName[4] ||
databases[i].name === blockedName[5] ||
databases[i].name === blockedName[6] ||
databases[i].name === blockedName[7] ||
databases[i].name === blockedName[8] ||
databases[i].name === blockedName[9] ||
databases[i].name === blockedName[10] ||
databases[i].name === blockedName[11] ||
databases[i].name === blockedName[12] ||
databases[i].name === blockedName[13] ||
databases[i].name === blockedName[14] ||
databases[i].name === blockedName[15] ||
databases[i].name.includes("blocked")) {

//THIS ALL IS CORRECT IF RED PEPPERS BLOCKED AND YOU REBOOT AND SELECT FROM GETFILENAMES. IF YOU SELECT FROM MANAGE FILES : without another reboot, works as advertised! But now try a reboot afresh and select from MANAGE files….select and tap delete database:..AND IT WORKS,! The database Red Peppers is deleted!!! SO A SCENARIO IN WHICH Red Peppers is renamed to Green Peppers works and other files load in as they should, and the Red Peppers file waits for deletion as it should.

//if (blocked && blockedName === dataBaseName) { AND IF THE PROGRAM HAS NOT REBOOTED! so blockedName[] is known

		alert(dataBaseName + ": The file is still blocked by the browser. Waiting for browser's Lock to time-out!");
	return;
	//getFileNames();
}//end if (blocked && blockedName === dataBaseName) 
	
		 fileChosenP.textContent = ' Database Selected: '+ databases[i].name;
		 console.log('dataBaseName = ' + dataBaseName);
	 //confirm choice window
		 if (window.confirm("DataBase to LOAD : " + " \n" + dataBaseName +  " \n" + "  CANCEL will UNDO")) {
		 
		 if(loadSampleBudget) {
			 tableScreenBtn.setAttribute('class','borderBlink');//prompting to go to table and tap changeMonth btn
	//fileChosenP.setAttribute('class','tdEdit')//reset from flashing
	
	fileChosenP.setAttribute('class','simulator');//reset from flashing
	
		 }//end if(loadSampleBudget) 
		 
			for (let i = 0; i< databases.length; i++) { 
			
			dataBaseList.removeChild(databaseNameLi[i]);
			}//end for loop
			 fileNamesWindow.setAttribute('class','hidden');
			 //clear previousVariables Mar 28
			 resetVariables();
			 //trying to make dataBaseName variable global!
			 dbName = dataBaseName;
			 //line below added Nov24 2022.. if table !exists this might produce an error? This will? also make table name AIWAYS = filename ..even if renamedb is run? No table name stays as previously saved in data.variable1 Is this wanted???..should be able to remove this line? Dec22 2022
			 
		// 	 dbTableName.value = dataBaseName;
		// alert("dbTableName.value = " + dbTableName.value)	; 
		
			 //clear previous settings from newTable selections
			newTableVariablesArray.length = 0; 
			newTableSpecificVariables.length = 0;
			tableIndex = -1;
			newTableEdit = false;
			newTableNames.length = 0;
			tableListExists = false;
			
		loadTheDataBase(dataBaseName);//WILL CHECK FOR A BLOCKED FILE IF REBOOTING FROM START!
	//if can't find file because dataBaseName has been changed then  DougieBase will think it is creating a new database! Mar9	
			console.log('Sending dataBaseName ' + dataBaseName + ' to loadTheDataBase function');
			} else {
				//return to fileNames screen. Need to remove the previous fileNames?
			for (let i = 0; i< databases.length; i++) { 
				dataBaseList.removeChild(databaseNameLi[i]);
			}//end for loop
			fileNamesWindow.setAttribute('class','hidden');	
			//getFileNames();//changed to just hide the window otherwise database list keeps growing
				}//end if window.confirm else ...
	
				//confirm choice window
		 
	 });//end addEventListener
	 
	 
	 dataBaseList.appendChild(databaseNameLi[i]);
	 console.log('Database to load is ' + dataBaseName);
 		
	}//end for i = 0;i < databases.length
	
	dbListExists = true;//flag to prevent list repeating. A one time switch
	//alert("databases[1].name = "+ databases[1].name + " blockedName === " + blockedName + "dbDeleted1 = " +dbDeleted1 + " blocked = " + blocked + " blocked2 = " + blocked2 + " dbDeletedName1 = " + dbDeletedName1);
	//alert("databases[1].name = "+ databases[1].name + " blockedName === " + blockedName + "dbDeleted1 = " +dbDeleted1 + " blocked = " + blocked + " blocked2 = " + blocked2);
if(mustTapRestore) {
//code below added Sept26 to scroll to bottom of element with id = 'id of element'
//alert("In mustTapRestore..about to scroll to bottom! fileNamesWindow.scrollHeight = " + fileNamesWindow.scrollHeight);		
	//const scrollToBottomFiles = (id) => {
	// const element = document.getElementById(id);
	
   fileNamesWindow.scrollTop = fileNamesWindow.scrollHeight;
//}	
//scrollToBottomFiles('fileNamesWindow');//this is a function expression..element id is passed as a parameter to the scrollToBottom function expression.
mustTapRestore = false;	
}//end if(mustTapRestore)	

	if (dbDeleted[0] && !blocked[0]) {fileChosenP.textContent = dbDeletedName[0] + ' successfully DELETED!';dbDeleted[0] = false;}
	if (dbDeleted[1] && !blocked[1]) {fileChosenP.textContent = dbDeletedName[1] + ' successfully DELETED!';dbDeleted[1] = false;}
	if (dbDeleted[2] && !blocked[2]) {fileChosenP.textContent = dbDeletedName[2] + ' successfully DELETED!';dbDeleted[2] = false;}
	if (dbDeleted[3] && !blocked[3]) {fileChosenP.textContent = dbDeletedName[3] + ' successfully DELETED!';dbDeleted[3] = false;}
	if (dbDeleted[4] && !blocked[4]) {fileChosenP.textContent = dbDeletedName[4] + ' successfully DELETED!';dbDeleted[4] = false;}
	if (dbDeleted[5] && !blocked[5]) {fileChosenP.textContent = dbDeletedName[5] + ' successfully DELETED!';dbDeleted[5] = false;}
	if (dbDeleted[6] && !blocked[6]) {fileChosenP.textContent = dbDeletedName[6] + ' successfully DELETED!';dbDeleted[6] = false;}
	if (dbDeleted[7] && !blocked[7]) {fileChosenP.textContent = dbDeletedName[7] + ' successfully DELETED!';dbDeleted[7] = false;}
	if (dbDeleted[8] && !blocked[8]) {fileChosenP.textContent = dbDeletedName[8] + ' successfully DELETED!';dbDeleted[8] = false;}
	if (dbDeleted[9] && !blocked[9]) {fileChosenP.textContent = dbDeletedName[9] + ' successfully DELETED!';dbDeleted[9] = false;}
	if (dbDeleted[10] && !blocked[10]) {fileChosenP.textContent = dbDeletedName[10] + ' successfully DELETED!';dbDeleted[10] = false;}
	if (dbDeleted[11] && !blocked[11]) {fileChosenP.textContent = dbDeletedName[11] + ' successfully DELETED!';dbDeleted[11] = false;}
	if (dbDeleted[12] && !blocked[12]) {fileChosenP.textContent = dbDeletedName[12] + ' successfully DELETED!';dbDeleted[12] = false;}
	if (dbDeleted[13] && !blocked[13]) {fileChosenP.textContent = dbDeletedName[13] + ' successfully DELETED!';dbDeleted[13] = false;}
	if (dbDeleted[14] && !blocked[14]) {fileChosenP.textContent = dbDeletedName[14] + ' successfully DELETED!';dbDeleted[14] = false;}
	if (dbDeleted[15] && !blocked[15]) {fileChosenP.textContent = dbDeletedName[15] + ' successfully DELETED!';dbDeleted[15] = false;}
	
	
	// if (dbDeleted1 && !blocked ||dbDeleted2 && !blocked2 ){
	// 	fileChosenP.textContent = dbDeletedName + ' successfully DELETED!';
	
	//	if(blocked) {blocked = false;}
	//	if(blocked2) {blocked2 = false;}
		//blocked = false;//moved to if (dbDeleted) Dec15 2022 to avoid glitch in program flow if delete is attempted again!
	//	dbDeleted = false;
		//dbDeletedName = "";
	//}//end if dbDeleted	
	
	if(blocked[0]) {
	
	//might this code work? Added Mar 28 2023 YES THIS WORKS LEAVE IT! April1
	if(blockedName[0]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
		//might need this line so fileChosenP is not stuck on Deletion successful msg all the time.
		blocked[0] = false;
	} else {
	
		//might this code work?
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[0] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[0]==="")
		//maybe use blockedName instead of dbDeletedNameDate:Dec19 2022
		}////end if(blocked[0])
if(blocked[1]) {

//might this code work? Added Mar 28 2023
	if(blockedName[1]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[1] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[1]==="")
		//maybe use blockedName instead of dbDeletedNameDate:Dec19 2022
		}//end if blocked1
if(blocked[2]) {

//might this code work? Added Mar 28 2023
	if(blockedName[2]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[2] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[2]==="")
			
		//maybe use blockedName instead of dbDeletedNameDate:Dec19 2022
		}//end if blocked2
if(blocked[3]) {

//might this code work? Added Mar 28 2023
	if(blockedName[3]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[3] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[3]==="")
		//maybe use blockedName instead of dbDeletedNameDate:Dec19 2022
		}//end if blocked3
if(blocked[4]) {

//might this code work? Added Mar 28 2023
	if(blockedName[4]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[4] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[4]==="")
			}//end if blocked4
			
if(blocked[5]) {

//might this code work? Added Mar 28 2023
	if(blockedName[5]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[5] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[5]==="")
			}//end if blocked5
if(blocked[6]) {

//might this code work? Added Mar 28 2023
	if(blockedName[6]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[6] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[6]==="")
			}//end if blocked6
if(blocked[7]) {

//might this code work? Added Mar 28 2023
	if(blockedName[7]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[7] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[7]==="")
			}//end if blocked7
if(blocked[8]) {

//might this code work? Added Mar 28 2023
	if(blockedName[8]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[8] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[8]==="")
			}//end if blocked8
if(blocked[9]) {

//might this code work? Added Mar 28 2023
	if(blockedName[9]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[9] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[9]==="")
			}//end if blocked9
if(blocked[10]) {

//might this code work? Added Mar 28 2023
	if(blockedName[10]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[10] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[10]==="")
			}//end if blocked10
if(blocked[11]) {

//might this code work? Added Mar 28 2023
	if(blockedName[11]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[11] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[11]==="")
			}//end if blocked11
if(blocked[12]) {

//might this code work? Added Mar 28 2023
	if(blockedName[12]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[12] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[12]==="")
			}//end if blocked12
if(blocked[13]) {

//might this code work? Added Mar 28 2023
	if(blockedName[13]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[13] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[13]==="")
			}//end if blocked13
if(blocked[14]) {

//might this code work? Added Mar 28 2023
	if(blockedName[14]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[14] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[14]==="")
			}//end if blocked14
if(blocked[15]) {

//might this code work? Added Mar 28 2023
	if(blockedName[15]==="") {
		fileChosenP.textContent ="The lock is now released. Deletion successful!"
	} else {
	
			fileChosenP.textContent = "DELETE FAILED! " + blockedName[15] +" is now BLOCKED by browser. Waiting for time-out!";
			}////end if else (blockedName[15]==="")
			}//end if blocked15

			
			
			
		//blocked = false;//moved to if (dbDeleted) Dec15 2022 to avoid glitch in program flow if delete is attempted again!
		
//alertblk("At getfilenames after fileChosenP shows its thing!  deleteCount = " +deleteCount + " blockedName[0] = " + blockedName[0]  + " blockedName[1] = " + blockedName[1] + " blockedName[2] = " + blockedName[2] + " dbDeleted[0] = " + dbDeleted[0] + " dbDeleted[1] = " + dbDeleted[1] + " dbDeleted[2] = " + dbDeleted[2] + " blocked[0] = " + blocked[0] + " blocked[1] = " + blocked[1] + " blocked[2] = " + blocked[2] + " dbDeletedName[0] = " + dbDeletedName[0] + " dbDeletedName[1] = " + dbDeletedName[1] + " dbDeletedName[2] = " + dbDeletedName[2]);	


	
	if (dbRestored && loadSampleBudget){
	
	//scroll to bottom for instruction if (loadSampleBudget)
// //code below added Dec18 2022 to scroll to bottom of element with id = 'id of element'
		
// 	const scrollToBottom = (id) => {
// 	 const element = document.getElementById(id);
//    element.scrollTop = element.scrollHeight;
// }	
// scrollToBottom('fileNamesWindow');//this is a function expression..element id is passed as a parameter to the scrollToBottom function expression.
	
	
	
		console.log('restoredDBName = ' + restoredDBName);
		fileChosenP.textContent = defaultDBName + ' successfully loaded! Tap the filename and then TABLE, then CHANGE MONTH. Follow flashing button prompts!';
		//fileChosenP.textContent = dataBaseName + ' successfully RESTORED!';
		dbRestored = false;
		//restoredDBName = "";
		defaultDBName = "";
	}//end if dbRestored && loadSampleBudget)
	else if (dbRestored && !dataBaseName.includes("blocked")) {
	fileChosenP.textContent = defaultDBName + ' successfully RESTORED!';
		//fileChosenP.textContent = dataBaseName + ' successfully RESTORED!';
		dbRestored = false;
		//restoredDBName = "";
		defaultDBName = "";
	} //end if (dbRestored && loadSampleBudget)
//SHOULD SCROLL TO BOTTOM GO HERE if (dbRestored or need new variable mustTapRestore	WOW THIS WORKED!!!this code not reached? Why .. moved it closer to top of this function
// alert("In getFileNames: mustTapRestore = " + mustTapRestore);
// if(mustTapRestore) {
// //code below added Sept26 to scroll to bottom of element with id = 'id of element'
// alert("In mustTapRestore..about to scroll to bottom! fileNamesWindow.scrollHeight = " + fileNamesWindow.scrollHeight);		
// 	//const scrollToBottomFiles = (id) => {
// 	// const element = document.getElementById(id);
//    fileNamesWindow.scrollTop = fileNamesWindow.scrollHeight;
// //}	
// //scrollToBottomFiles('fileNamesWindow');//this is a function expression..element id is passed as a parameter to the scrollToBottom function expression.
// mustTapRestore = false;	
// }//end if(mustTapRestore)
// }//end if if else else
	
});//end promise.then databases



//newDataBaseButton is generated by HTML code
newDBButton.onclick = function() {
//dataBaseName = ""; //added Feb20 to aid in cancelling createNewDB ..did not work still deletes last created db
//set up newTable variables preceding a virgin db creation to prevent run error
/*
let skip = false;
if(skip) {
console.log("At create new db and dbListExists is false so about to i itiate new table variables ");
	//tableIndex = 0;
//newTableVariablesArray[0] = tableIndex;

newTableVariablesArray = [-1,,false];

//newTableNames = 
//newTableVariablesArray[1] = newTableNames;
//tableListExists = false;
//newTableVariablesArray[2] = tableListExists;

dataVobj.newTableVariables = newTableVariablesArray;

savedTablesArray = [,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,];

savedTablesArray[0] = [,,,];
dataVobj.savedTables = savedTablesArray;

//tableIndex = 0;
//newTableSpecificVariables[0] [0] = tableIndex;

//newTableFieldsArray = 
//newTableSpecificVariables[0][1] = newTableFieldsArray;
//numberOfNewTableAddedFields = 0;
//newTableSpecificVariables[0][2] = numberOfNewTableAddedFields;

newTableSpecificVariables = [-1,,0],[-1,,0],[-1,,0],[-1,,0],[-1,,0],[-1,,0],[-1,,0],[-1,,0],[-1,,0],[-1,,0];

dataVobj.tableSpecific = newTableSpecificVariables;
}//end if!dbListExits
*/

	console.log(' Tapped newDBButton. Going to createNewDB function.');
	for (let i = 0; i< numberOfDatabases; i++) { 
		//does this even run ? numberOfDatabases is never incremented????	
			dataBaseList.removeChild(databaseNameLi[i]);
			}//end for loop
			fileNamesWindow.setAttribute('class','hidden');
	//go to createNewDB function
	createNewDB();
}//end function newDBButton.onclick

flashBtn.onclick = function () {
	//toggle flashing tagged filename
	
	if(!flashing) {
	flashBtn.textContent = "Turn flashing OFF";
	timeDateFlagP.textContent = "Tagged files now flashing.";
	flashBtn.style.backgroundColor = "yellow";
		flashing = true;
		//window.location.reload();
		fileNamesWindow.setAttribute('class','hidden');
		getFileNames();
	} else {
		flashBtn.textContent =
		"Flash tagged filenames";
		timeDateFlagP.textContent = "Flashing filenames now OFF.";
		flashBtn.style.backgroundColor = "lightgreen";
		flashing = false;
		//window.location.reload();
		fileNamesWindow.setAttribute('class','hidden');
		getFileNames();
		}//end if (!flashing) 
		
	}//end flashBtn.onclick = function ()
//toggle flashing filenames

//cancel fileNamesScreen
cancelFileNamesWindowBtn.onclick = function(databases) {	
	dataBaseName = "";

for (let i = 0; i< databases.length; i++) { 
databaseNameLi[i].textContent = "";	dataBaseList.removeChild(databaseNameLi[i]);
	}//end for i databases.length. ? This does not clear list..need while firstChild below
	
	//databases.length =0;//trying to remove db list
fileNamesWindow.setAttribute('class','hidden');	
while (dataBaseList.firstChild) {
   dataBaseList.removeChild(dataBaseList.firstChild);
}//end while
}//end cancelFileNamesWindowBtn.onclick

//firstManageBtn
firstManageBtn.onclick = function() {
	manageDbListExists = true;//flag to prevent manageDbList from repeating. NOT SURE IF THIS SHOULD BE HERE? Remove if messed up May9
	firstManageBtn.setAttribute('class','tdEdit');//if blinking from a change month operation in new budget sheet restore to normal Date:Dec9 2022
	manageBtn.setAttribute('class','tdEdit')//reset if blinking from changeMonth in new budget sheet
	manageDataBases();
	fileNamesWindow.setAttribute('class','hidden');	
	};//end firstManageBtn.onclick
	
restoreDataBaseBtn.onclick = function() {
if(restoreDataBaseBtn.textContent === "RESTORE " + renamedFileName) {mustTapRestore = false;}//added April 1 2023 to facilitate proper scrolling to restore btn so you don't scroll down after restoring the blocked db.
restoreDataBaseBtn.textContent = "RESTORE from Backup";
restoreDataBaseBtn.setAttribute('class','tdEdit');
	restoreDataBase();
	fileNamesWindow.setAttribute('class','hidden');	
	//mustTapRestore = false;//flag to force scroll to bottom of fileNamesWindow REMOVE THIS ONE ???
};//end restore database …firstManageBtn.onclick

//start loadSampleDbBtn.onclick
loadSampleDbBtn.onclick = function () {
console.log('loadSampleDbBtn Button clicked. FileNamesWin hidden.');
//alertx("loadSampleDbBtn..savedTablesArray[0] = " + savedTablesArray[0]);
	fileNamesWindow.setAttribute('class','hidden');	
	//set loadSampleDb flag to true
	loadSampleDb = true;
	copySampleDbWin.setAttribute('class',
	'showing');
	
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	copySampleDbWin.style.backgroundColor = "black";
	copySampleDbWin.style.color = "white";
} else {
	copySampleDbWin.style.backgroundColor = "#eee";
	copySampleDbWin.style.color = "black";
}//end if else screenDark
	continueBtn.setAttribute('class','attentionBtn');
	
	//copySampleDbData.value should now be sample database
	
	
	
	continueBtn.onclick = function () {
		continueBtn.setAttribute('class','normalBtn');
		copySampleDbWin.setAttribute('class',
		'hidden');
		//loadSampleDb = true; //should be here ? Aug 21
		restoreDataBase();
	}//end continueBtn.onclick
	
	
}//end loadSampleDbBtn.onclick restoreDataBase(dataBaseName);

//start tutorial SampleDbBtn.onclick
loadTutorialDbBtn.onclick = function () {
console.log('loadTutorialDbBtn Button clicked. FileNamesWin hidden.');
	fileNamesWindow.setAttribute('class','hidden');	
	//set loadSampleDb flag to true
	loadTutorialDb = true;
	tutorialSampleDbWin.setAttribute('class',
	'showing');
	
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	tutorialSampleDbWin.style.backgroundColor = "black";
	tutorialSampleDbWin.style.color = "white";
} else {
	tutorialSampleDbWin.style.backgroundColor = "#eee";
	tutorialSampleDbWin.style.color = "black";
}//end if else screenDark
	
	tutorialContinueBtn.setAttribute('class','attentionBtn');
	
	//copySampleDbData.value should now be sample database
	
	
	
	tutorialContinueBtn.onclick = function () {
		tutorialContinueBtn.setAttribute('class','normalBtn');
		tutorialSampleDbWin.setAttribute('class',
		'hidden');
		//loadTutorialDb = true; //should be here ? Aug 21
		restoreDataBase();
	}//end continueBtn.onclick
	
	
}//end loadTutorialDbBtn.onclick
	
//start tutorial SampleDbBtn.onclick
loadSampleBudgetBtn.onclick = function () {
if(TEMPLATEblocked) {alert("Wait for browser to release its LOCK on the previous TEMPLATE before trying to create another budget sheet.");
selectedDBinfoP.textContent =  "The browser has temporarily blocked the previous TEMPLATE. Wait for the browser to release its LOCK before trying to create another budget sheet.";
	fileChosenP.textContent =  'The browser has temporarily blocked the previous TEMPLATE. Try again after the browser releases its LOCK!';
	return;
	}//end if(TEMPLATEblocked) 
	
console.log('loadSampleBudgetBtn Button clicked. FileNamesWin hidden.');
// tableScreenBtn.setAttribute('class','borderBlink');//prompting to go to table and tap changeMonth btn
changeMonthBtn1.setAttribute('class','borderBlink');
changeMonthBtn2.setAttribute('class','borderBlink');
fileNamesWindow.setAttribute('class','hidden');	
	//set sampleBudget flag to true
	loadSampleBudget = true;
	TEMPLATEblocked = false;//flag used in TEMPLATE BLOCKED code see getFileNames()
	sampleBudgetWin.setAttribute('class',
	'showing');
	
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	sampleBudgetWin.style.backgroundColor = "black";
	sampleBudgetWin.style.color = "white";
} else {
	sampleBudgetWin.style.backgroundColor = "#eee";
	sampleBudgetWin.style.color = "black";
}//end if else screenDark
	
	sampleBudgetContinueBtn.setAttribute('class','attentionBtn');
	
	//copySampleDbData.value should now be sample database
	
	
	
	sampleBudgetContinueBtn.onclick = function () {
	// tableScreenBtn.setAttribute('class','borderBlink');//prompting to go to table and tap changeMonth btn
	
		sampleBudgetContinueBtn.setAttribute('class','normalBtn');
		sampleBudgetWin.setAttribute('class',
		'hidden');
		//loadTutorialDb = true; //should be here ? Aug 21
		restoreDataBase();
	}//end continueBtn.onclick
	
	
}//end loadSampleBudgetBtn.onclick

// if(creationDONE && !ranOnce) {
// //code to remove .creatingDB which maybe should be changed to -creatingDB in case js thinks its a method!	
// //code to rename db with tag removed
// //dataBaseName = databases[i].name;
// dataBaseName = dbTableName.value;//helps insure dataBaseName is not wiped out in creation new db process
// alert("dataBaseName = " + dataBaseName);
// //renameDataBaseFileName(dataBaseName);
// dbFileName.textContent = dataBaseName.substring(0, dataBaseName.length-11);//trim off .creatingDB
// renamedFileName = dbFileName.textContent; 
// reNamedDBFileName = true;
// dbTitle.textContent = renamedFileName;
// dbTableName.value = renamedFileName//dbTableName is stored in variable1 and represents the variable in view settings that reflects the table name 
// saveVariables();
// backupDataBase(dataBaseName);//go to backup with original name!! And new filename is now in variable 	 renamedFileName = dbFileName.textContent


// //NOW NEED TO RETURN TO FILE NAMES WITH RESTORE BTN BLINKING
// //code to rename db with tag removed

// //creationDONE = false;
// let ranOnce = true;//to prevent rerun
// }//end if(creationDONE)	

}//end function getFileNames

function createNewDB () {
	console.log('In the createNewDB function. Resetting some variables if the start creating new db btn is pressed..')
	//come here from newDB button in menu or from fileNames screen
	//should xtraField = 0 for a reset if creating more than one new db?
	newDBflag = true;
	newDBGuidance = true;//newDBflag is made false after addNote and displayNote so to continue instructions for createNewDB after addNote this flag is set (won't disturb when newDBflag is made false)
	//clear the fileNamesList in preparation for a return to getFileNames
	//const newDBGuideP = document.createElement('p'); //made a global variable reference
//if (!fromResore) {
	while (dataBaseList.firstChild) {
   dataBaseList.removeChild(dataBaseList.firstChild);
}//end while
//}//end if !fromRestore
getFileNamesSwitch = false;//so getFileNames does not run again after creating new DB
createNewDBWindow.setAttribute('class','showing');

//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	createNewDBWindow.style.backgroundColor = "black";
	createNewDBWindow.style.color = "white";
	newDBGuideP.style.color = "black";//only needs this once already black in light mode!
} else {
	createNewDBWindow.style.backgroundColor = "#eee";
	createNewDBWindow.style.color = "black";
}//end if else screenDark

console.log("In start createNewDB: newDBGuidance = " + newDBGuidance + "newDBflag = " + newDBflag + " xtraField = " + xtraField);
//for guidance creating newDB
newDBGuideP.textContent = "Type the name of your database into the text entry element and then tap 'Start Creating new DataBase'. Follow the flashing button prompts!";
createNewDBWindow.appendChild(newDBGuideP);
newDBTitleInput.onfocus = function () {
	submitNameButton.setAttribute('class','borderBlink');
}
//end for guidance creating newDB
	submitNameButton.onclick = function() {
	submitNameButton.setAttribute('class','attentionBtn');
		dataBaseName = newDBTitleInput.value + ".creatingDB";
		//firstLOAD = true;//not used did not work
		// createNewDBWindow.setAttribute('class','hidden');
		
		//for guidance creating newDB
newDBGuideP.textContent = "";
createNewDBWindow.removeChild(newDBGuideP);
//end for guidance creating newDB

		resetVariables();
		console.log('Sending new db name  ' + dataBaseName + ' to the loadTheDataBase function. ResetVariables function has run!');
		console.log("In createNewDb after resetVariables, and going to loadTheDataBase: xtraField = " + xtraField);
		//In createNewDb after resetVariables, and going to loadTheDataBase: xtraField = 0
		loadTheDataBase(dataBaseName);
	//Aug26 ? Should getFileNames be here..don't think so	
	settingsBtn.click();//click function 1	
	//renameBtn.click();	
		}//end submitNameButton.onclick
	//cancel
	cancelNewDBButton.onclick = function() {
//prevent newDBGuidance appearing on preferences if create newDB was cancelled Sept13 2021
		newDBflag = false;
		newDBGuidance = false;
		newDBTitleInput.value = "";
		//for guidance creating newDB
newDBGuideP.textContent = "";
createNewDBWindow.removeChild(newDBGuideP);
//end for guidance creating newDB
	console.log('CANCEL newDBButton clicked. Returning to getFileNames.');	createNewDBWindow.setAttribute('class','hidden');
	//REMOVE BELOW IF MESSES UP!!!!Mar27
	//ReferenceError: Can't find variable: databases
	//databases.length = 0;
	//deleteDataBase(dataBaseName);//added Feb20..removed because repeating a cancel of the next new db to be created results in the last created db being deleted
	
	
	while (dataBaseList.firstChild) {
   dataBaseList.removeChild(dataBaseList.firstChild);
}//end while
		getFileNames();
		
	}//end cancelNewDBButton.onclick
	
}//end function createNewDB
//code for managing file names of databases
//function manageDataBases
function manageDataBases () {//added dataBaseName Feb25 did not work
showTable.setAttribute('class','hidden');//to cover scenario where manage btn in main menu tapped and the table window hides the manage window date; Feb25 2023
reNamedDBFileName = false;
//const restoreFileBtnLabel = document.querySelector('#restoreFileBtnLabel');
//const fileToRestore = document.querySelector('#fileToRestore');
	
console.log('In manageDataBases function.');	manageFilesWindow.setAttribute('class','showing');
//fileToRestore.style.overflow = "scroll";

//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	manageFilesWindow.style.backgroundColor = "black";
	manageFilesWindow.style.color = "white";
	} else {
	manageFilesWindow.style.backgroundColor = "#eee";
	manageFilesWindow.style.color = "black";
}//end if else screenDark

if(manageDbListExists) {
	while (manageDataBaseList.firstChild) {
	manageDataBaseList.removeChild(manageDataBaseList.firstChild);
}//end while
};//end if manageDbListExists


 promise = indexedDB.databases()
//A promise that resolves either to an error or a list of dictionaries, each with two elements, name and version.
promise.then(databases => {
 // console.log(databases);my code below
  for (let i = 0; i< databases.length; i++) {
	  
	  let dbNumber = i + 1;
	  console.log('databases = ' + databases)
	  console.log('databases.length = '+ databases.length);
	  console.log('Database # ['+ dbNumber +'] is ' + databases[i].name);
databaseNameMLi[i] = document.createElement('li');

if(databases[i].name === "Monthly Expenses - TEMPLATE.bs") {
databaseNameMLi[i].style.backgroundColor = "lightgreen";	databaseNameMLi[i].setAttribute('class','borderBlink');
}//end if(databases[i].name === "Monthly Expenses - TEMPLATE.bs")

if(!newDBflag && newDBGuidance === undefined && databases[i].name.includes(".creatingDB")){
databaseNameMLi[i].style.backgroundColor = "lightgrey";	databaseNameMLi[i].setAttribute('class','borderBlink');

//databaseNameLi[i].textContent =  ". DELETE this" at this stage there is no textContent?? Does not work a yway?? Why?
 }//end if(!newDBflag && newDBGuidance === undefined && databases[i].name.includes(".creatingDB"))



if(databases[i].name === blockedName[0]||databases[i].name === blockedName[1]||databases[i].name === blockedName[2]||databases[i].name === blockedName[3]||
databases[i].name === blockedName[4] ||
databases[i].name === blockedName[5] ||
databases[i].name === blockedName[6] ||
databases[i].name === blockedName[7] ||
databases[i].name === blockedName[8] ||
databases[i].name === blockedName[9] ||
databases[i].name === blockedName[10] ||
databases[i].name === blockedName[11] ||
databases[i].name === blockedName[12] ||
databases[i].name === blockedName[13] ||
databases[i].name === blockedName[14] ||
databases[i].name === blockedName[15]) {

	 databaseNameMLi[i].textContent = databases[i].name + " BLOCKED BY BROWSER! ";
	 databaseNameMLi[i].style.backgroundColor = "lightgrey";
	 databaseNameMLi[i].setAttribute('class','blocked');
	 
	 } else {
	 databaseNameMLi[i].textContent = databases[i].name;
	 }//end if(databases[i].name === blockedName)

	//databaseNameMLi[i].textContent = databases[i].name;
	//try click instead of dblclick
	//changed dblclick to just click in addEventListener to avoid magnification Date: Oct5 2021	
	databaseNameMLi[i].addEventListener('click', function () {
		//put name of database in global variable dataBaseName
		dataBaseName = databases[i].name;
		
if(dataBaseName.slice(-2) === "bs") {
//alert(dataBaseName + " is a Budget sheet!");

budgetSheet = true;
} else {
	budgetSheet = false;
}//end if else dataBaseName.slice(-2) === "bs"
		
		//SHOULD THERE BE CODE HERE TO REMOVE THE SELECTED DB????not tested May10
		//manageDataBaseList.removeChild(databaseNameMLi[i]);
		
		//SHOULD THERE BE CODE HERE TO REMOVE THE SELECTED DB????May10 NOT YET TESTED!!!?,?,!!!!!!
		 
		// fileChosenP.textContent = ' Database Selected: '+ databases[i].name;
		 console.log('dataBaseName = ' + dataBaseName);
		 
//To catch situation where wrong db is clicked on		
if(loadSampleBudget && dataBaseName !== "Monthly Expenses - TEMPLATE.bs") {
	alert("You have not tapped on Monthly Expenses - TEMPLATE.bs. Try again or CANCEL.");
	//manageDataBases();
	return;
}//end if(loadSampleBudget && dataBaseName !== "Monthly Expenses - TEMPLATE.bs")
		 
	 //confirm choice window
		 if (window.confirm("DataBase SELECTED is: " + " \n" + dataBaseName +  " \n" + "  CANCEL will UNDO")) {
			// for (let i = 0; i< databases.length; i++) { 
			// 	manageDataBaseList.removeChild(databaseNameLi[i]);
			// }//end for loop
			 //manageFilesWindow.setAttribute('class','hidden');
			 console.log('At manage DB Files window.');
			// deleteDataBase(dataBaseName);
		selectedDBinfoP.textContent = "Selected Database Name is : ";
		if(loadSampleBudget && budgetSheet) {dbNameInfo.style.color = "black";
		} else if (!loadSampleBudget) {
			dbNameInfo.style.color = "black";
		}//end if(loadSampleBudget) 
		dbNameInfo.textContent = dataBaseName;
		
// //THIS CODE ADDED Mar 1 2023 - remove if does not work!
// if(dataBaseName.slice(-2) === "bs") {
// //code below added Sept26 to scroll to bottom of element with id = 'id of element'
// //why doesn't this scroll??? Should it be a section???		
// 	const scrollDownToBottom = (id) => {
// 	 const elementToScroll = document.getElementById(id);
//    elementToScroll.scrollTop = elementToScroll.scrollHeight;
// }	
// scrollDownToBottom('manageFilesWin');//this is a function expression..element id is passed as a parameter to the scrollToBottom function expression.
// }//end if(dataBaseName.slice(-2) === "bs")
// //THIS CODE ABOVE  ADDED Mar 1 2023 - remove if does not work!

		
// if (blocked[0] && blockedName[0] === dataBaseName || blocked[1] && blockedName[1] === dataBaseName || blocked[2] && blockedName[2] === dataBaseName || blocked[3] && blockedName[3] === dataBaseName) {

if(databases[i].name === blockedName[0]||databases[i].name === blockedName[1]||databases[i].name === blockedName[2]||databases[i].name === blockedName[3]||
databases[i].name === blockedName[4] ||
databases[i].name === blockedName[5] ||
databases[i].name === blockedName[6] ||
databases[i].name === blockedName[7] ||
databases[i].name === blockedName[8] ||
databases[i].name === blockedName[9] ||
databases[i].name === blockedName[10] ||
databases[i].name === blockedName[11] ||
databases[i].name === blockedName[12] ||
databases[i].name === blockedName[13] ||
databases[i].name === blockedName[14] ||
databases[i].name === blockedName[15]) {



	alert(dataBaseName + ": The file is still blocked by the browser. Waiting for browser's Lock to time-out!");
	return;
	//getFileNames();
}//end if (blocked && blockedName === dataBaseName) 

	//alertcm("dbNameInfo.textContent = " + dbNameInfo.textContent);
		selectedDBinfoP.appendChild(dbNameInfo);
	
		// fileChosenP.textContent = ' Database Selected: '+ databases[i].name;
		
		console.log('dataBaseName = ' + dataBaseName);
		
//code below added Sept26 to scroll to bottom of element with id = 'id of element'
		
	const scrollToBottom = (id) => {
	 const element = document.getElementById(id);
   element.scrollTop = element.scrollHeight;
}	
scrollToBottom('manageFilesWin');//this is a function expression..element id is passed as a parameter to the scrollToBottom function expression.


	
			} else {
				//return to fileNames screen. Need to remove the previous fileNames?
			for (let i = 0; i< databases.length; i++) { 
				manageDataBaseList.removeChild(databaseNameMLi[i]);
			}//end for loop
			console.log('Cancelled. Going back to getFileNames.');
			manageFilesWindow.setAttribute('class','hidden');
				//REMOVE BELOW IF MESSES UP!!!!Mar27
				databases.length = 0;
			getFileNames();
				}//end if window.confirm else ...
	
				//confirm choice window
		 
	});//end addEventListener
	 manageDataBaseList.appendChild(databaseNameMLi[i]);
	 console.log('Database SELECTED is ' + dataBaseName);
 		
	}//end for i = 0;i < databases.length
 });//end promise.then databases
	
cancelDeleteDataBaseButton.onclick = function() {
console.log('Cancel Manage DataBase Files Button clicked. ManageFilesWindow hidden.');

manageFilesWindow.setAttribute('class','hidden');
//MAYBE SHOULD NOT CLEAR THESE VARIABLES HERE?Dec17 2022
// blocked = false;
//   blockedName = "";

//clear fileNames list

// for (let i = 0; i< databases.length; i++) { 
// 				manageDataBaseList.removeChild(databaseNameLi[i]);
// 			}//end for loop
			
while (manageDataBaseList.firstChild) {
	manageDataBaseList.removeChild(manageDataBaseList.firstChild);
}//end while
	
}//end cancelDeleteDataBaseButton.onclick

deleteFileButton.onclick = function() {
	console.log('deleteFileButton clicked!');
	//if this file is still blocked tell user!
	//alert("blocked = " +blocked+ ". blockedName = " +blockedName+ ". dataBaseName = " + dataBaseName + " ");
	
	//if (blocked && blockedName === dataBaseName) {
	// if (blocked && blockedName === dataBaseName || blocked2 && blocked2Name === dataBaseName || blocked3 && blocked3Name === dataBaseName || blocked4 && blocked4Name === dataBaseName) {
//ReferenceError: Can't find variable: databases	
	if(blocked[0] &&  blockedName[0] === dataBaseName ||blocked[1] &&  blockedName[1] === dataBaseName||blocked[2] &&  blockedName[2] === dataBaseName||blocked[3] &&  blockedName[3] === dataBaseName||blocked[4] &&  blockedName[4] === dataBaseName ||blocked[5] &&  blockedName[5] === dataBaseName ||blocked[6] &&  blockedName[6] === dataBaseName ||blocked[7] &&  blockedName[7] === dataBaseName ||blocked[8] &&  blockedName[8] === dataBaseName ||blocked[9] &&  blockedName[9] === dataBaseName ||blocked[10] &&  blockedName[10] === dataBaseName ||blocked[11] &&  blockedName[11] === dataBaseName ||blocked[12] &&  blockedName[12] === dataBaseName ||blocked[13] &&  blockedName[13] === dataBaseName ||blocked[14] &&  blockedName[14] === dataBaseName ||blocked[15] &&  blockedName[15] === dataBaseName) {

	alert(dataBaseName + ": The file is still blocked by the browser. Waiting for browser's Lock to time-out!");//added Dec17 2023
	return;
	//getFileNames();
}//end if (blocked && blockedName === dataBaseName) 
	 //confirm choice window
		 if (window.confirm("DataBase to DELETE is: " + " \n" + dataBaseName +  " \n" + "  CANCEL will UNDO")) {
			// for (let i = 0; i< databases.length; i++) { 
			// 	backupDataBaseList.removeChild(dataBaseBKUPNameLi[i]);
			// }//end for loop
			
			selectedDBNameP.textContent = "DELETING database ...";
			
			dbNameInfo.textContent = dataBaseName;
			selectedDBNameP.appendChild(dbNameInfo);
			
			// backupBtn.onclick = backupDataBase(dataBaseName);
			
			// restoreFileBtn.onclick = restoreDataBase(dataBaseName);
			 //manageFilesWindow.setAttribute('class','hidden');
			 console.log('Going to delete DataBase function.');
	 while (manageDataBaseList.firstChild) {
	manageDataBaseList.removeChild(manageDataBaseList.firstChild);
	}//end while
	manageFilesWindow.setAttribute('class','hidden');
	
	deleteDataBase(dataBaseName);
		
	// if(dbDeleted1 = false) {dbDeleted1 = true;dbDeletedName1 = dataBaseName;}
	// else if(dbDeleted1) {dbDeleted2 = true;dbDeletedName2 = dataBaseName;
	// } else if (dbDeleted2) {dbDeleted3 = true;dbDeletedName3 = dataBaseName;
	// } else if (dbDeleted3) {dbDeleted4 = true;dbDeletedName4 = dataBaseName;}
	//dbDeleted = true;//flag to make notice in Current Database File Names window
			//backupDataBase(dataBaseName);
		//	dbDeletedName = dataBaseName;//preserve for deleted notice in getFileNames May10
	// if(dbDeleted) {
	// 	selectedDBinfoP.textContent = dataBaseName + ' successfully DELETED!'}//end if dbDeleted	
	
			} else {
				//return to fileNames screen. Need to remove the previous fileNames?
			// for (let i = 0; i< databases.length; i++) { 
			// 	backupDataBaseList.removeChild(dataBaseBKUPNameLi[i]);
			// }//end for loop
			console.log('Cancelled. Going back to notes.');
		//this should be 'hidden'??
		while (manageDataBaseList.firstChild) {
	manageDataBaseList.removeChild(manageDataBaseList.firstChild);
		}//end while
		manageFilesWindow.setAttribute('class','hidden');
		//DON'T THINK THIS CODE IS REQUIRED IF YOU DON'T DELETE A DATABASE JUST KEEP STATUS QUO
		// if(blocked) {blocked = false}
		// if(blocked2) {blocked2 = false}
		// if(dbDeleted1) {dbDeleted1 = false}
		// if(dbDeleted2) {dbDeleted2 = false}
		// if(blocked3) {blocked3 = false}
		// if(blocked4) {blocked4 = false}
		// if(dbDeleted3) {dbDeleted3 = false}
		// if(dbDeleted4) {dbDeleted4 = false}
		
				//REMOVE BELOW IF MESSES UP!!!!Mar27
				//ReferenceError: Can't find variable: databases
				//databases.length = 0;
			//getFileNames();
		}//end if window.confirm else ...	
	
}//end deleteFileButton.onclick

//rename database filename
renameDbFileNameButton.onclick = function() {
	console.log('renameDbButton clicked!');
	
//SOLUTION TO PREVENT USE OF RENAME OR BKUP WHILE TEMPLATEblocked is overkill?..commented out Mar 9 2023 	
// if(TEMPLATEblocked) {alert("Wait for browser to release its LOCK on the previous TEMPLATE before trying to RENAME another database.");
// selectedDBinfoP.textContent =  "The browser has temporarily blocked the previous TEMPLATE. Wait for the browser to release its LOCK before trying to RENAME another database.";
// 	fileChosenP.textContent =  'The browser has temporarily blocked the previous TEMPLATE. Try again after the browser releases its LOCK!';
// 	return;
// 	}//end if(TEMPLATEblocked) 
	

renameDbFileNameButton.setAttribute('class','tdEdit');//if blinkingfrom change month operation restore to normal
if (dataBaseName === "") {
	alert("You need to select a database file first. Try again!");
	//manageFilesWindow.setAttribute('class','showing');
	manageDataBases();
	return;
}//end if database name === ""	

//alert("objectStoreName = " + objectStoreName + ". dataBaseName = " + dataBaseName);

if (objectStoreName !== dataBaseName + "_os" ) {
	alert("⚠️ You need to OPEN and view " + dataBaseName + " from the database file names list first, before you can RENAME the file in MANAGE. Returning to the database list.");
	//manageFilesWindow.setAttribute('class','showing');
	manageFilesWindow.setAttribute('class','hidden');
	getFileNames();
	return;
}//end if database name === ""	
	 //confirm choice window
		 if (window.confirm("DataBase to RENAME is: " + " \n" + dataBaseName +  " \n" + "  CANCEL will UNDO")) {
			// for (let i = 0; i< databases.length; i++) { 
			// 	backupDataBaseList.removeChild(dataBaseBKUPNameLi[i]);
			// }//end for loop
			
			selectedDBNameP.textContent = "RENAMING database ...";
			
			dbFileNameInfo.textContent = dataBaseName;
			selectedDBNameP.appendChild(dbFileNameInfo);
			
			// backupBtn.onclick = backupDataBase(dataBaseName);
			
			// restoreFileBtn.onclick = restoreDataBase(dataBaseName);
			 //manageFilesWindow.setAttribute('class','hidden');
			 console.log('Going to RENAME DataBase function.');
	 while (manageDataBaseList.firstChild) {
	manageDataBaseList.removeChild(manageDataBaseList.firstChild);
	}//end while
	manageFilesWindow.setAttribute('class','hidden');
	
	renameDataBaseFileName(dataBaseName);	
	dbFileNameRenamed = true;//flag to make notice in Current Database File Names window
			//backupDataBase(dataBaseName);
			//keep track of what old filename was
			dbFileNameRenamedName = dataBaseName;//preserve for deleted notice in getFileNames May10
	// if(dbDeleted) {
	// 	selectedDBinfoP.textContent = dataBaseName + ' successfully DELETED!'}//end if dbDeleted	
	
			} else {
				//return to fileNames screen. Need to remove the previous fileNames?
			// for (let i = 0; i< databases.length; i++) { 
			// 	backupDataBaseList.removeChild(dataBaseBKUPNameLi[i]);
			// }//end for loop
			console.log('Cancelled. Going back to notes.');
		//this should be 'hidden'??
		while (manageDataBaseList.firstChild) {
	manageDataBaseList.removeChild(manageDataBaseList.firstChild);
		}//end while
		manageFilesWindow.setAttribute('class','hidden');
				//REMOVE BELOW IF MESSES UP!!!!Mar27
				//ReferenceError: Can't find variable: databases
				//databases.length = 0;
			//getFileNames();
		}//end if window.confirm else ...	
	
}//end renameDbButton.onclick
//rename database filename

//backup code from manage windoe backup button
backupFileButton.onclick = function() {
	console.log('backupFileButton clicked!');
//SOLUTION TO PREVENT USE OF RENAME OR BKUP WHILE TEMPLATEblocked is overkill?..commented out Mar 9 2023 		
// if(TEMPLATEblocked) {alert("Wait for browser to release its LOCK on the previous TEMPLATE before trying to BACKUP another database.");
// selectedDBinfoP.textContent =  "The browser has temporarily blocked the previous TEMPLATE. Wait for the browser to release its LOCK before trying to BACKUP another database.";
// 	fileChosenP.textContent =  'The browser has temporarily blocked the previous TEMPLATE. Try again after the browser releases its LOCK!';
// 	return;
// 	}//end if(TEMPLATEblocked) 
	

//error code to make sure a file name is selected if backing up to prevent issue where a blank filename is created in the filenames list
if (dataBaseName === "") {
	alert("You need to select a database file first. Try again!");
	//manageFilesWindow.setAttribute('class','showing');
	manageDataBases();
	return;
}//end if database name === ""
//error code to make sure a file name is selected if backing up to prevent issue where a blank filename is created in the filenames list	
	
	
	
	 //confirm choice window
		 if (window.confirm("DataBase to BACKUP is: " + " \n" + dataBaseName +  " \n" + "  CANCEL will UNDO")) {
			// for (let i = 0; i< databases.length; i++) { 
			// 	backupDataBaseList.removeChild(dataBaseBKUPNameLi[i]);
			// }//end for loop
			
			selectedDBNameP.textContent = "BACKINGUP database ...";
			
		dbNameInfo.textContent = dataBaseName;
		selectedDBinfoP.appendChild(dbNameInfo);
			// backupBtn.onclick = backupDataBase(dataBaseName);
			
			// restoreFileBtn.onclick = restoreDataBase(dataBaseName);
			 //manageFilesWindow.setAttribute('class','hidden');
			 console.log('Going to backup DataBase function.');
	 while (manageDataBaseList.firstChild) {
	manageDataBaseList.removeChild(manageDataBaseList.firstChild);
	}//end while
	manageFilesWindow.setAttribute('class','hidden');
	
	backupDataBase(dataBaseName);

	backupFileButton.setAttribute('class','tdEdit');//added Feb25
	
			} else {
				//return to fileNames screen. Need to remove the previous fileNames?
			// for (let i = 0; i< databases.length; i++) { 
			// 	backupDataBaseList.removeChild(dataBaseBKUPNameLi[i]);
			// }//end for loop
			console.log('Cancelled. Going back to notes.');
			
			backupFileButton.setAttribute('class','tdEdit');//added Feb25
			
		//this should be 'hidden'??
		while (manageDataBaseList.firstChild) {
	manageDataBaseList.removeChild(manageDataBaseList.firstChild);
		}//end while
		manageFilesWindow.setAttribute('class','hidden');
				//REMOVE BELOW IF MESSES UP!!!!Mar27
				//ReferenceError: Can't find variable: databases
				//databases.length = 0;
			//getFileNames();
		}//end if window.confirm else ...	
	
	}//end backupFileButton.onclick

//clear database temporarily disabled until code written to support it see declaration above Sept17 2021
//clear database
clearFileButton.onclick = function() {
	console.log('clearFileButton clicked!');
	
	 //confirm choice window
		 if (window.confirm("DataBase to CLEAR is: " + " \n" + dataBaseName +  " \n" + "  CANCEL will UNDO")) {
			// for (let i = 0; i< databases.length; i++) { 
			// 	backupDataBaseList.removeChild(dataBaseBKUPNameLi[i]);
			// }//end for loop
			selectedDBNameP.textContent = "CLEARING database ..." + dataBaseName;
			
			// backupBtn.onclick = backupDataBase(dataBaseName);
			
			// restoreFileBtn.onclick = restoreDataBase(dataBaseName);
			 //manageFilesWindow.setAttribute('class','hidden');
			 console.log('Going to clear DataBase function.');
	 while (manageDataBaseList.firstChild) {
	manageDataBaseList.removeChild(manageDataBaseList.firstChild);
	}//end while
	manageFilesWindow.setAttribute('class','hidden');
	
	clearDataBase(dataBaseName,objectStoreName);	
			//backupDataBase(dataBaseName);
			
			} else {
				//return to fileNames screen. Need to remove the previous fileNames?
			// for (let i = 0; i< databases.length; i++) { 
			// 	backupDataBaseList.removeChild(dataBaseBKUPNameLi[i]);
			// }//end for loop
			console.log('Cancelled. Going back to notes.');
		//this should be 'hidden'??
		while (manageDataBaseList.firstChild) {
	manageDataBaseList.removeChild(manageDataBaseList.firstChild);
}//end while
		manageFilesWindow.setAttribute('class','hidden');
				//REMOVE BELOW IF MESSES UP!!!!Mar27
				//ReferenceError: Can't find variable: databases
				//databases.length = 0;
			//getFileNames();
		}//end if window.confirm else ...	
	
	}//end clearFileButton.onclick
//end clear database

backupRestoreFileBtn.onclick = function() {
	console.log('backupRestoreFileBtn clicked. ManageFilesWindow hidden.');
while (manageDataBaseList.firstChild) {
	manageDataBaseList.removeChild(manageDataBaseList.firstChild);
}//end while
manageFilesWindow.setAttribute('class','hidden');
	backupFilesWin.setAttribute('class','showing');
//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	backupFilesWin.style.backgroundColor = "black";
	backupFilesWin.style.color = "white";
	//restoreFileBtnLabel.style.color = "black";
	
} else {
	backupFilesWin.style.backgroundColor = "#eee";
	backupFilesWin.style.color = "black";
}//end if else screenDark	
	
//fileToRestore.textContent = "—>  " + dataBaseName;
// promise = indexedDB.databases()
// //A promise that resolves either to an error or a list of dictionaries, each with two elements, name and version.
// promise.then(databases => {
//  // console.log(databases);my code below
//   for (let i = 0; i< databases.length; i++) {
	  
// 	  let dbNumber = i + 1;
// 	  console.log('databases = ' + databases)
// 	  console.log('databases.length = '+ databases.length);
// 	  console.log('Database # ['+ dbNumber +'] is ' + databases[i].name);
// dataBaseBKUPNameLi[i] = document.createElement('li');
// 	 dataBaseBKUPNameLi[i].textContent = databases[i].name;
// 	 dataBaseBKUPNameLi[i].addEventListener('dblclick', function () {
// 		//put name of database in global variable dataBaseName
// 		dataBaseName = databases[i].name;
// 		selectedDBinfoP.textContent = "Selected Database Name is : " + dataBaseName;
// 		// fileChosenP.textContent = ' Database Selected: '+ databases[i].name;
		 console.log('dataBaseName = ' + dataBaseName);
	 //confirm choice window
		 if (window.confirm("DataBase SELECTED is: " + " \n" + dataBaseName +  " \n" + "  CANCEL will UNDO")) {
			// for (let i = 0; i< databases.length; i++) { 
			// 	backupDataBaseList.removeChild(dataBaseBKUPNameLi[i]);
			// }//end for loop
			selectedDBNameP.textContent = "Tap BACKUP to SAVE ...";
	dbNameInfo.textContent = dataBaseName;
	selectedDBNameP.appendChild(dbNameInfo);

			
			
			// backupBtn.onclick = backupDataBase(dataBaseName);
			
			// restoreFileBtn.onclick = restoreDataBase(dataBaseName);
			 //manageFilesWindow.setAttribute('class','hidden');
			 console.log('Choosing  backupDataBase or Restore function.');
			//backupDataBase(dataBaseName);
			
			} else {
				//return to fileNames screen. Need to remove the previous fileNames?
			// for (let i = 0; i< databases.length; i++) { 
			// 	backupDataBaseList.removeChild(dataBaseBKUPNameLi[i]);
			// }//end for loop
			console.log('Cancelled. Going back to Notes.');
		//this should be 'hidden'??
		backupFilesWin.setAttribute('class','hidden');
				//REMOVE BELOW IF MESSES UP!!!!Mar27
				//ReferenceError: Can't find variable: databases
				//databases.length = 0;
			//getFileNames();
				}//end if window.confirm else ...
	
				//confirm choice window
		 
//	});//end addEventListener
	// backupDataBaseList.appendChild(dataBaseBKUPNameLi[i]);
	//  console.log('Database to backup is ' + dataBaseName);
 		
	//}//end for i = 0;i < databases.length
//});//end promise.then databases
//}//end function backupRestoreFileBtn.onclick	
backupBtn.onclick = function () {
//SOLUTION TO PREVENT USE OF RENAME OR BKUP WHILE TEMPLATEblocked is overkill?..commented out Mar 9 2023 	
// if(TEMPLATEblocked) {alert("Wait for browser to release its LOCK on the previous TEMPLATE before trying to BACKUP another database.");
// selectedDBinfoP.textContent =  "The browser has temporarily blocked the previous TEMPLATE. Wait for the browser to release its LOCK before trying to BACKUP another database.";
// 	fileChosenP.textContent =  'The browser has temporarily blocked the previous TEMPLATE. Try again after the browser releases its LOCK!';
// 	return;
// 	}//end if(TEMPLATEblocked) 
	
	
	//error code to make sure a file name is selected if backing up to prevent issue where a blank filename is created in the filenames list
if (dataBaseName === "") {
	alert("You need to select a database file first! Select CANCEL and try again!");
	//manageFilesWindow.setAttribute('class','showing');
	manageDataBases();
	return;
}//end if database name === ""
// //error code to make sure a file name is selected if backing up to prevent issue where a blank filename is created in the filenames list	
console.log('Backup Button clicked. backupFilesWin hidden.');	backupFilesWin.setAttribute('class','hidden');
alert("Backup Button clicked - variable values: loadSampleDb = " + loadSampleDb + " dataAltered = " + dataAltered + " bkupAlertsFlag = " + bkupAlertsFlag + " dataNotBackedUp = " + dataNotBackedUp + " convertingOldFile = " + convertingOldFile);

	backupDataBase(dataBaseName);
	
}//end backupBtn.onclick //backupDataBase(dataBaseName);
			
restoreFileBtn.onclick = function () {
console.log('RestoreFile Button clicked. backupFilesWin hidden.');	backupFilesWin.setAttribute('class','hidden');
	mustTapRestore = false;//flag to force scroll to bottom of fileNamesWindow
	restoreDataBase(dataBaseName);
	
}//end restoreFileBtn.onclick restoreDataBase(dataBaseName);




cancelbackupDataBaseButton.onclick = function() {
console.log('Cancel BackupDataBaseButton clicked. backupFilesWin hidden.');


// for (let i = 0; i< databases.length; i++) { 
// 				backupDataBaseList.removeChild(databaseNameLi[i]);
// 			}//end for loop

// for (let i = 0; i< numberOfDatabases; i++) { 
// 				backupDataBaseList.removeChild(dataBaseBKUPNameLi[i]);
// 			}//end for loop
			
// while (backupDataBaseList.firstChild) {
// 	backupDataBaseList.removeChild(backupDataBaseList.firstChild);
// }//end while
backupFilesWin.setAttribute('class','hidden');

//clear fileNames list

// for (let i = 0; i< databases.length; i++) { 
// 				manageDataBaseList.removeChild(databaseNameLi[i]);
// 			}//end for loop


	
}//end cancelBackupDataBaseButton.onclick	
	
	
}//end function backupRestoreFileBtn.onclick
//});//end promise.then databases
}//end function manageDataBases

//function to resetVariables prior to creating a new db
function resetVariables () {
	//clear list of newTables if they exist. Do this before we lose all the variable settings. Done in resetVariables because also needed with createNewDB
//to keep tableList from repeating
//ReferenceError: Cannot access uninitialized variable.
if(tableListExists) {
		while (newTableList.firstChild) {
	newTableList.removeChild(newTableList.firstChild);
};//end while
tableChosenP.textContent = "";
}//end if(tableListExists)


	
setup = 0;
xtraField = 0;//Mar26 remove?
tableExists = 0;
tableArray = tableArray.splice(0, tableArray.length);
tableTitle = tableTitle.splice(0,tableTitle.length);
//COULD THIS BE WHAT IS MESSING UP MY SAVEDTABLESARRAY SETTINGS????
//savedTablesArray = savedTablesArray.splice(0, savedTablesArray.length);
fieldNamesArray = fieldNamesArray.splice(0,fieldNamesArray.length);
//dbTableName = "";
newFieldCounter = 0;
xtraField = 0;//might this just have to be let xtraField so all is controlled by having run addField section..otherwise starts from scratch if reloading db???
//let xtraFieldButton = false; fix did not work!
xtraFieldBtnExists = false;//flag to fix xtraFieldBtn bug Date: Mar 6 2021
newFieldName = "";
ver = 1; //changed version variable from 1 to 2 to trigger onupgradeneeded event in order to create the 'notesVariables_os' object store
variable2Array = [setup,noteListItemColour, noteTitleColour, bodyColour, xtraFieldColour, fontColour, tableExists];
//let nextFieldName;//title of subsequent fields as determined by input in a for loop
	numberOfFields = "";//the counter to use in the for loop
	numberOfDynamicFields = "";//number of new required fields
	moreFields = 0;//add more dynamic fields in edit table
// 	let tableTitle;
// let paraBody;
// let displayXtraFieldData;
// 	//ReferenceError: Cannot access uninitialized variable.
// let otherVariablesArray = [tableExists,showExtraField,nextFieldName,numberOfFields,numberOfDynamicFields,tableTitle,paraBody,displayXtraFieldData];
// let variable3 = "more variables here";
//TABLE SECTION VARIABLES
//recordCounter = 50;//to declare tableArray with a fixed number of records. Hoping to correct error in buildRecordRows re tableArray[][] undefined is not an object??
//LOOK UP HOW TO CLEAR AN ARRAY
tableTitle = [];
copyOfTableTitle = [];
copyOfTableArray = [];
searchedRecordTitle = [];
//let tableTitle = ['CN6035', 'CN3205', 'CN6700'];//tableTitle array needs to be created in dbNotes?
	//let XtableTitle;//remove when tables fixed!!!!
//let paraBody;
//let XparaBody;
//let displayXtraFieldData;
//let XdisplayXtraFieldData;
paraBody = [];

//let paraBody = ['Y2Trk2','Y3Trk2','Y3Trk8'];
displayXtraFieldData = [];
//let displayXtraFieldData = ['TSU-1100','Econami-PNP','TSU-1100'];
	//all above will be variables from IndexedDBNotes
	//create the 2D array tableArray
	 tableArray = new Array(recordCounter);

//for (var i = 0; i < recordCounter; i++) {
	
for (var i = 0; i < recordCounter; i++) {

tableArray[i] = new Array(numberOfFields);

}//number of fields means all fields

//COULD THIS BE WHAT IS MESSING UP MY SAVEDTABLESARRAY SETTINGS????
	//create the 2D array tableArray
/*	 savedTablesArray = new Array(10);

//for (var i = 0; i < recordCounter; i++) {
	
for (var i = 0; i < 10; i++) {

savedTablesArray[i] = new Array(4);

}//number of fields means all fields
*/
//create fieldNamesArray
fieldNamesArray = [];
	//ReferenceError: Cannot access uninitialized variable.
fieldOption = [];	
fieldDeleted = false;//flag to make displayTable show the field header with the field removed Feb 2 2021
buildingTableArrays = 0;//this variable enables displayData to construct the tableTitle and paraBody and displayXtraFieldData arrays ? May not need???
dateTable = [];//date array used in creating table. Note how this array is declared variable array name = []
//originalNumberRecords;//used to give option of refreshTable
originalNumberRecords = 0;//was blank? So unchanged DATE: JAN20 watch this if it crashes elsewhere??!!?,!!?,
//variables used in refreshTable	
originalNumberOfFields = numberOfFields;
	addedNumberOfRecords = tableTitle.length-originalNumberRecords;
currentNumberOfFields = fieldNamesArray.length;

addedNumberOfRecords = tableTitle.length-originalNumberRecords;
currentNumberOfFields = fieldNamesArray.length;
fromMakeTable = 0;//to prevent warning in displayData from popping up if displayTable btn tapped after a table has been creates..see displayTable
displayedTable = 0;//to prevent fieldNames repeating after repeat calls to displayTable via displayTableBtn
tableConstructed = 0;
DTBtnTappedOnce = 0;//flag to disable or enable edit and deleteField buttons also used in displayTable
editCurrentTable = 0;//so displayTable workS correctly when editing a table that pre-exists
deleteTableRecord = 0;
//?have to reset individual variables in otherVariablesArray!!
otherVariablesArray = [tableExists,originalNumberRecords,nextFieldName,numberOfFields,numberOfDynamicFields,tableTitle,paraBody,displayXtraFieldData];
if(setup===3) {
prefVariablesArray = [viewDateWritten,dateShade,showExtraField,showScroll,centerTitle,tableDateTime,linkLabel,scrollTable,bkgrdImage,trigger,caseSensitive,includesSubstring];
}//end if setup = 3
variable3 = showExtraField;
// let key;//can remove if myKey works
// let myKey = 1;
// let keyPath;
searchNote = 0;//searchRecord code
fromSearchRecord = false;
// let noteId;
// let RecordId;//used in displayTable editing TD cell
// let editedTDchange;//used in displayTable editing TD cell
fudgeFactor = 1;//to correct for adding record after a delete when doing search may not need MiGht eraseh
matchedRecordIndex = "";
 fromFullViewItem = false;//used for proper creation of table view after a fullItemView
fromDeleteField = false;//to add field headers back on if going to displayTable from deleteField
fromNew = false;//flag to not show make changes Btn if New table being created
//add tableArray here

//dataVobj will compare to variable2Array, and dataV: will compare to variable2:

//tableArray = [["CN7035", "Oct 20 2020 22:21","Y2Trk2","TSU-1100","5","128","255"],["CN3205", "Oct 20 2020 22:21","Y3Trk2","Econami PNP","15","128","255"],["CN6700","Oct 20 2020 22:21","Y3Trk8","TSU-1100","77","130","190"]];	
//have to reset individual members	
if(setup===3) {
let	dataVobj = {
  tableArray: tableArray,
  fieldNamesArray: fieldNamesArray,
  otherVariables: otherVariablesArray,
  prefVariables: prefVariablesArray,
  variable3: variable3,
  savedTables: savedTablesArray,
  newTableVariables: newTableVariablesArray,
  tableSpecific: newTableSpecificVariables};
  
 } else { 
let	dataVobj = {
  tableArray: tableArray,
  fieldNamesArray: fieldNamesArray,
  otherVariables: otherVariablesArray,
  prefVariables: prefVariablesArray,
  variable3: variable3,
  savedTables: savedTablesArray,
  newTableVariables: newTableVariablesArray,
  tableSpecific: newTableSpecificVariables
};//end declaration of dataV object
}//end if setup=3

//dataVobj = {
 // tableArray: tableArray,
 // fieldNamesArray: fieldNamesArray,
  //otherVariables: otherVariablesArray,
  //prefVariables: prefVariablesArray,
 // variable3: variable3
//};//end declaration of dataV object
//THESE VARIABLES ABOVE FOR TABLE SECTION	
//THESE VARIABLES ABOVE FOR TABLE SECT
newTableNames.length =0;
savedOriginal = false;
fromEditFieldLabels = false;
displayDataBtn.setAttribute('class', 'normalBtn');//because can still be blinking if you create a new db after having renamed another table name in a previous db date: Jan22 2023
//settingsBtn.setAttribute('class','tdEdit');//added Feb20 to cover scenario of cancelling a create new db after first record stage
}//end resetVariables function


//TO RESET DATABASE!!!!!!!!!!!?,?,!
//deleteDataBase();

//code to run to delete database..so can reset?


function deleteDataBase (dataBaseName) {
	console.log('At deleteDataBase function. dataBaseName = ' + dataBaseName);
	//avoid open if still blocked (for ongoing situation where an attempted delete has been made…not for a reboot scenario)
if (blocked[0] && blockedName[0] === dataBaseName || blocked[1] && blockedName[1] === dataBaseName ||blocked[2] && blockedName[2] === dataBaseName || blocked[3] && blockedName[3] === dataBaseName|| blocked[4] && blockedName[4] === dataBaseName || blocked[5] && blockedName[5] === dataBaseName || blocked[6] && blockedName[6] === dataBaseName || blocked[7] && blockedName[7] === dataBaseName || blocked[8] && blockedName[8] === dataBaseName || blocked[9] && blockedName[9] === dataBaseName || blocked[10] && blockedName[10] === dataBaseName || blocked[11] && blockedName[11] === dataBaseName) {
	alert(dataBaseName + ": The file is still blocked by the browser. Waiting for browser's Lock to time-out!");
	return;
	//getFileNames();
}//end if (blocked && blockedName === dataBaseName) 


//REMOVE BELOW IF MESSES UP DATE-APRIL5 2023
//You can try using the following code snippet to force Safari mobile to release lock on indexedDb file programatically in javascript:

// var db;
// var request = indexedDB.open(dataBaseName, 1);
// request.onupgradeneeded = function(event) {
//   db = event.target.result;
//   var objectStore = db.createObjectStore('myObjectStore', {keyPath: 'id'});
// };
// request.onsuccess = function(event) {
//   db = event.target.result;
//   var transaction = db.transaction([objectStoreName], 'readwrite');
//   var objectStore = transaction.objectStore(dataBaseName);
//   var request = objectStore.clear();
//   request.onerror = function(event) {
//     console.log('Error clearing object store:', event.target.errorCode);
//   };
//   request.onsuccess = function(event) {
//     console.log('Object store cleared');
//     alert("Object store cleared");
//   };
// };
//This code snippet will clear the object store of your database which will release any locks that are held on it1. I hope this helps!


//REMOVE ABOVE IF MESSES UP DATE-APRIL5 2023
	
	var req = indexedDB.open(dataBaseName,1);
	//InvalidStateError: Failed to read the 'result' property from 'IDBRequest': The request has not finished.
	//let db = e.target.result;
	//var db = req.result;//remove if messes up May11
    req.onblocked = function () {
        console.log('In req.onblocked of open(dataBaseName)…blocked');
		let db = e.target.result;
        // close the blocking connection:             
       //e.target.result.close();//SWITCH??
       var transaction = db.transaction([objectStoreName], 'readwrite');
  var objectStore = transaction.objectStore(dataBaseName);
  var request = objectStore.clear();
  request.onerror = function(event) {
    console.log('Error clearing object store:', event.target.errorCode);
  };
  request.onsuccess = function(event) {
    console.log('Object store cleared');
   // alert("Object store cleared");//this code never ran?
  };
		db.close();//SWITCH??
	// 	if(blocked) {blocked2 = true;}
	// 	if(!blocked) {blocked = true;}
	// 	//blocked = true;//added Dec 15 2022 to avoid error in flow if user attempts to delete db again but still blocked?
	// 	//SyntaxError: Left side of assignment is not a reference.
	// 	else if(blocked && blocked2) {blocked3 =true}
	// 	else if(blocked && !blocked2) {blocked2 = true;}
	// 	else if(blocked && blocked2 && blocked3) {blocked4 = true;}
     };//end req.onblocked = function of opening database
     
    req.onsuccess = function (e) {
		console.log('In onsuccess of open(dataBaseName. Will now db.close() via e.target.result.close.. and try to delete database');
        // close the formerly blocked connection:
       e.target.result.close();//SWITCH??
		//db.close();//SWITCH??
        var req = indexedDB.deleteDatabase(dataBaseName);
     //deleteCount variable set to 0 at start when declared as global variable  
        req.onsuccess = function () {
            console.log('In onsuccess of delete(dataBaseName)….database deleted. we ok. Now should go to getFileNames.');
 // let locked = isLocked(dataBaseName);
  // alert("locked = " + locked) ;        
  // let successCount = 0;   
 // alert("In delete db req.onsuccess - dbTableName.value = " + dbTableName.value);  //greenPeppers.blocked 
  //alert("Is " + dataBaseName + " locked? - " + isLocked(dataBaseName)); 
  //for deleting a database normally ..one that has not been blocked..don't keep track of successCount here  
  if(!(dbTableName.value.includes("blocked")) ) {
 // successCount = successCount + 1;//keep track of all deletions..no just keep track of blocked deletions
            alert("The database ' "+dataBaseName + " ' has now been successfully deleted!");//this line runs most often!
            fileChosenP.textContent = "The database ' "+dataBaseName + " ' has now been deleted!"; 
 //IF CODE BELOW DOES NOT WORK COMMENT OUT
  } //else if (dataBaseName !== dbTableName && !(isLocked(dataBaseName))) {
  
  else if (dataBaseName !== dbTableName.value && dbTableName.value.includes("blocked")) {
	alert("The locked database ' "+dataBaseName + " ' has now been successfully deleted!");
	return;
 //IF CODE ABOVE DOES NOT WORK COMMENT OUT
     } else {
     //alert("pendingDeleteNameSuccessCount["+successCount+"] = " + pendingDeleteName[successCount] + "  pendingDeleteNameBlockedCount["+blockedCount +"] = " + pendingDeleteName[blockedCount] + " deleteCount = " + deleteCount + " blockedCount = " + blockedCount);//ERROR USING blockedCount-1 (NaN = undefined!);
     
	    alert("The previously blocked database ' "+ pendingDeleteName[successCount] + " ' has now been deleted after the browser relinquished its lock!");//successCount is the correct variable to use here
	   fileChosenP.textContent = 'Blocked database file released…now deleted!!'; 
	   successCount = successCount + 1;//keep track of all blocked deletions
     } //end if else if if(!(dbTableName.includes("blocked")) )    
            
           //fileChosenP.textContent = 'Blocked database file released…now deleted!';
           //if(dataBaseName.includes("blocked)")) {TEMPLATEblocked = false;}//end if(dataBaseName.includes("blocked)"))
           if(dataBaseName.includes("Monthly Expenses - TEMPLATE.bs"||dataBaseName === pendingDeleteName)) {
           TEMPLATEblocked = false;
           }
           // alert("TEMPLATEblocked = " + TEMPLATEblocked);
            
 // bug! blockedName[0] = Monthly Expenses TEMPLATE.bs
 //dbTableName = Monthly Expenses - TEMPLATE.bs.blocked
 
 
 //move this out of the while loop	
 //SyntaxError: Left hand side of operator '=' must be a reference.
 
 //SHOULD THIS CODE BE : IF BLOCKED AND DATABASE NAME = BLOCKED NAME THEN CLEAR CORRESPONDING VARIABLES ..MAKE BLOCKED = FALSE BLOCKED NAME = "". AND DO THIS FOR ALL BLOCKED SCENARIOS KEEPING ALL BLOCKS SEPARATE,!
 
// let deleteCount = 0;
 dbDeleted[deleteCount] = true;
 dbDeletedName[deleteCount] = dataBaseName;
 deleteCount = deleteCount + 1;
 
 for(i=0;i<15;i++) {
// alert("dbDeletedName[" + i + "] = " + dbDeletedName[i] + " blockedName[" + i + "]) = " + blockedName[i]);
	 //if(dbDeletedName[i] === blockedName[i]) {
	
	if(dataBaseName === blockedName[i]) {
		blockedName[i] = "";
	 }//end if(dbDeletedName[i] === blockedName[i])


 }//end for loop this code is useful and works see getFileNames KEEP THIS CODE!
 
//  for(i=0;i<4;i++) {
// if(dataBaseName === blockedName[i]) {
// 	blocked[i] = false;
// 	blockedName[i] = "";
// dbDeleted[i] = true;
// dbDeletedName[i] = dataBaseName;

// 	}//end if(dataBaseName = blockedName[i])
// }//for i loop
 
 // if(blocked && blockedName === dataBaseName) {blocked = "false";blockedName = "";}	
 // if(blocked2 && blocked2Name === dataBaseName) {blocked2 = "false";blocked2Name = "";}	
 // if(blocked3 && blocked3Name === dataBaseName) {blocked3 = "false";blocked3Name = "";}	
 // if(blocked4&& blocked4Name === dataBaseName) {blocked4 = "false";blocked4Name = "";}	
 
 // if(!dbDeleted1) {dbDeleted1 = true;dbDeletedName1 = dataBaseName;}
	// else if(dbDeleted1) {dbDeleted2 = true;dbDeletedName2 = dataBaseName;
	// }else if(dbDeleted2) {dbDeleted3 = true;dbDeletedName3 = dataBaseName;
	// }else if(dbDeleted3) {dbDeleted4 = true;dbDeletedName4 = dataBaseName;}
 
 // blocked = false;
 // blockedName = "";
 //alertblk("AT ONSUCCESS OF DELETEDATABASE: deleteCount = " + deleteCount + " blockedName[0] = " + blockedName[0] +" blockedName[1] = " +blockedName[1] + " blockedName[2] = " +blockedName[2] + " blockedName[3] = " + blockedName[3] + " dbDeleted[0] = " + dbDeleted[0] + " dbDeleted[1] = " + dbDeleted[1] + " dbDeleted[2] = " + dbDeleted[2] + " dbDeleted[3] = " + dbDeleted[3] + " blocked[0] = " + blocked[0] + " blocked[1] = " + blocked[1] + " blocked[2] = " + blocked[2] + " blocked[3] = " + blocked[3] + " dbDeletedName[0] = " + dbDeletedName[0] + " dbDeletedName[1] = " + dbDeletedName[1] + " dbDeletedName[2] = " + dbDeletedName[2] + " dbDeletedName[3] = " +dbDeletedName[3]);
 //SHOULD I ADD THIS LINE TO INSURE FILENAMES LIST IS NOT REPEATED?
  dbListExists = true;//flag to prevent list repeating. A one time switch
 //SHOULD I ADD THIS LINE TO INSURE FILENAMES LIST IS NOT REPEATED?
  
while (dataBaseList.firstChild) {
	// //move this out of the while loop		
  // blocked = false;
  // blockedName = "";
   dataBaseList.removeChild(dataBaseList.firstChild);
		};//end while
		fileChosenP.textContent = 'Blocked database file released…now deleted!';//ADDED MAR15 remove if not work
		//mustTapRestore gets set to false somehow at this point? So added this statement April3 2023..seems to work!
		//alert("reNamedDBFileName = " + reNamedDBFileName);
		
		if(reNamedDBFileName) {mustTapRestore = true;}//end if(renamedDB) 
			getFileNames();//added May8 REMOVE IF MESSES UP 
        };//end onsuccess of deleting database
        
		//added e to function brakets May13
		
        req.onblocked = function (e) { //of deleting database
   blocked[blockedCount] = true;//keep needed in getFileNames
   blockedName[blockedCount] = dataBaseName;////keep needed in getFileNames
   
  // alert("At req.onblocked = function:  blockedCount = " + blockedCount + " dataBaseName = " + dataBaseName + " dbTableName.value = " + dbTableName.value);
   
   //dataBaseName = Green Peppers dbTableName = Green Peppers 🫑 (attempting to delete Green Peppers having renamed to Green Peppers 🫑 blockedName will be Green Peppers)
   //pendingDeleteName[blockedCount] = undefined so moved code below? SEE CODE BELOW! April 1 2023
   
   //  pendingDeleteName[blockedCount] = dataBaseName;//Mar9
   // // pendingDeleteName[deleteCount] = blockedName[blockedCount];//Mar9
   //  alert("pendingDeleteName[" +blockedCount+ "] = " + pendingDeleteName[blockedCount]);
   // //alert("blockedName[" + blockedCount + "] = " + blockedName[blockedCount]);
   
   // blockedCount = blockedCount + 1;
   
  
  //SHOULD YOU REALLY RAISE THE DELETE COUNT IF THE DELETION WAS BLOCKED.?? Feb17
 //alertblk("deleteCount = " + deleteCount + " blockedName[" +deleteCount + "] = " + blockedName[deleteCount]) ;      
  
  
  //reset dbTableName and save so that if user shuts down Dougiebase on return the blocked file is remembered
  //alertblk("At delete database.onblocked: dbTableName.value = " + dbTableName.value + ". dataBaseName = " + dataBaseName);
 // dbTableName.value = dbTableName.value +".blocked" ;
 if(!(dbTableName.value.includes("blocked"))) {
 dbTableName.value = dataBaseName +".blocked" ;
 }//end if(!(dbTableName.value.includes("blocked"))) so blocked is not added twice Date:Feb18 
 
 //alertflm("in deletedb : objectStoreName = " + objectStoreName + ". dbTableName.value = " + dbTableName.value);
 //dbTableName will now still contain .blocked but need to get it remembered for the next file load?
  saveVariables() ;  //NEED TO SAVE SO THAT .BLOCKED IS ADDED TO DBTABLENAME SO IT IS REMEMBERED IN A RELOAD OF DB FILES!this gives error ?undefined error? 
  //HAVE TO REMOVE CODE BELOW!?,?,!!  This line is new since ver44 Jan 23 2023 which works but won't remember
  //saveVariables will set dataBkup to false!dataNotBackedUp variable is set to true
      
       // for(i=0;i<4;i++) {
// if(!blocked[deleteCount]) {
// 	blocked[deleteCount] = true;
// 	blockedName[deleteCount] = dataBaseName;
// 	}
//}
        // if(blocked) {blocked2 = true;}
        // //if a delete occurs in the middle of a second block: make blocked = true when this occurred blockedName was Weird Creatures but blocked was false
        // if(dbDeleted1 && !blocked) { blocked = true}
		// if(!blocked) {blocked = true;}
		// //blocked = true;//added Dec 15 2022 to avoid error in flow if user attempts to delete db again but still blocked?
		// //SyntaxError: Left side of assignment is not a reference.
		// else if(blocked && blocked2) {blocked3 =true}
		// else if(blocked && !blocked2) {blocked2 = true;}
		// else if(blocked && blocked2 && blocked3) {blocked4 = true;}
  //  }; <—- this was the culprit!!
        
        // if(blocked) {blocked2 = true;}
		// 	//blocked = true;
		// if(blocked2) {blocked3 = true;}
		// if(blocked3) {blocked4 = true;}
            console.log('In onblocked of delete(dataBaseName)…still blocked');
            
        
 if(creationDONE) { 
 	alert("⚠️ Sorry. The data files '" + dataBaseName + "' used to create the new database are still blocked by the browser and therefore DougieBase is unable to delete them. Do not open or access the '" +dataBaseName +"' file until deletion is complete! DougieBase will automatically delete the file when the lock times out. InvalidStateError: Failed to read the result property from IDBRequest: The request has not finished.");
 } else {
			alert('⚠️ Sorry. Database ' + dataBaseName + '- is still blocked by browser and therefore DougieBase is unable to delete it. Do not open or use ' +dataBaseName + ' file until deletion is complete! Opening another database will/might force close ' + dataBaseName + ' and its DELETION process will complete. Wait for browser to time-out its lock on ' + dataBaseName + ' before trying to re-access.   InvalidStateError: Failed to read the result property from IDBRequest: The request has not finished.');
			}//end  if(creationDONE)
			
if(dataBaseName.includes("Monthly Expenses - TEMPLATE.bs")) {TEMPLATEblocked = true;}

//CODE BELOW TO REPLACE SAME CODE ABOVE put here because not sure it ran above??

//alert("In code below: blockedCount = " + blockedCount);

    pendingDeleteName[blockedCount] = dataBaseName;//Mar9
   // pendingDeleteName[deleteCount] = blockedName[blockedCount];//Mar9
   
  //  alert("pendingDeleteName[" +blockedCount+ "] = " + pendingDeleteName[blockedCount] + " dbTableName.value = " + dbTableName.value);
   //alert("blockedName[" + blockedCount + "] = " + blockedName[blockedCount]);
   
   blockedCount = blockedCount + 1;
   
   
   
   
			
			// if(blocked && blockedName === "") {blockedName = dataBaseName}
			// if(blocked2 && blocked2Name === "") {blocked2Name = dataBaseName}
			// if(blocked3 && blocked3Name === "") {blocked3Name = dataBaseName}
			// if(blocked4 && blocked4Name === "") {blocked4Name = dataBaseName}
			//blockedName = dataBaseName;
			//InvalidStateError: Failed to read the 'result' property from 'IDBRequest': The request has not finished.
			//remove if messes upREMOVED May13
			//e.target.result.close();
			//added May22 remove if problem
			event.stopPropagation();//this might be helping. A delayed delete did occur successfully 
			//added above May22 remove if problem

//CODE HERE TO AUTOMATICALLY DELETE ORIGINAL DB ?		
			
//alertblk("At ONBLOCKED OF DELETEDATABASE: blockedName[] = " + blockedName + " dbDeleted[] = " + dbDeleted + " blocked[] = " + blocked + " dbDeletedName[] = " + dbDeletedName);

// alert("At ONBLOCKED OF DELETEDATABASE: blockedName[] = " + blockedName[]  + " dbDeleted[] = " + dbDeleted[] + " dbDeleted2 = " + dbDeleted2 + " dbDeleted3 = " + dbDeleted3 + " blocked = " + blocked + " blocked2 = " + blocked2 + " blocked3 = " + blocked3 + " dbDeletedName1 = " + dbDeletedName1 + " dbDeletedName2 = " + dbDeletedName2 + " dbDeletedName3 = " + dbDeletedName3);

			while (dataBaseList.firstChild) {
   dataBaseList.removeChild(dataBaseList.firstChild);
		};//end while
		getFileNames();//DATE: April2 correct repeat of filenames list when a second blocked file has lock released and is deleted.removing this DID NOT WORK filenames just did not appear
			//remove above if messes up
        };//end of blocked while deleting database
    };//end of req.onblocked of opening database
	


// //experimental CODE TO SCROLL TO BOTTOM OF FILENAMES WINDOW SO FLASHING RESTORE BTN COMES INTO VIEW	
// // Create an observer and pass it a callback.
// var observer = new MutationObserver(scrollToBottomDiv); 
// // Tell it to look for new children that will change the height.
// var config = {childList: true};
// observer.observe(fileNamesWindow,config);
//  function scrollToBottomDiv() {
//   fileNamesWindow.scrollTop = fileNamesWindow.scrollHeight;
// }	
// //end experimental code to scroll to bottom	
	
	
	
	//CODE WILL STOP RUNNING HERE? After repeat deletes?May11
	//open db first. Then close it then delete
//THIS CODE WRITTEN BY JOSH BELL FROM GOOGLE OBTAINED FROMSTACKOVERFLOW.COM
//first open database
// indexedDB.open(dataBaseName).onsuccess = function(e) { var deletingDb = e.target.result;};//end open database

// var request = indexedDB.deleteDatabase(dataBaseName);
// request.onsuccess = function(e) { console.log("success"); 
// 	console.log("Database deleted successfully");
// 	getFileNames();//added May8 REMOVE IF MESSES UP 
// 	};//end request.onsuccess
// //rewrite .onblocked code and put open before delete	

// request.onblocked = function(e) {
//   console.log("blocked: " + e);
//   // Close connections here
//   //after repeating process program STOPS here at console.log
//  //blocked: [object IDBVersionChangeEvent]
// //   indexedDB.open(dataBaseName).onsuccess = function(e) { var deletingDb = e.target.result;
//   console.log('Closing database in order to unblock delete')
//   //TypeError: undefined is not an object (evaluating 'deletingDb.close')
// 	  deletingDb.close(); //};//end indexedDB.open.onsuccess
//  };//end request.onblocked

// // request.onblocked = function(e) {
// //   console.log("blocked: " + e);
// //   // Close connections here
// //   //after repeating process program STOPS here at console.log
// //   //blocked: [object IDBVersionChangeEvent]
// //   indexedDB.open(dataBaseName).onsuccess = function(e) { var deletingDb = e.target.result;
// // 	  console.log('Closing database in order to unblock delete')
// // 	  deletingDb.close(); };//end indexedDB.open.onsuccess
// // };//end request.onblocked

// request.onerror = function(e) { console.log("error: " + e); 
// 	console.log('Error loading database.');
// 	};//end request.onerror
	
// // 	//CODE BELOW REPLACED WITH CODE WRITTEN BYJOSH BELL FROM GOOGLE	
// // 	var DBOpenRequest = window.indexedDB.open(dataBaseName, ver); // opening a database.
// // 	// Create event handlers for both success and failure of
// // 	DBOpenRequest.onerror = function(event) {
// //  // note.innerHTML += "<li>Error loading database.</li>";
// //  console.log('Error loading database.');
// // };//end DBOpenRequest.onerror

// // 	DBOpenRequest.onsuccess = function(event) {
// //  // note.innerHTML += "<li>Database initialised.</li>";
// // console.log('Database initialised.');
// //   // store the result of opening the database in the db variable.
// //   deletingDb = DBOpenRequest.result;

// //   // now let"s close the database again!
// //   deletingDb.close(function(event){console.log('close after open ..' + event)});
// // // };//end DBOpenRequest.onsuccess
// // 	//TypeError: undefined is not an object (evaluating 'db.close')
// // deletingDb.close();
// // var DBDeleteRequest = window.indexedDB.deleteDatabase(dataBaseName);

// // DBDeleteRequest.onerror = function(event) {
// //   console.log("Error deleting database.");
// //   console.log(event);
// // };//end DBDeleteRequest.onerror
 
// // DBDeleteRequest.onsuccess = function(event) {
// //  //may 9 seems to delete because you can't load it in in spite of it showing in the list? If you go to table it says NEW and title id Notes
// // 	console.log("Database deleted successfully");
// //   getFileNames();//added May8 REMOVE IF MESSES UP 
// //   console.log(event.result); // should be undefined
// // //  clearDBFilesList();//added May 8 to keep db file list from repeating names deemed unnecessary May8
// // };//end DBDeleteRequest.onsuccess

// // DBDeleteRequest.onblocked = function(event) {
// //   console.log("Blocked");
// //   alert('Database DELETION blocked! Try again later.');
// // };
// // };//end DBOpenRequest.onsuccess

// // //CODE ABOVE REPLACED WITH CODE WRITTEN BYJOSH BELL FROM GOOGLE

}//end function deleteDataBase

//PROGRAM START
//THIS IS THE OPENING COMMAND ON STARTING UP THE DATABASE CODE
//don't think this code ever runs??Mar30
if (getFileNamesSwitch &!newDBflag) {
getFileNames();

	}//end if getFileNamesSwitch
// if just created new database, code below should make displayData screen show without having to tap the db name in the database list again?DOES NOT WORK BECAUSE CODE RERUNS FROM START AFTER ADDING NOTE AND ALL VARIABLES ARE INITIALIZED BACK TO 0 so still have to tap the new db name just created to see the new database	
if (upgraded === 1) {
	upgraded = 0;
	loadTheDataBase();
}//end if upgraded = 1

function loadTheDataBase (dataBaseName) {
if (blocked && blockedName === dataBaseName) {
	alert(dataBaseName + " The file is still blocked by the browser. Waiting for browser's Lock to time-out!");
	getFileNames();
}//end if (blocked && blockedName === dataBaseName) 

	//alert("At loadTheDatabase…savedTablesArray[0] = " + savedTablesArray[0]);
	console.log('In loadTheDataBase function.');
flipMenu.textContent = "Tap - Click to show / hide TABLE MENU";//clear flipMenu so search phrase from previous database does not show 
	const loadingDataBase= document.querySelector('#openDB');
	console.log('Name of database to load is ' + dataBaseName);
	
	
// 	if(dataBaseName.includes(".creatingDB")) {
// databaseNameLi[i].style.backgroundColor = "lightgrey";	databaseNameLi[i].setAttribute('class','borderBlink');
// }//end if(databases[i].name
	
	//special case
	if(dataBaseName === "notes_dbx") {
		objectStoreName = "notes_os";
	// } else if (dataBaseName.includes(".creatingDB")&& firstLOAD) {
	// //dataBaseName = dataBaseName.slice(0, -11);
	// objectStoreName = dataBaseName + "_os";
	// firstLOAD = false;
	// alert("objectStoreName = " + objectStoreName + ". newDBflag = " + newDBflag + ". newDBGuidance = " +newDBGuidance);
	// } else if (dataBaseName.includes(".creatingDB")) {
	// dataBaseName = dataBaseName.slice(0, -11);
	// objectStoreName = dataBaseName + "_os";
	// alert("objectStoreName = " + objectStoreName + ". newDBflag = " + newDBflag + ". newDBGuidance = " +newDBGuidance);
	} else {//end if dataBaseName = notes_dbx
objectStoreName = dataBaseName + "_os";
}//end if else

//alert("In loadTheDataBase - dataBaseName = " +dataBaseName);

console.log('objectStoreName = ' + objectStoreName);
if(newDBflag) {
	// newDBflag = false;
createNewDBWindow.setAttribute('class','hidden');
}//end if newDBflag

// clear the foundRecordsList if it exists from a previous database to prevent an operations error if doing a search in the freshly loaded db
if(foundRecordsList) {
	console.log('In Load the database..foundRecordsList = ' + foundRecordsList);
	foundRecordsList = false;
	while (resultList.firstChild) {
    resultList.removeChild(resultList.firstChild);
}//end while
}//end if foundRecordsList

fileNamesWindow.setAttribute('class','hidden');
	//loadingDataBase.textContent = 'The dataBase named ' + dataBaseName + ' is loading. This function will be wrapped around the programs open requests.' 
	//***********getDataBaseName has to be called here...use LoadTheDataBase as a wrapper around the getDataBaseName function!!!!!
//****************************
console.log('In loadTheDataBase function setup = ' + setup + '  going to getDataBaseName to see if there is a prexisting database!');

getDataBaseName(1,dataBaseName,objectStoreName).then(function(result) {
    // Do whatever you want with the data
	console.log('Returned from getDataBaseName. event.target.result = ' + event.target.result);
	var data = event.target.result;
	console.log('Back In loadTheDataBase after returning from getDataBaseName,hopefully at request.onsuccess getting database variables data if setup is 1 or if data undefined because dataBaseName_os was not found setup will then be 0. If data is undefined pickOldNew function will not work. Next call is to pickOldNew(). Data = ' + data + '. Setup = ' + setup);
	console.log('If creating new db, onupgradeneeded set variable to 1...upgraded = ' + upgraded + '. newDBflag = ' + newDBflag);
	//alert("Back from getDatabaseName….savedTablesArray[0] = " + savedTablesArray[0]);
	//OK HERE!
	//updatedbTableName for h2 HTML Apr 11
	if(changeDB) {
		dbTableName.value = data.variable1;
	}//end if changeDB
	
//IF DOING A DELETE THAT IS BLOCKED dbTableName is set to dataBaseName + .blocked..see deleteDataBase function
	//checking that filename was not blocked previously
	//alertflm("In loadTheDatabase: data.variable1 =  " +data.variable1 + " data.variable1.value = " + data.variable1.value);//RedPeppers .blocked
	
	//alert("Back from getDataBaseName - dataBaseName = " + dataBaseName + " data.variable1 = " + data.variable1);
	
	if(data.variable1.includes(".blocked")) {
	
	//put code here to repeat delete db again to cover scenario where having rebooted and tried to open a blocked file the browser has to be again made aware it is trying to block this file..otherwise I am not sure the browser will know to delete the file if all is starting from scratch after a reboot
	
	blockedName[checkIfBlocked] = dataBaseName;
	//remove alert after troubleshoot
	//alertflm("blockedName[" +checkIfBlocked + "] = " +  blockedName[checkIfBlocked]);//blockedName[0] = Red Peppers
	
	deleteDataBase(dataBaseName);//added Feb18 to cover scenario where a reboot is done prior to a locked file being deleted, and so that when rebooted DougieBase knows to delete the file again after the browser releases its lock. This scenario is only fulfilled after an addEventListener is triggered on the file
	getFileNames();	
	}//end if(data.variable1.includes(".blocked"))
	
	//IF CREATING NEW DATABASE, data = undefined after onupgradeneeded and return from getDataBaseName. PickOldNew function does not run. IF NOW YOU FOLLOW THE CREATING NEW DATABASE INSTRUCTION: Tap SAVE, GOING TO SaveVariables..
	//try this
	// if (data === "undefined") {
		
	// 	dbTableName.value = "The database was found but there were no object stores. Go ahead and add a record!"
	// }//end if data=undefined
	//try this
	//alert(" Calling pickOldNew function");
//alertbkup("Now going to pickoldnew…dataBaseName = " + dataBaseName);
	
	pickOldNew (data, dataBaseName);//added variable dataBaseName here Feb18 2023
	
});//end getDataBaseName.then call
//}*****************************************

	
	
	
}//end function loadTheDataBase LOAD THE DATABASE!!!Mar25
//alert('Done');change notes-dbx to dataBaseName .!,,,,,





alert('Installing DougieBase.. Install version = ' + ver);

	// console.log('setup = ' + setup + '  going to getDataBaseName to see if there is a prexisting database!');
	//if (!list.firstChild) {
//1 is the key passed to the getDataBase function	
// //****************************
// getDataBaseName(1).then(function(result) {
//     // Do whatever you want with the data
// 	var data = event.target.result;
// 	console.log('at request.onsuccess getting database variables data = ' + data + '. Setup = ' + setup);
// 	pickOldNew (data);
	
// });//end getDataBaseName.then call
// //}*****************************************


//get dbTableName
//if (setup === 1) {
	
	//code below moved to end of getDataBaseName so that saveVariables does not reset all variables to initial values after loading in a pre-existing db
	
/*
	if (setup===0) {
		console.log('At setup = 0. just added brackets to the function call. If upgraded === 1 or setup === 0 should go to saveVariables. If saveVariables not done then first addNote fails because first child has not been created by saveVariables and first addNote is not displayed! upgraded = ' + upgraded + '. setup = ' + setup);
		//remove line below if screw up
		//displayData below is not the answer because this makes 2 iterations of the first (really the second) note.
		//displayData();
		//!!! no brackets after saveVariables function so it didn't go there? ?ok not to have brackets if variable = function call, but NOT if just calling the function????!!! Yes now works after adding brackets to function call!
		//TOOK OUT SAVEVARIABLES HERE !!!!
	if (upgraded === 1 | setup === 0) {
		saveVariables();
		}//end if upgraded
		
	}//end if setup=0 
*/	


	
//came back here from saveVariables before saveVariables changed setup to 1. (setup still 0)	
//  }//end if setup ===1
//console.log('At end of request open notes_dbx');
  
//!!!!!!!!!!! might need to replace displayData here and remove it from saveVariables???or just put it in getDataBaseName? what happens when returning from addField..does data display?
  //displayData();
  //getDataBaseName();
//!!!!!!!!
//};//end request.onsuccess handler function .. a success event has triggered the success callback; 


// request.onupgradeneeded = function(e) {
//  //onupgradeneeded is the event, and the request object is the target of the event handlers function code.
// //onupgradeneeded is the only place where you can alter the structure |of the database. In it, you can create and delete object stores and build and remove indices.
// 	// Grab a reference to the opened database from the event target's result property which is the request object.(request.result)
//   let db = e.target.result;
  
//   //ConstraintError: Failed to execute 'createObjectStore' on 'IDBDatabase': An object store with the specified name already exists.
//   //createObjectStore won't execute if the os already exists
  
//   // instead of commenting out the original I put the original in an if statement that runs if ver =1, and the code to create the notesVariables_os in an if ver = 2 section
  
//   //maybe should be if (ver = 1 | 0) (OR) and the second create os if (ver === 2| 0) so that a newdb will create both os??
//   //this won't run unless .onupgradeneeded and if the _os already exists it won't overwrite..will produce an error and program stops. therefore in this case of ver9 db I put the if ver ===1 statement here to skip this code and moveon to creating the notesVariable_os .. see below. 
//  //if (ver === 0) {
//   let objectStore = db.createObjectStore('notes_os', { keyPath: 'id', autoIncrement:true });
  
// //the method to use to delete an objectstore is : 'deleteObjectStore(name);'
// //to close an objectstore 'close() - close object store'
//   //can I use this section to save vatiables xtraField and newFieldName?? do I need separate objectstore lines?
//   	/*	xtraField: 'xtraField',
// 		newFieldName: 'newFieldName', */
		
//   objectStore.createIndex('title', 'title', { unique: false });
  
//   //addind date of note creation
//   objectStore.createIndex('created', 'created', { unique: false });
//   //end code for adding date created
//   objectStore.createIndex('body', 'body', { unique: false });
//   //CODE FOR xtraField basically substituting xtraField for body
  
// 	  objectStore.createIndex('xtraField', 'xtraField', { unique: false });
//   objectStore.createIndex('variable1', 'variable1', { unique: false });
//   objectStore.createIndex('variable2', 'variable2', { unique: false });
//   objectStore.createIndex('dataV', 'dataV', { unique: false });
//    //createIndex() takes an optional options object that refines the type of index that you want to create
//    //Additionally, indexes have the ability to enforce simple constraints on the stored data. By setting the unique flag when creating the index, the index ensures that no two objects are stored with both having the same value for the index's key path. So, for example, if you have an object store which holds a set of people, and you want to ensure that no two people have the same email address, you can use an index with the unique flag set to enforce this.
   
//    //PLAN FOR XTRA FIELD: Create xtraField (body), xtraField (body). use if xtraField true create a string with first line fieldName rtn then data input from entry. version number will be set to 2 to trigger onupgradeneeded
// //}//end if ver === 1

//  //code for saving table variables
//   //this won't run unless .onupgradeneeded
//  //if (ver === 0) {
// //  let objectStoreV = db.createObjectStore('notesVariables_os', { keyPath: 'id', autoIncrement:true });
// // //should autoIncrement be false???!!!!!..no because that gave an can't resolve id pat Higgins for us error. if true I can use get(1) to open the _os.
// //   objectStoreV.createIndex('tableArray', 'tableArray', { unique: false });
  
// //  //field names
// //   objectStoreV.createIndex('fieldNamesArray', 'fieldNamesArray', { unique: false });
// //   //other variables
// //     //should this read 'otherVariables', 'otherVariablesArray' and declare otherVariablesArray at top??
// //   objectStoreV.createIndex('otherVariables', 'otherVariables', { unique: false });
// // //if you need another section
// // objectStoreV.createIndex('variable3', 'variable3', { unique: false });
// // //maybe variable3 should be added to notes-os and all variables put in it?..think not so all this data is not saved with every record?
// //  //end code for saving table variables
 
//    console.log('In onupgradeneeded. This means db_name not found and a new database is being created. (volatile memory of Trpextastic cache?. The ver # was not changed..still ver= ' + ver + '. Database setup complete. Now returning to .onsuccess handler of open database event? upgraded variable about to be set to 1. ');
// //}//end if ver === 9

//   //If the onupgradeneeded event exits successfully, the onsuccess handler of the open database request will then be triggered.Next run of program should run without triggering onupgradeneeded. but note that ver will have to be 9 because otherwise can't find db and on error is triggered
//   //after onupgrade needed code goes back to open db!! line 117
//   upgraded = 1;
//  // saveVariables();//firstDifference from fallBack
// };//end request.onupgradeneeded handler

//if (setup === 1) {getDataBaseName();}

form.onsubmit = addData;//from addNote window This is theCreateNewNote button in the Add new note window. The reference is to the input submit in the form element of the add new note window in HTML
//const manualContactsForm = document.querySelector('#contacts');form.onsubmit is used for addData so any other form with any kind of submit btn will divert program flow to addData and this caused the crash when adding contacts with the + btn! SO REMOVED THE FORM WITH ID =CONTACTS IN HTML AND AL REFERENCES TO IT IN JS I.E. manualContactsForm.BLUR ,!!?,?,?,


saveBtn.onclick = function () {
	
if (newDBGuidance) {
		//clearInterval(flashing);	
		NotesEditBtn.setAttribute('class','tdEdit');//want to restore notes edit btn to normal after it was set blinking in create new db	
	}//end if (newDBGuidance)
	
	
//disable SAVE if in a newTable ? Is this good or bad? Will you need this save btn to edit newTables??Date: Jan30 2022
if(makeContactsTable || loadFromTableOptions) {
	alert("The MAIN MENU SAVE button is DISABLED because you can not Save a database from the main menu when a new table is currently active. Returning to the Table screen! and clear the new table or contacts table.  loadFromTableOptions = " + loadFromTableOptions + " makeContactsTable = " + makeContactsTable);
	saveBtn.style.backgroundColor = "lightgrey";
	saveBtn.disabled = true;
//saveTableBtn.disabled = true;
saveTableBtn.textContent = "SAVE";
//saveTableBtn2.disabled = true;
saveTableBtn2.textContent = "SAVE";	
showTable.setAttribute('class','showing');
	return //you don't want to go on to saveVariables! DID THIS CAUSE A GLITCH IF ACCIDENTALLY USED SAVE.BTN ..SHOULD RETURN BE REPLACED WITH SHOW Table? Date:Mar28 2023 OR saveTableBtn.click()
	} else { //code below never runs?
	saveBtn.style.backgroundColor = "rgb(240, 248, 255)";
	saveBtn.disabled = false;
	saveTableBtn.disabled = false;
saveTableBtn.textContent = "SAVE";
saveTableBtn2.disabled = false;
saveTableBtn2.textContent = "SAVE";	
}//end if makeContactsTable || loadFromTableOptions

//-xxxx-xxx
	//error code to prevent saving null data if user has not selected a db Dec21 2021
	if(dbName === undefined && !newDBflag) {
		alert('No database has been selected! Select or create a database to make SAVE available.');
	//prefWindow.setAttribute('class','hidden');
		//getFileNames();
		return;
	} //end if dbName===undefined
	//return false;
	
	if(newDBflag) {
		addNoteBtn.disabled = false;//for create new db, add note btn was disabled in onupgradeneeded
		//addNoteBtn.setAttribute('class','attentionBtn');
	//if displayTableBtn is flashing at time of Edit there is confusion! Added May25
		//displayTableBtn.setAttribute('class','tdEdit');
		addNoteBtn.setAttribute('class','borderBlink');
		saveBtn.setAttribute('class','normalBtn');
		newDBflag = false;
		}//end if newDBflag
	saveVariables();//need to add the brackets here to have the save function work! May23DID THIS CAUSE A GLITCH IF ACCIDENTALLY USED SAVE.BTN
	}//end function saveBtn.onclick May23
	
loadBtn.onclick = function() {
	documentation();//this line was loadBtn.onclick = load; loadBtn now labelled HELP see html
	fromHELP = true;
	}//end function loadBtn.onclick
	
tableScreenBtn.onclick = function () {
tableScreenBtn.setAttribute('class','tdEdit');///in case flashing from new budget sheet creation
//alert("> TableScreenBtn tapped renameNewTableFlag = " + renameNewTableFlag);
if(renameNewTableFlag) {
tableScreenBtn.setAttribute('class','tdEdit');
displayTableBtn.setAttribute('class','borderBlinkGrn');
//return;//to prevent trip to resetContacts ? NOT REQUIRED. WILL STOP PRGM.????
}//end if(renameNewTableFlag)

	if(convertingOldFile) {tableScreenBtn.setAttribute('class','editTD');
	tableScreenBtn.textContent = "TABLE";
		}//end if convertingOldFile
		
	tableScreenOptions();
	
	//}//end dataTableName.value.includes
}//end tableScreenBtn.onclick

searchBtn.onclick = searchRecords;

newDBBtn.onclick = function () {
scrollHere = false;//added Dec4
	scrollBtn.textContent = "Scroll ⬇️";
showTable.setAttribute('class', 'hidden');
//THIS IS THE NEW/CHANGE DB button in main menu!
backupBtn1.style.display = "none";
 backupBtn2.style.display = "none";
//trigger SAVE warning if unsaved data in another database prior to loading in a new one. SHOULD THIS CODE BE IN THE NEW/CHANGE DB code section
//alertbkup("At changeDB - dataNotBackedUp = " + dataNotBackedUp + " dataBaseName = " + dataBaseName + " dbTableName.value = " + dbTableName.value + " dataAltered = " + dataAltered + " bkupAlertsFlag = " + bkupAlertsFlag);

if(bkupAlertsFlag && dataNotBackedUp && !(dbTableName.value.includes("blocked"))) {//added.includes Mar9
	if (window.confirm("You have recently saved data to " + dbTableName.value + " that is not backed up! BACKUP RECENTLY SAVED DATA ? : \n" + "  CANCEL will continue without backup.")) {
	dataBaseName = dbTableName.value;
	
	//alertbkup("After choice prompt…going to bkup - dataNotBackedUp = " + dataNotBackedUp + " dataBaseName = " + dataBaseName + " dbTableName.value = " + dbTableName.value);
	
//if renamedDBName = true (case scenario where a budget sheet was created or a file renamed? Or a new db created? dbTableName.value will have had its name stripped of .bs and then in the meantime renamedDBName has been made false manipulate string called in the backup code will not be called and so the opportunity to restore dataBaseName.bs is lost. So check before going to backup that if budgetsheet dataBaseName has .bs on the end otherwise you get a path taking you through onupgradeneeded	Date:Mar 11 2023dataBaseName WAS STRIPPED OF .BS IN THIS SCENARIO WHERE YOU ARE IN A NEWDBBTN.ONCLICK AFTER COMING FROM A CREATION OF NEW BUDGET SHEET!
//this line gards against this situation Mar11
if(budgetSheet && !(dataBaseName.includes("bs"))) {
		dataBaseName = dataBaseName + ".bs";
	}//end if(budgetSheet && !(dataBaseName.includes("bs")))
//alert("in getFileNames going to backup after prompting if you want to backup, budgetSheet flag = " + budgetSheet + " dataBaseName = " + dataBaseName);
	//reset renamedDBName flag to false so backup is just a backup
	reNamedDBFileName = false;//this flag prevents backup routine from going to manipulateString Mar9 Mar11  2023
	backupDataBase(dataBaseName);
	dataNotBackedUp = false;
	} else {
		dataNotBackedUp = false;//has to be false as well otherwise you continually get backup warning and with the wrong database as dataBaseName will now become the tapped on filename
		//return;
	}//end confirm backup prompt

}//end if(dataNotBackedUp)

if(dataAltered) {
	if (window.confirm("You have recently edited data in " + dbTableName.value + " that has not been SAVED! SAVE RECENTLY EDITED DATA ? : \n" + "  CANCEL will continue without saving.")) {
	dataBaseName = dbTableName.value;
	
//if renamedDBName = true dbTableName.value will have had its name stripped of .bs and then in the meantime renamedDBName has been made false manipulate string called in the backup code will not be called and so the opportunity to restore dataBaseName.bs is lost. So check before going to backup that if budgetsheet dataBaseName has .bs on the end otherwise you get a path taking you through onupgradeneeded	Date:Mar 11 2023 dataBaseName WAS STRIPPED OF .BS IN THIS SCENARIO WHERE YOU ARE IN A NEWDBBTN.ONCLICK AFTER COMING FROM A CREATION OF NEW BUDGET SHEET!
//this line gards against this situation Mar11
if(budgetSheet && !(dataBaseName.includes("bs"))) {
		dataBaseName = dataBaseName + ".bs";
	}//end if(budgetSheet && !(dataBaseName.includes("bs")))
//alert("in newDBBtn.onclick dataAltered going to backup after prompting if you want to backup, budgetSheet flag = " + budgetSheet + " dataBaseName = " + dataBaseName);	
	
reNamedDBFileName = false;//this flag prevents backup routine from going to manipulateString Mar9 Mar 11 2023	
	resetFields = true;//lose field names returning to table to save Mar13 2023..don't think this will do anything given showTable class showing rather than displayTable() ?
	
	saveTableBtn.setAttribute("class", "borderBlink");
	saveTableBtn2.setAttribute("class", "borderBlink");
	showTable.setAttribute('class', 'showing');
	//saveVariables();
	dataAltered = false;
	} else {
		dataAltered = false;//has to be false as well otherwise you continually get SAVE warning and with the wrong database as dataBaseName will now become the tapped on filename
		//return;
	}//end confirm backup prompt

}//end if(dataAltered)


scrollHere = false;//added Dec4 only put here and not in more notes so it is maintained while in that main table database
rowSummed = false;//this flag indicates if total is summing in last field or other fields see summing()
savedOriginal = false;//reset for loading in a new db
originalOrder = true;//flag that gives warning if not SAVED after a sort is reset
fromEditFieldLabels = false;
tableLimit = false;//reset this flag if leaving a database so the new db gets to start afresh re number of tables relative to limit date:April27
DTBtnTappedOnce = 0;//to prevent fields header being messed up if switching db and doing an edititem Mar5 2022
contactsFieldNames.length = 0;//clear the new table field names to reset for a new database
	if(convertingOldFile) {
		newDBBtn.setAttribute('class','tdEdit');
		newDBBtn.textContent = "NEW/CHANGE DB";
		convertingOldFile = false;
	}//end ifif(convertingOldFile) 
	//should this also include  loadFromTableOptions?
	if(makeContactsTable || loadFromTableOptions) {
				resetFromContacts();
			}//end if makeContactsTable
	console.log('new/changeDBBtn tapped.');
	changeDB = true;//Important need this
	dbListExists = true;
	
	//code below prevent table being messed up if you do an edit then change databases before updating the table
	console.log('DTBtnTappedOnce = ' + DTBtnTappedOnce + 'editNote = ' + editNote + 'tableExists = ' + tableExists);
	//add another condition if (updateNeeded)
	if(tableExists && editNote || tableNeedsUpdate){
		alert('Update the Table before leaving current database.')
		tableScreenOptions();
		editNote = false;
	}
	//code above prevent table being messed up if you do an edit then change databases before updating the table
	
//CODE BELOW OK BUT WHY DID I NOT ALSO ADD STSECONDDATANAMETDLISTENER???
//function below will cover everything?
if(telephoneActive || eMailActive || STfirstDataNameTdListener || STsecondDataNameTdListener) {
resetFixedFieldActivity();	
}// end if(telephoneActive || eMailActive) {
	
if(STfirstDataNameTdListener) {
STfirstDataNameTd.removeEventListener('dblclick',STfirstDataNameTd.fn, false);
	//STfirstDataNameTd.removeEventListener;
	STfirstDataNameTdListener = false;
	telephoneActive = false;
	
STfirstDataNameTd.removeEventListener;
 STfirstDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STfirstDataNameTdListener)

if(STsecondDataNameTdListener) {
STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
	//STsecondDataNameTd.removeEventListener;
	STsecondDataNameTdListener = false;
	eMailActive = false;
	STsecondDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STsecondDataNameTdListener)


	getFileNames();//date Mar11 2023
	}//this function call starts DougieBase off with current filenames as opening screen!//end newDBBtn.onclick
manageBtn.onclick = function () {
fileNamesWindow.setAttribute('class','hidden');	//added Jan 24 2023
 manageBtn.setAttribute('class','tdEdit')//reset if blinking from changeMonth in new budget sheet
 firstManageBtn.setAttribute('class','tdEdit');
	manageDbListExists = true;//flag to prevent manageDbList from repeating
	manageDataBases();
	}//end manageBtn.onclick
	
//manualContactsSubmit
addContactsBtn.onclick = async function (createContacts) {
//to add ADDRESS field if coming from addContacts/Records
addContactsBtnTapped = true;//to add ADDRESS field if using ADD CONTACTS
	if(dbName === undefined && !newDBflag && !newDBGuidance) {
		alert('⚠️ No database has been selected! Select or create a database to make ADD CONTACTS/RECORDS available.');
		
		return;
	} //end if dbName===undefined

if(DTBtnTappedOnce ===0 & tableExists && !makeContactsTable && !loadFromTableOptions){initializeTable();return}

emailBtn.setAttribute('class','tdEdit');//stops flashing CONTACTS btn if Field Labels btn used prior to ADD CONTACTS 
addContactsBtn.setAttribute('class','tdEdit');
checkTableLimit();
if (tableLimit) {
tableLimit = false;
showTable.setAttribute('class','hidden');
return;	
}
//let defaultFieldNames = [];
let defaultFieldNames = "CONTACT NAME,DATE,TELEPHONE,EMAIL,ADDRESS";
if(contactsFieldNames.length !== 0) {
	defaultFieldNames = "";
	//defaultFieldNames.length = 0;
}

//code for promptBox 3 btns .. EDIT FIELD NAMES, USE CURRENT FIELD NAMES, CANCEL
promptBox.setAttribute('class','showing');
//	tableScreen.setAttribute('class','hidden');
// tableNameTxt.setAttribute('style', 'white-space: pre;');//enable line breaks add \r\n in text everywhere You want for line-break (new line)
//tableNameTxt.setAttribute('class','ppref');
tableNameTxt.setAttribute('style', 'white-space: pre-wrap; background-color: black; color: white; border: 2px solid red; border-radius:3px; padding:5px');//enable line breaks add \r\n in text everywhere You want for line-break (new line)

//alertx("defaultFieldNames = " +defaultFieldNames + " contactsFieldNames = " +contactsFieldNames);
console.log("defaultFieldNames = " +defaultFieldNames + " contactsFieldNames = " +contactsFieldNames);

tableNameTxt.textContent = `ADD CONTACTS/RECORDS allows manual entry of records. The ContactPicker API is not available here. The current field headings are: ` +`\r\n` +defaultFieldNames + contactsFieldNames +` \r\n ` + `
    EDIT FIELD NAMES will allow re-naming field labels (Tap Field Headings on table screen) \r\n
     USE CURRENT FIELD NAMES will create a new Table with the current headings above. \r\n
      CANCEL returns to table screen.`;
      
actionLoadBtn.textContent = "EDIT FIELD NAMES";
actionRenameBtn.textContent = "USE CURRENT FIELD NAMES";
actionCancelBtn.textContent = "CANCEL";
actionDeleteBtn.style.display = "none";
actionRenameBtn.style.display = "unset";//this btn might get devisualized in Field Labels




//prompt to give choice to edit field names
//confirm choice window
		 // if (window.confirm("The current field headings are: " + defaultFieldNames + contactsFieldNames +" \n" + "  OK will allow editing of field labels (Tap Field Headings on table screen) \n CANCEL will create a new Table with the current headings above.")) {
		 //showTable.setAttribute('class', 'showing');
		 //await editNewTableFieldNames();
		 
//Allow for scenario of ADD CONTACTS new table if preceding screen was a resultant table from a searched main db table make Fields Labels btn show or tell user to go back to Display Main db table…in aid of having the fields label btn on the screen!

//if(tableArray[0][0].includes(">")) {the Field Labels btn

//edit field names uses actionLoadBtn btn
actionLoadBtn.onclick = function () {
newTableFieldsBtn.style.display = "unset";
//}//end if(tableArray[0][0].includes(">")) {
promptBox.setAttribute('class','hidden');

newTableFieldsBtn.setAttribute('class','borderBlink');
actionRenameBtn.setAttribute('class','borderBlink');//so this btn is flashing when you come back to it from the Field Labels scrn
	showTable.setAttribute('class','showing');	
actionLoadBtn.setAttribute('class','borderBlink');//so EDIT FIELD NAMES btn is flashing when you go to the Field Labels screen	
//actionLoadBtn.style.display = "none";//so only use current appears when returning to this screen via ADD CONTACTS/RECORDS during the EDIT FIELD NAMES process of ADD CONTACTS Date:May1..doesn't work because this screen revisited before final ADD CONTACTS!
	fromAddContacts = true;//flag to tell editNewTableFieldNames to flash and return to ADD CONTACTS
	//actionLoadBtn.style.display = "none";
		 }//end actionLoadbtn.onclick
		 
//use current uses actionRenameBtn btn
actionRenameBtn.onclick = function () {	
actionLoadBtn.style.display = "unset";//$in case disvisualized in EDIT FIELD NAMES process
 actionRenameBtn.setAttribute('class','tdEdit');
promptBox.setAttribute('class','hidden');
contactsArray.length = 0;//preventing addContacts from tagging on to previous table ? Mar14
manualContacts.length = 0;
newTableFieldsArray.length = 0;

	 manuallyCreateContacts();
	}//end function actionDeleteBtn.onclick
//CANCEL action
actionCancelBtn.onclick = function () {
fromAddContacts = false;//flag to tell editNewTableFieldNames to flash and return to ADD CONTACTS
actionRenameBtn.setAttribute('class','tdEdit');//in case flashing from a cancelled edit field names
actionLoadBtn.setAttribute('class','tdEdit');//so EDIT FIELD NAMES btn is not flashing when you go back to the Action Prompt screen	
actionLoadBtn.style.display = "unset";//$in case disvisualized in EDIT FIELD NAMES process
promptBox.setAttribute('class','hidden');
showTable.setAttribute('class','showing')
	
}//end function actionCancelBtn.onclick	
	
}//end addContactsBtn.onclick = function

backupBtn1.onclick = function (dataBaseName) {
dataBaseName = dbTableName.value;
backMeUp(dataBaseName);
	}//end function call backupBtn1.onclick = function
//now what happens when no notes and we go to add note btn returning to addData function??
console.log('dataBaseName = ' + dataBaseName);
// Define the addData() function
//now what happens when no notes and we go to add note btn returning to addData function??

// Define the addData() function
function addData(e) {
//IN AID OF PREVENTING A REFESH RELOAD OF CODE WHEN CREATING A NEW DB!! May27 2022
if (newDBGuidance && xtraField === 0) {

//alertx("newDBGuidance = " +newDBGuidance + " newDBflag = " + newDBflag + " should now go to getfilenames");

		getFileNamesSwitch = false;
		
		if (!refreshing) {
    refreshing = true;
    alert("Reloading page!");
    window.location.reload();
    }
		// will this fix wild crash reset? May 26 2022 
		//stopped here
		//fileNamesWindow.setAttribute('class','showing');
		getFileNames();
	
		// will this fix wild crash reset? May 26 2022 
	//trying to fix crash when creating new db .. need to force a reload	
	
	
//navigator.serviceWorker.addEventListener('controllerchange',
 
    // if (!refreshing) {
    // refreshing = true;
    // window.location.reload();
    // }


		//return;
	}//end if newDBflag
	
//IN AID OF PREVENTING A REFESH RELOAD OF CODE WHEN CREATING A NEW DB!! May27 2022. ^^^^^^
	
	console.log('At addData');
editNote = true; //flag added to prevent switching to another db if a record added to current one without having initialized the table	
//trying to fix fields getting messed up in displayTable if viewing main db table after viewing a new table Mar7
if(fromNewTable) {
resetFields = true;//flag used at reconstuction of displayTable
fromNewTable = false;
}//end if fromNewTable

//maybe setup = 1 should be here. Otherwise you can add a new note to a new db but not be able to see its variables
//!!!!!!!REMOVE setup=1 if not working!!!!!!
//setup = 1;
//!!!!!!

//createNewDBGuide
//for guidance creating newDB
console.log("In addData function after Add Note btn - theCreateNewNote button tapped (the newDBflag is made false when you tap the SAVE button) : newDBGuidance = " + newDBGuidance + "newDBflag = " + newDBflag + " xtraField = " + xtraField);
if(newDBGuidance) {
	addNoteWindow.removeChild(newDBGuideP);
newDBGuideP.textContent = "For creating a new database, now tap ADD RELABEL FIELD', then EDIT your first record to add data to the second NOTES data field of this record. Return to Preferences and tap 'Show Extra field'";
prefWindow.appendChild(newDBGuideP);
settingsBtn.setAttribute('class','borderBlinkGrn');//was attentionBtnREPLACE IF NOT WORKING
}//end if newDBflag
//end for guidance creating newDB

//createNewDBGuide

addNoteWindow.setAttribute('class','hidden');
//is above line needed?? YES. THIS CLEARS THE ADD NOTE WINDOW FROM addNoteBtn.onclick line 815?
  // prevent default - we don't want the form to submit in the conventional way
  //e.preventDefault triggers undefined error if addData runs without form.onsubmit so put it in a conditional e is the event of the event handler form.onsubmit in this case so undefined if not comming from the form.onsubmit handler.
  
  
  //do I need if setup = 0? and to declare dataV again. I don't think so??
  
   
//  if (setup === 0) {
// 	 //construuct dataV object
// 	otherVariablesArray = [tableExists,showExtraField,nextFieldName,numberOfFields,numberOfDynamicFields,tableTitle,paraBody,displayXtraFieldData];
// 	otherVariablesArray[1] = showExtraField; 
	 
// 		dataV = {
//   tableArray: tableArray,
//   fieldNamesArray: fieldNamesArray,
//   otherVariables: otherVariablesArray,
//   variable3: variable3
// };//end declaration of dataV object 

 if (counter > 1) {
	  e.preventDefault();
 }
 
today = new Date();
todayS = today.toString();
todayString = todayS.slice(3, 21);
//alert('todayString = ' + todayString);
  //code to add date to title.input
  if (noteDate) {
	  titleInput.value = titleInput.value + ' ' + date;
	  noteDate = false;
	  addDateBtn.disabled = false;//enable addDateBtn so it is ready to accept a date for next use of addNote
  }//end if noteDate
  
  // grab the values entered into the form fields and store them in an object ready for being inserted into the DB
  
  //new code for xtraField
 // alert('value of xtraField = ' + xtraField);
/*  if (xtraField) {
	  xtraFieldInput.value = newFieldName + ': \n' + xtraFieldInput.value;
	 let newItem = { title: titleInput.value,
		 created: new Date(), body: bodyInput.value, xtraField: xtraFieldInput.value}; 
  }//end if xtraField*/
  
  //if xtraField does not get set then make xtraField = 0. otherwise at line add new Item generates an insufficient data error
  
  if (xtraField !==1) {//was>1
	  xtraField = 0;
	  
  }//end if xtraField !=1 or 0
  
  if (xtraField === 0) {
	  //necessary because if at start there is no extra field then new Item provides insufficient data
	  //DataError: Provided data is inadequate.line 277
	  xtraFieldData = ' ';
	  xtraField = 0;
	  newFieldName = ' ';
	//  alert('here we are at !xtraField');
	//let removed !
	//changed created: new Date to todayString
	//if coming here from else code of displayData..setup = 0, no cursor on first run of program, titleInput.value will have been set to value of xtraField variable ..we are creating the admin first record
	     newItem = { title: titleInput.value,
		  created: todayString, body: bodyInput.value, xtraField: xtraFieldData, variable1: dbTableName.value, variable2: variable2Array, dataV: dataVobj};
		  //changed variable2: setup to variable2Array
	//	ReferenceError: Can't find variable: dataVobj // lineb2314
		
		  //dataVobj will compare to variable2Array, and dataV: will compare to variable2:
		//  alert('newItem title reads: ' + newItem.title);

  }//end if
  //end of code for xtraField
  
 
 
 //xtraFieldData = inputExtraFieldData.value;
// alert('value of xtraField = ' + xtraField);
 
	//  alert('here we are at !xtraField');
	
		//  alert('newItem title reads: ' + newItem.title);

else if (xtraField === 1) {
	//for the sake of table appearance I replaced line below with: Nov 25 2020
	xtraFieldData = inputXtraFieldData.value;

	//xtraFieldData = newFieldName + ': \n' + inputXtraFieldData.value;//+ xtraFieldData maybe should be + inputExtraFieldData.value;
	//changed created: new Date to todayString
	
	  newItem = { title: titleInput.value,
		 created: todayString, body: bodyInput.value, xtraField: xtraFieldData, variable1: dbTableName.value, variable2: variable2Array, dataV: dataVobj}; 
		 	  //changed variable2: setup to variable2Array
		 //in displayData if xtraFieldData != "" append hild listItem
	//should this be xtraFieldData
	
}//end else if xtraField ===1


 // alert(newItem);
  let transaction = db.transaction([objectStoreName], 'readwrite');
  
  let objectStore = transaction.objectStore(objectStoreName);

  // Make a request to add our newItem object to the object store. Add the new record to the database. This creates a request object, 
 // alert('about to add newItem');
 //when coming here from addNote without setting anything in preferences and starting with no notes this error is generated..DataError: Provided data is inadequate.
 
 //DataError: Provided data is inadequate.
 
 //??????I think changing xtraField variable to 1 in preferences then saving fixed this error???????
// alert(newItem);
  let request = objectStore.add(newItem);
  
//Other methods: Methods returning IDBResult (range may be used instead of key where applicable):

/*add(value [, key]) – adds a new record into database put(value [, key]) – updates/adds a record delete(key) – remove entries, clear() – removes all entries count([key]) – number of records in object store get(key) – retrieves data from object store openCursor([range] [,direction]) – creates cursor to iterate read-only transaction → all changes cause ReadOnlyError

Methods working with indexes:

parameters – object may set unique or multiEntry true

idx = index(name), deleteIndex(name) */
  //The result of a request generated from a call to add() is the key of the value that was added.
   //look uo 'for each' the code might be useful here?:
  /*customerData.forEach(function(customer) {
	  var request = objectStore.add(customer);*/
  request.onsuccess = function() {
  //ADDED THIS LINE JAN18 2023 to update the save table arrays so that the tableArray variables are restored to updated info after an ADD Note
  savedOriginal = false;//to trigger updating saved table arrays to enable restoring to main db mode has uptodate info following an ADD Note btn tap.
  
    // Clear the form inputs from the addNote window to be ready for adding the next entry in addNote
	console.log('At request.onsuccess of addData after adding newItem');
    titleInput.value = '';
    bodyInput.value = '';
	if (xtraField === 1) {
		inputXtraFieldData.value = '';
	}//end if
  };//end request.onsuccess

  // Report on the success of the transaction completing, when everything is done
  //IDBTransaction.oncomplete was fired only when all data was guaranteed to have been .value 

  // Report on the success of the transaction completing, when everything is done
  //IDBTransaction.oncomplete was fired only when all data was guaranteed to have been flushed to disk.
  transaction.oncomplete = function() {
    console.log('Transaction completed: database modification finished.');
	//show notice below only once .. at first run of app when there are no notes
	if (viewedThis === 0) {
		viewedThis = 1;
	//alert('In addData. Create first note by tapping the Add Note button. You may also set settings for creating and naming the extra field, or do this at a later time. (Tap Preferences button, then Add Field.) .. extra field must be set to showing.   Tap OK to continue.');
	 
		
	}//end if viewedThis = 0

    // update the display of data to show the newly added item, by running displayData() again...if here from setting up admin record, cursor will now exist in displayData so the setup admin record code should not run again, and the setup variable should be set to 1.
	console.log('leaving addData and going to displayData. counter = ' + counter);
	//to avoid going back to fileNames function after add note in createNewDB Apr8
	if (newDBflag) {
		getFileNamesSwitch = false;
		
		// // will this fix wild crash reset? May 26 2022 
		// //stopped here
		// getFileNames();
		// // will this fix wild crash reset? May 26 2022 
		
	}//end if newDBflaf
	//to avoid going back to fileNames function after add note in createNewDB
	
    displayData();
  };
//the default behavior of an error is to abort the transaction in which it occurred. Unless you handle the error by first calling stopPropagation() on the error event 
  transaction.onerror = function() {
    console.log('Transaction not opened due to error');
  };
 dataAltered = true;//flag to provide warning if data changed but not saved 
 
}//end addData function

//left off here Dec 122020

// Define the displayData() function
function displayData() {
	console.log("In dispalyData..called by pickOldNew..…after retrieving dataVobj…….tableIndex = " + tableIndex + " tableListExists = " + tableListExists + " newTableNames = " + newTableNames);
	
	//removed! if messes up trying to reset background image as per each database Nov11 this code (removed) does not allow the database to load in
	
	
	
	//alert('dateShade = ' + dateShade);
	//alert('viewDateWritten =  ' + viewDateWritten);
	//on last run Oct 5 2020 console.log says setup=0, but viewsettings says setup=1?
	console.log('at DisplayData. counter variable is being set to 0. The setup variable = ' + setup);
	counter = 0;
	loadBtn.disabled = false;
	saveBtn.disabled = false;
	/*if (setup === 0) {counter = 0;
	} else {
		counter = 1;
	}//end if elsesetup counter = 0; */
	
  // Here we empty the contents of the list element each time the display is updated
  // If you didn't do this, you'd get duplicates listed each time a new note is added
    //this says while there is a list item remove it until there are no more list items.while loops through all the li items removing them until no more left...the ul is now empty ready for the renewed display data. When the top li is removed, the next one becomes the first child and it is removed. We do not want to remove the ul elements as they are needed for the updated display.
  while (list.firstChild) {
    list.removeChild(list.firstChild);
  }

  // Open our object store and then get a cursor - which iterates through all the
  // different data items in the store Next, we get a reference to the notes_os object store using IDBDatabase.transaction() and IDBTransaction.objectStore() +like we did in addData(), except here we are chaining them together in one line.(shorthand)
  let objectStore = db.transaction(objectStoreName).objectStore(objectStoreName);
   //if you don't specify the transaction mode, then defaults to read only. Calling transaction() with no mode specified gives you a "readonly" transaction.Only specify a readwrite transaction mode when necessary. You can concurrently run multiple readonly transactions with overlapping scopes, but you can have only one readwrite transaction for an object store.  Note that if deleting using the delete button, the tansaction method in the delete function does specify readwrite as the mode.
  //The next step is to use IDBObjectStore.openCursor() method to open a request for a cursor — this is a construct that can be used to iterate over the records in an object store. We chain an onsuccess handler on to the end of this line to make the code more concise — when the cursor is successfully returned, the handler is run.
  objectStore.openCursor().onsuccess = function(e) {
    // Get a reference to the cursor. Get a reference to the cursor itself (an IDBCursor object)
    let cursor = e.target.result;
	//The cursor object itself is the result of the request (above we're using the shorthand, so it's event.target.result). Then the actual key and value can be found on the key and value properties of the cursor object. If you want to keep going, then you have to call continue() on the cursor. 
//One common pattern with cursors is to retrieve all objects in an object store and add them to an array, .. see MDN web docs UsingIndexedDB
    // If there is still another data item to iterate through, keep running this code. Check to see if the cursor contains a record from the datastore
    if(cursor) {
		
	//	console.log('There is a cursor so setup =1; depends on which dbx is found by Textastic when loading a fresh run of code.');
		if(setup===3) {
			setup=3;
		} else {
		setup=1;//added this Oct 5 2020 might be wrong thing to do????!!!!!
		}//end if setup ===3
		//if so, we create a DOM fragment, populate it with the data from the record, 
      // Create a list item, h3, and p to put each data item inside when displaying it
      // structure the HTML fragment, and append it inside the list..insert it into the page (inside the <ul> element)
	 // the ListItem is the note that contains the note title..h3.. and the body text para
	 //alert('cursor.value.created = ' + cursor.value.created);
      const listItem = document.createElement('li');
      const h3 = document.createElement('h3');
	//  if (viewDateWritten) {const dateP = document.createElement('p');}//end if viewDateWritten
	const secondDataH4 = document.createElement('h4');//title of second field data
      const para = document.createElement('p');
	  const dateP = document.createElement('p.date');
	 // const dateP = document.createElement('p.date');//was h3 h5 does not work NOTE when this was removed to top code so dateP was recognized in viewCreationDate, it would not shoe date in each instance,only the last!
	  const displayXtraField = document.createElement('p');
	  dateP.setAttribute('class','date');
	  //set colours
	  
	  if (dateShade === "black") {
		 dateP.style.color = "black" ;
	  
     } else if (dateShade === "white") {
		dateP.style.color = "white" ;
	//dateP.setAttribute('class','dateWhite');
	 }//end elde if dateColor
	// alert('dateP.style.color = ' + dateP.style.color);
	  listItem.style.backgroundColor = noteListItemColour;
	  h3.style.backgroundColor = noteTitleColour;
	  para.style.backgroundColor = bodyColour;
	  displayXtraField.style.backgroundColor = xtraFieldColour;
	//font colour  
	  	  listItem.style.color = fontColour;//style color inhereits so only need to change listItem
//align title to center of record-code below
if(centerTitle) {
h3.setAttribute('style','text-align: center');
h3.style.backgroundColor = noteTitleColour;//if this line comes before text-align it doesn't register and background color is not changed
}else if(!centerTitle) {
	h3.setAttribute('style','text-align: left');
	h3.style.backgroundColor = noteTitleColour;
}//end if(centerTitle)
//align title to center of record- code above

	 /*REMOVE h3.style.fontColor = "white";
	  para.style.textColor = "white";
	  para.setAttribute('color', 'white');*/
//const para2 = document.createElement('p');
      listItem.appendChild(h3);//put h3 inside the li
	  //alert('viewDateWritten variable = ' + viewDateWritten);
	  if (viewDateWritten) {listItem.appendChild(dateP);}//put h5 inside the li}//end if viewDateWritten
      listItem.appendChild(para);//put p inside the h3 inside the li
//	  listItem.appendChild(para2);
//alert('contents of extraField = ' + cursor.value.xtraField);
if (showExtraField===1 & cursor.value.xtraField !== " ") {
	
	listItem.appendChild(secondDataH4);//title of secondField dataNov 25 2020
	listItem.appendChild(displayXtraField);
	//above line was : if (showExtraField===1) {listItem.appendChild(displayXtraField);
		//the idea is to not display the extra field if it is empty
}//end if xtraField

//display all but first note
//perhaps should use cursor range here. 
/*Methods (all returning IDBRequest):

openCursor([range] [,direction]) openKeyCursor([range] [,direction]) – organized by index count([key]), get(key) getKey(key) – gets the key from referenced entry */
console.log('Start of displayData. cursor.value.id = ' + cursor.value.id);
if (cursor.value.id  != 1) {
      list.appendChild(listItem);//add the li to the ul
	  //if buildingTableArrays switch is on create the table arrays but don't include (admin) record 1. Because arrays start at 0 use -2 to bring the array index down to 0 at start
	 //works without buildingTableArrays switch so will leave to see if needed If deleting a record cursor.value.id 3 gets deleted so cursor.value 4 contains CN4700...I WANT TO MAKE tableTitle [1]=CN4700..so when cursor.value.id is 4 go -3 to make tableTitle[1] = CN4700 AND YOU WANT tableTitle[2]to = cursor.value.id 5 -3 OR TRY USING COUNTER?
	 //if (deleteTableRecord === 1) {
	//	offset = -2 -1 
		 
	// }//end if deleteTableRecord = 1
	  // tableTitle[cursor.value.id - 2] = cursor.value.title;//locomotive 
	  // dateTable[cursor.value.id-2] = cursor.value.created;//date record created
	  // paraBody[cursor.value.id -2] = cursor.value.body;//location
	  // displayXtraFieldData[cursor.value.id -2] = cursor.value.xtraField;//(decoder) maybe should just use newFieldName?
	  
	  // console.log('In displayData, iterating through notes_os with cursor. tableTitle[' + Number(cursor.value.id -2) +'] = ' + tableTitle[cursor.value.id -2]);
	//LEFT OFF HERE DEC 14  !!
	//LEFT OFF HERE JAN 7 + cursor.value.id
	//THESE ARE TABLE ARRAYS..TO DISPLAY DATA IN TABLE..NOT USED FOR NOTES
	//ADDED SPACE AFTER > REMOVE IF MESSES UP!!!!!!!Jan24so in search use +2 instead of +1
	 tableTitle[counter - 1] = cursor.value.id + '> ' + cursor.value.title;//locomotive 
	  dateTable[counter-1] = cursor.value.created;//date record created
	  paraBody[counter-1] = cursor.value.body;//location
	  displayXtraFieldData[counter-1] = cursor.value.xtraField;//(decoder) maybe should just use newFieldName?
	  
	  console.log('In displayData, iterating through objectStoreName_os with cursor. tableTitle[' + Number(counter-1) +'] = ' + tableTitle[counter-1]);
	  //In displayData, iterating through notes_os with cursor. tableTitle[0] = CN3205..after deleting record
	  //In displayData, iterating through notes_os with cursor. tableTitle[2] = CN4700
	  //go to function to formulate contents% of paraBody[] to = everything up to a colon
	 settingTable(cursor,counter);
	
	  
	  }//end if cursor.value.id != 1
      // Put the data from the cursor inside the h3 and para
      h3.textContent = cursor.value.title;
if (viewDateWritten) {dateP.textContent = cursor.value.created;}	//end if viewDateWritten  
//para, displayXtraField are used in Notes…NOT the table!
      para.textContent = cursor.value.body;
	  secondDataH4.textContent = newFieldName;
	  displayXtraField.textContent = cursor.value.xtraField;
//para2.textContent = caches.keys();
      // Store the ID of the data item inside an attribute on the listItem, so we know
      // which item it corresponds to. This will be useful later when we want to delete items. Is data-note-id an attribute type like 'class', 'style' etc. specified in the IDB API?
      listItem.setAttribute('data-note-id', cursor.value.id);
	  
	  //this occurs everytime display data is run. the id comes from the note creation createIndex 'id' when the write to the object store is creared. setting the attribute in displayData gets the id from cursor.value.id. So putting it as an attribute saves having to run a cursor everytime you want to edit or delete a specific note.

      // Create a button and place it inside each listItem
	  //here you could add an edit button, and NotesEditBTN.onclick go to editItem function..(Doug D.)
      const deleteBtn = document.createElement('button');
      listItem.appendChild(deleteBtn);
      deleteBtn.textContent = 'Delete';

      // Set an event handler so that when the button is clicked, the deleteItem()
      // function is run
      deleteBtn.onclick = deleteItem;
	  
	  //set up Edit button Feb12 removed const as it is declared globally?
	const NotesEditBtn = document.createElement('button');
	//TypeError: Attempted to assign to readonly property. SO RETURNED CONST FEB12 2023
	// NotesEditBtn = document.createElement('button');
	  //make this a global variable because it is referenced in addField function ..WAIT,! This needs to be created for every note via cursor iteration so it needs to be here!!
      listItem.appendChild(NotesEditBtn);
      NotesEditBtn.textContent = 'Edit';
//was let noteNumber..now declared up top because variable not found error in if !listItem & setup===0
     noteNumber = listItem.getAttribute('data-note-id'); // Set an event handler so that when the button is clicked, the deleteItem()
      // function is run
	//NotesEditBtn.setAttribute('class','attentionBtn');//REMOVE  
//DATE FEB3 trying to flash edit btn in notes record	
	
  //if(newDBGuidance) {
	//  NotesEditBtn.setAttribute('class','attentionBtn');
	  //code to flash attentionBtn
	  
if(newDBGuidance) {
	 NotesEditBtn.setAttribute('class','attentionBtn');
	  //NotesEditBtn.setAttribute('class','borderBlinkGrn');
	  //code to flash attentionBtn
//changed above Feb12	RESET IN  NotesEditBtn.onclick 
//CAN'T GET THIS TO STOP FLASHING SO BEST TO LEAVE AS ATTENTIONBTN!
 // flashing = setInterval(flash, 1000);

// function flash () {
// 	var flashYellow = true;
//   if(flashYellow) {
// 	  NotesEditBtn.setAttribute('class','yellowOnly');
// 	  flashYellow = false;
//   } else {
// 	  NotesEditBtn.setAttribute('class','attentionBtn');
//   }//end if flashYellow
  
// }//end function flash
	  
	  
	    //code to flash attentionBtn
  }//end if newDBGuidance
   noteId = noteNumber;//added Sept20 2022..not sure this is necessary?
   
  //changed this code Feb12 
    NotesEditBtn.onclick = editItem;
  //  NotesEditBtn.onclick = editItem; 
    
    
    // NotesEditBtn.onclick = function (e,noteId) {
    // NotesEditBtn.setAttribute('class','tdEdit');
	//  editItem(e,noteId);   
    //  }//end NotesEditBtn.onclick = function ()
     
    //code below above causes error TypeError: undefined is not an object (evaluating 'e.target') line 4572
    
   // NotesEditBtn.onclick = function (e)  {
	//   fromSearchRecord = false;//to fix issue of retaining previous record id from a searched record edit
	//  // noteId = noteNumber;
	//    editItem();
   // }//end function NotesEditBtn.onclick =
   
	  //set up Full Note View button
	  
	  //clearTimeout(flashing);
	  
	  const fullViewBtn = document.createElement('button');
      listItem.appendChild(fullViewBtn);
      fullViewBtn.textContent = 'View Entire Note - Record ID: '+ noteNumber;

      // Set an event handler so that when the button is clicked, the deleteItem()
      // function is run
      fullViewBtn.onclick = fullViewItem;

      // Iterate to the next item in the cursor. use the IDBCursor.continue() method to advance the cursor to the next record in the datastore, and run the content of the if block again. If there is another record to iterate to, this causes it to be inserted into the page, and then continue() is run again, and so on.
	  
	  // const noteNumberP = document.createElement('button');
      // listItem.appendChild(noteNumberP);
      // noteNumberP.textContent = 'Record # :  '+noteNumber;
	  
	 // alert("noteNumber = " +noteNumber);
	  counter = counter + 1;
	/*  if (setup === 1 & noteNumber ===1) {
			list.removeChild(listItem);//remove the 1st note from view the li to the ul providedg setup is done. otherwise setup will keep repeating
		}//end if cursor.value.id===1 */
		
      cursor.continue();
	  //When there are no more records to iterate over, cursor will return undefined, and therefore the else block will run instead of the if block. This block checks whether any notes were inserted into the <ul> — if not, it inserts a message to say no note was stored.
	  //when starting afesh there is no cursor so code jumps to else statement..setup will still be =0
    } else {
      // Again, if list item is empty, display a 'No notes stored' message
      
      // if there are no more cursor items to iterate through, say so
//code below added to create first note as administration	
//my thinking: Here we are talking about the display screen, NOT the actual files in the database? because code above in displayData did not create the first note if cursor = 1 then here firstChild should be the second 'note' and if it does not exist then there are no notes entered yet in the database.
//ReferenceError: Can't find variable: noteNumber
//code below creates first record as admin record by going to addData to 'write the newItem set up as an admin record?'

//I DON'T THINK CODE BELOW WILL EXECUTE BECAUSE SETUP = 1 as there was a cursor because previous saveVariables call via getDataBaseName will have created the first admin record so else above just delivers code to bottom of disPlayData function
// if(!list.firstChild & setup ===0) {
//         const listItem = document.createElement('li');
//         listItem.textContent = 'This is noteNumber : ' + noteNumber + '. No notes stored. Setting up database. Create first note by tapping the Add Note button. You may also set settings for creating and naming the extra field, or do this at a later time. (Tap Preferences button, then Add Field. .... Added a note. Then preferences and add Field.. If extra field not set can’t keep data if added to extra field extra field must be set to 1 I.e. xtraField = 1)';
//         list.appendChild(listItem);
		
		
// 		//if no notes yet automatically create the first note for variables!!!!..otherwise error generated because data. is undefined in load and save operations
// 		//disable load and save until after the first note is created
// 		loadBtn.disabled = true;
// 		saveBtn.disabled = true;
// xtraField = 0;//was xtraField = 1 why?Date July 29 2020
// xtraFieldData = ' ';	
// newFieldName = " ";
// titleInput.value = xtraField;
// bodyInput.value = newFieldName;

// inputXtraFieldData.value = ' ';
// setup = 1;
// console.log('Now going to addData from the code that ran after the else statement because there was no cursor on initial set up. now setup = 1');

// 	addData();	//going to 218 error undefined evaluating e.preventDefault should I make setup = 1 here?
// ver = 2;//don't think I need to set ver = 2 because I came here via onupgradeneeded already? set it to 2 to force an onupgradeneeded
// console.log('..now back from addData and going to open dbx again. ver is set = 2. will go to displayData again? recursive???');
// let request = window.indexedDB.open('notes_dbx', ver); //seems to then go to start of code ? to onupgradeneeded??

// request.onsuccess = function() {
//   console.log('Database opened after addField successfully');
 
// db = request.result;
// //trying to prevent repeat display of records REMOVE IF MESSED UP!!!!! |
// while (list.firstChild) {
//     list.removeChild(list.firstChild);
// }
// //remove above if it messes up!
// displayData();
// };//end request.onsuccess handler function .. a success event has triggered the success callback; 

// request.onupgradeneeded = function(e) {

// let db = e.target.result;
// let objectStore = db.createObjectStore('notes_os', { keyPath: 'id', autoIncrement:true });
// objectStore.createIndex('title', 'title', { unique: false });
  
//   //addind date of note creation
//   objectStore.createIndex('created', 'created', { unique: false });
//   //end code for adding date created
//   objectStore.createIndex('body', 'body', { unique: false });
//   //CODE FOR xtraField basically substituting xtraField for body
//   if (xtraField===1) {
// 	  objectStore.createIndex('xtraField', 'xtraField', { unique: false });
//   }//end if xtraField
//   //createIndex() takes an optional options object that refines the 
//    //PLAN FOR XTRA FIELD: Create xtraField (body), xtraField (body). use if xtraField true create a string with first line fieldName rtn then data input from entry. version number will be set to 2 to trigger onupgradeneeded

//   console.log('Database setup after addField complete and onupgradeneeded');
//   //trying to prevent repeat display of records REMOVE IF MESSED UP!!!!! |
// while (list.firstChild) {
//     list.removeChild(list.firstChild);
// }
// //remove above if it messes up!
//   displayData();
// };//end request.onupgradeneeded handler

// console.log('Now going to saveVariables after addData');
// saveVariables;

// loadBtn.disabled = false;
// 		saveBtn.disabled = false;
// setup = 1;

// 	}//March29 end if not list first child and setup=0 so might remove this code which I did in notes-osFileNamesTableNotesVer21
	


	
	counter = counter-1;//number of visible records
//remove all code above if screw up
//after deleteItem, record deleted, the index key is not removed so an iteration of the cursor shows 4 records instead of 2
      console.log('Notes all displayed. Number of notes = ' + counter);
	  //should I add here tableTitle.length = counter to cut off extra element after a displayData() call at end of saveVariables which is called by deleteItem(delete record?...)
	  //to prevent error Apr 8
	  if (counter > 0){
	 tableTitle.length = counter;
	 paraBody.length = counter;
	 displayXtraFieldData.length = counter;
		 }//end if counter>0
	 console.log('At end of displayData()..tableTitle = ' + tableTitle + ' counter = ' + counter);
	 //CODE RUNS TO HERE AND STOPS BECAUSE MEANWHILE ANOTHER BRANCH OF CODE IS COMPLETING IN GETDATABASEName
	 //TypeError: undefined is not an object (evaluating 'data.variable2')line 3012
	  //because js is asynchronous does code re-iterate through here while at the same time deleteItem code is running, and has not yet deleted the designated record, so tableTitle[] ends up with a 0 in its last instance making tableTitle array length one more than it should be?? Note after saving tableArray following deletion of a record from 4 record list + admin record, tableArray[4][0] = 0. so table.length = 4 instead of 3? So this is why tableTitle.length = counter statement in experiment2TableNotesVer15.js fixes the problem that occurs if going back to table from a previous run of deleteItem code?
	  
	//  Left off here Dec 9
    }//end else
  };//end opencursor.onsuccess
  
  
  //AUG 25 make prefbtn green so user is directed to prefs after creating first record of new db
console.log("End display data .. at make pref btn green");
console.log("(In wanting to restore to status quo) (make pref btn green): newDBGuidance = " + newDBGuidance + " newDBflag = " + newDBflag + " xtraField = " + xtraField + "counter = " + counter);
//(In wanting to restore to status quo) (make pref btn green): newDBGuidance = undefined newDBflag = falsextraField = 0
if (newDBGuidance === undefined && !newDBflag && xtraField === 0 && counter === 0) {
addNoteBtn.setAttribute('class','normalBtn');
  addNoteBtn.disabled = true;
  settingsBtn.setAttribute('class', 'borderBlinkGrn');//preferences was attentionBtn
  prefBtnGreen = true;
}//end if (newDBGuidance === undefined && !newDBflag && xtraField === 0) {
	//make prefbtn green so user is directed to prefs after creating first record of db
	
//Aug25 restore status quo of preferences and add note btns after new db creation done Aug25
	
  if (!newDBGuidance && !newDBflag && xtraField === 1 && counter > 1) {
addNoteBtn.setAttribute('class','attentionBtn');
  addNoteBtn.disabled = false;
  settingsBtn.setAttribute('class', 'tdEdit');//preferences
}//end if (newDBGuidance === undefined && !newDBflag && xtraField === 0)
//restore statusbquo after finishing creating new db




console.log('At end of displayData: tableTitle = ' + tableTitle + '. tableTitle.length = ' + tableTitle.length);
 	
			console.log('after displayData, paraBody = '+ paraBody);
			console.log('after displayData, displayXtraFieldData = '+ displayXtraFieldData);
  //note originalNumberRecords is NOT set here.
  console.log("At end of display data. Is savedTablesArray intact ? savedTablesArray = " + savedTablesArray);
}//end displayData function
//At end of display data. Is savedTablesArray intact ? savedTablesArray = Doug Dyer,
//Contact Name , Feb 06 2022 00:20, ,username@shaw.ca,(250) 658-5645,addyer@telus.net,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

// Define the deleteItem() function
function deleteItem(e) {
	console.log('At function deleteItem');
	
//trying to fix fields getting messed up in displayTable if viewing main db table after viewing a new table Mar7
if(fromNewTable) {
resetFields = true;//flag used at reconstuction of displayTable
fromNewTable = false;
}//end if fromNewTable
	
	//fix loop hole of table screen getting messed up if user adds new note prior to first initialization of table
	if(DTBtnTappedOnce ===0 & tableExists){
		alert('The pre-existing main table has to be initialized first before deleting a note! Tap the DISPLAY TABLE button.');
		tableScreenOptions();
	}//end if if(DTBtnTappedOnce ===0 & tableExists)
	
//	deleteRecord = 1; //flag used in refreshTable()
//make delete window appear	!!!!
deleteWindow.setAttribute('class','showing');

  // retrieve the name of the task we want to delete. We retrieve the ID of the record to be deleted. We need
  // to convert it to a number before trying it use it with IDB; IDB key
  // values are type-sensitive. Recall that the ID of the record was saved in a data-note-id attribute on the <li> when it was first displayed. See this code line in display function....'listItem.setAttribute('data-note-id', cursor.value.id);'The <li> list item is the parentnode of the event (e) targetted item..the button. We do however need to pass the attribute through the global built-in Number() object as it is of datatype string, and therefore wouldn't be recognized by the database, which expects a number.
 
  let noteId = Number(e.target.parentNode.getAttribute('data-note-id'));

  // open a database transaction and delete the task, finding it using the id we retrieved above. First Activate the notes-os for readwrite actions.
  let transaction = db.transaction([objectStoreName], 'readwrite');
  //reference/put the activated 'notes-os' object store into the variable objectStore
  let objectStore = transaction.objectStore(objectStoreName);
 console.log('noteId = ' + noteId);
 let request = objectStore.get(noteId);
//var request = objectStore.get();
request.onerror = function(event) {
  // Handle errors!
  console.log("delete failed");
};//end request.onerror
request.onsuccess = function(event) {
	//original note in data variable
	var data = event.target.result;
	//create the tools for warning re delete
	console.log('Will delete item # ' + data.id + ' ' + data.body);
 
 const deleteBanner = document.querySelector('h2.deleteBan');
const textToBeDeletedP = document.querySelector('#deleteTxt');
const deleteInputP = document.querySelector('p.deleteInstruction');
const deleteTableBanner = document.createElement('p');
const deleteTableRecordBtn =  document.createElement('button');
const deleteNotice = document.createElement('p');

//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	deleteWindow.style.backgroundColor = "black";
	deleteWindow.style.color = "white";
	textToBeDeletedP.style.color = "black";
} else {
	deleteWindow.style.backgroundColor = "#eee";
	deleteWindow.style.color = "black";
}//end if else screenDark


 deleteBanner.textContent = 'Delete the Existing Record with Title:' + '  ' + data.title;
textToBeDeletedP.textContent = data.body;
deleteInputP.textContent = 'Tap the OK DELETE button to erase this record. Tap CANCEL to escape.';
 
 deleteButton = document.querySelector('#okDelete');
 deleteButton.setAttribute('class','attentionBtn');
 cancelDelBtn = document.querySelector('#cancelDelete');
 alert('Scroll up or down if data is not on screen!');
 deleteWindow.setAttribute('class','showing');
 
if (tableExists) {
 deleteWindow.appendChild(deleteTableBanner);
 deleteWindow.appendChild(deleteTableRecordBtn);
 // const deleteTableBanner = document.createElement('p');
		 deleteTableBanner.setAttribute('class','simulator');
		 deleteTableBanner.textContent = 'First delete the record from the Notes!';
		 // // const deleteTableRecordBtn =  document.createElement('button');
		 deleteTableRecordBtn.textContent = 'Delete from Table';
		 deleteTableRecordBtn.setAttribute('class','normalBtn');
		 deleteTableRecordBtn.disabled = true;
		// deleteWindow.appendChild(deleteTableBanner);
		// deleteWindow.appendChild(deleteTableRecordBtn);
 
 
}//end if tableExist
 
 cancelDelBtn.onclick = function () {
	deleteWindow.removeChild(deleteTableBanner);
	deleteWindow.removeChild(deleteTableRecordBtn);
	deleteWindow.setAttribute('class','hidden');
	};//end cancelDelBtn.onclick
	
	
 deleteButton.onclick = function () {
	// editNote=true;//flag insures that you update table before leaving for another database Dec21//this causes a table refresh after deleting record which messes up reappearance of displayData() so I removed this line Mar8 2022
	
	 deleteTableBanner.textContent = 'Now delete the record from the Table!';
	 deleteButton.setAttribute('class','normalBtn');
	 
	 //reactivate the transaction
	 counter = counter - 1;
	 let transaction = db.transaction([objectStoreName], 'readwrite');
  //reference/put the activated 'notes-os' object store into the variable objectStore
  let objectStore = transaction.objectStore(objectStoreName);
  //create a request to delete the object store identified with noteId.
	 
	 let request = objectStore.delete(noteId);
	 //Methods returning IDBResult (range may be used instead of key where applicable):delete(key) – remove entries, clear() – removes all entries 
	 //Methods working with indexes: ? use for removing and adding Fields in a database?

/*parameters – object may set unique or multiEntry true

idx = index(name), deleteIndex(name)

idx = createIndex(name, keyPath[, parameters])
*/
  // report that the data item has been deleted
  transaction.oncomplete = function() {
	  deleteNotice.textContent = 'Note ' + noteId + ' deleted.';
   deleteWindow.appendChild(deleteNotice); e.target.parentNode.parentNode.removeChild(e.target.parentNode);
    console.log('Note ' + noteId + ' deleted.');
//add code here to put record deleted on screen
    // Again, if list item is empty, display a 'No notes stored' message
    if(!list.firstChild) {
      let listItem = document.createElement('li');
      listItem.textContent = 'No notes stored.';
      list.appendChild(listItem);
  }	
	
  if (tableExists) {
	  deleteTableRecordBtn.setAttribute('class','attentionBtn');
	  deleteTableRecordBtn.disabled = false;
		 // const deleteTableBanner = document.createElement('p');
		 // deleteTableBanner.setAttribute('class','simulator');
		 // deleteTableBanner.textContent = 'Do you wish to also delete record from the Table?';
		 // // const deleteTableRecordBtn =  document.createElement('button');
		 // deleteTableRecordBtn.textContent = 'Delete from Table';
		// deleteWindow.appendChild(deleteTableBanner);
		// deleteWindow.appendChild(deleteTableRecordBtn);
		deleteTableRecordBtn.onclick = function () {
			console.log('Before displayData...tableTitle[] = ' + tableTitle);
			deleteTableRecordBtn.setAttribute('class','normalBtn');
			deleteTableRecord = 1;//flag used to try and fix tableArray by preventing concurrent running of displayData
			
		//	LEFT OFF HERE DEC 12
			
		tableConstructed = 0;	//deleteWindow.setAttribute('class','hidden');
		//added Dec 10
	//	deleteTableRecord = 1;//to prevent displayData running again from saveVariables in aid of avoiding a repeat last element after a deleted table record
		
		//may not need to set refreshed=1 here as I am no longer going to refreshTable() from this code!!! Dec 7 .. so maybe should REMOVE??
		refreshed = 1;//to prevent repeat of field headers in refreshTable() Dec6
		//should I REMOVE above?
		//also if going back to notes screen, then returning to TABLE, you have added a new record sinCe last creation of table appears because originalNumberRecords variable has changed (-1) ..so look at code to fix!!!!Dec 7
		
		console.log('noteId = ' + noteId);
		//var a = fruits.indexOf("Apple");
		//let arrayIndex = Number(noteId-2);
		//need to do indexOf because notesID keePs increasing as records are dealTed because in js the record keys are not deleted, just kept and new ones added.
		//create complete target title to match to identify record to delete
		//added space after > for correct compareJan 25
		let targetTitle = data.id + '> ' + data.title;
		console.log('targetTitle = ' + targetTitle);
		let arrayIndex = tableTitle.indexOf(targetTitle);
		//data.title = CN4700
		//console.log('noteId -2 arrayIndex = ' + arrayIndex);
		console.log('data.title = ' + data.title);
		console.log('arrayIndex = ' + arrayIndex);
		//arrayIndex = -1
		
		console.log('tableTitle[arrayIndex] = ' + tableTitle[arrayIndex]);
		
	//	let removedArrayElement = tableTitle.splice(arrayIndex, 1);
	//	console.log('removedArrayElement = ' + removedArrayElement);
	
//if removing tableTitle[0] before removedTableRecordElements, I =think this causes a blank entry in the tableArray, so let’s not remove tableTitle[0] and just remove the whole record, then set originalNumber Records to tableTitle.length see experiment2TableNotesVer15.js

//from stack overflow
let removedRecord = tableArray.splice(arrayIndex,1);
console.log('removedRecord = ' + removedRecord);
//removedRecord = 
console.log('tableArray = ' + tableArray);

//tableArray = 2>CN3205, Jan 08 2021 16:56,Yard3 Track 2,Econami PNP  ,5,128,255,3>CN4800, Jan 08 2021 16:59,Yard3 Track12 ,Tsunami2 TSU-1100,15,128,255,4>CN4700, Jan 08 2021 17:00,Yard2 Roundhouse Track 2,TSUNAMI2 TSU-1100,77,130,190,5>CN5502, Jan 08 2021 17:01,Ogden Point Yard Track 4,NCE DW13SR ,10,20,30,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,


//ADDED DEC 13 2020
tableArray.length = counter;
//CODE TO REBUILD tableArray after deleting record


// let removedRecordFields = Number(numberOfFields);
// 		let removedTableRecordElements = tableArray[arrayIndex].splice(0,removedRecordFields);


// 		console.log('removedTableRecordElements = ' + removedTableRecordElements);
	//if removedArrayElement tableTitle not done then tableTitle.length remains unchanged! Dec 6	
		let removedArrayElementparaBody = paraBody.splice(arrayIndex, 1);
		//removedArrayElementparaBody = Ogden Point Yard Track 4
		console.log('removedArrayElementparaBody = ' + removedArrayElementparaBody);
		
		let removedArrayElement = tableTitle.splice(arrayIndex, 1);
		console.log('removedArrayElement = ' + removedArrayElement);
	//removedArrayElement = 5>CN5502
		
		let removedArrayElementdisplayXtraFieldData = displayXtraFieldData.splice(arrayIndex, 1);
		console.log('removedArrayElementdisplayXtraFieldData = ' + removedArrayElementdisplayXtraFieldData);
		//removedArrayElementdisplayXtraFieldData = NCE DW13SR 
		
		
		console.log('tableTitle array now = ' + tableTitle);
		//tableTitle array now = 2>CN3205,3>CN4800,4>CN4700
		
		console.log('tableTitle.length = ' + tableTitle.length);
		//tableTitle.length = 3 essentially it removed the last element because arrayIndex was -1
		originalNumberRecords = tableTitle.length;//update record number so table  redisplays correctly in buildRecordRows
		//save changes to variables, in particular originalNumberRecords so a re-run will show the proper number of records? originalNumberRecords is initially set to tableTitle.length in newBtn.onclick, and in refreshTable after a table reconstruct post adding a new record, and in deleteItem, and is saved as a variable so it loads in with getDataBaseName(). It is compared with tableTitle.length to determine if table needs updating after adding a record
		saveVariables();
	//	deleteTableRecord = 0;
		//saveVariables goes to displayData and so maybe you are doing this twice??!!!!!!BUT IT STILL SEEMS TO WORK IF GOING BACK TO NOTES AND RETURNING TO TABLE AND VICE VERSA.????
		 //Dec 11 2020:because js is asynchronous does code re-iterate through here while at the same time deleteItem code is running, and has not yet deleted the designated record, so tableTitle[] ends up with a 0 in its last instance making tableTitle array length one more than it should be?? Note after saving tableArray following deletion of a record from 4 record list + admin record, tableArray[4][0] = 0. so table.length = 4 instead of 3? So this is why tableTitle.length = counter statement in experiment2TableNotesVer15.js fixes the problem that occurs if going back to table from a previous run of deleteItem code?
	//	Left off here Dec 10 see line 2185.. in saveVariables
		//tableTitle[noteId] = '' ;
		tableArray.length = counter;//ADDED DEC13
			displayData();
			console.log('after displayData, tableTitle = '+ tableTitle);
			console.log('after displayData, paraBody = '+ paraBody);
			console.log('after displayData, displayXtraFieldData = '+ displayXtraFieldData);
			deleteWindow.setAttribute('class','showing');
			
			//reset copyOfTableArray fixes reset!Mar15
copyOfTableArray = tableArray.slice(0,tableTitle.length);
copyOfTableTitle = tableTitle.slice();
console.log('copyOfTableArray = ' + copyOfTableArray);
console.log('copyOfTableTitle = ' + copyOfTableTitle);

// update copy to reflect new originalMar 15 not tested!			
			
				//reset copyOfTableArray
			
			clearTableRows();
		//	refreshTable();
//instead of going to refreshTable go to displayTable so tableArray is not messed up by redefineTableArray in buildRecordRows
addFieldHeaders();
	displayTable();//Dec 6
	//go to refreshTable but use deleteRecord flag to avoid buildRecordRows

deleteWindow.removeChild(deleteTableBanner);
	deleteWindow.removeChild(deleteTableRecordBtn);
	deleteWindow.removeChild(deleteNotice);
//deleteWindow.removeChild(deleteNotice); why had I taken this out?? Mar15?

deleteWindow.setAttribute('class','hidden');
//left off here Dec 7
			//tableScreen.setAttribute('class','showing');
			
		}//end deleteTableRecordBtn.onclick
		
	}//end if tableExists
	
	//now hide delete window again
	
};//end transaction.oncomplete
};//end deleteButton.onclick function
 
};//end of request.onsuccess
  //create a request to delete the object store identified with noteId.
//deleteWindow.setAttribute('class','hidden');
//displayData();//MAR8 REMOVE IF MESSED UP
//editNote = false;//this flag causes a refresh update table if true and not needed here after a delete record..it messes uo reappearance of displayData!
deleteRecord = 0; //flag used in refreshTable() SHOULD THIS BE MOVED ABOVE TO COPYOFTABLEARRAY. CODE DOESN'T GET HERE
// copyOfTableArray = tableArray.slice(0,tableTitle.length);
// copyOfTableTitle = tableTitle.slice();
// console.log('copyOfTableArray = ' + copyOfTableArray);
// console.log('copyOfTableTitle = ' + copyOfTableTitle);

// update copy to reflect new originalMar 15 not tested!
}//end of deleteItem function

//show full item view function
// Define the fullViewItem() function
function fullViewItem(e) {
//make full view window appear	!!!!
displayFullNote.setAttribute('class','showing');
const editFromSearchBtn = document.querySelector('#editFromSearch');
editFromSearchBtn.style.display = 'none';
//TypeError: undefined is not an object (evaluating 'e.target')
  
//Sept20 2021: tableTittle label #> probably represents original note-id when first creted. searchNote from search function represents the i array index of the current tableArray. If there have been record deletions these two numbers might be different because indexedDB does not delete the id number when creating a new record but instead just creates a new one incremented from the original id list. Might this become a source of error in retriving the full view note from search????? fullViewBtn.textContent = 'View Entire Note - Record#: '+ noteNumber; noteNumber is derived from note-data-id when item is created..se displayData()…listItem.setAttribute('data-note-id', cursor.value.id);
if (fromSearchRecord) {
	noteId = Number(searchNote);
	editFromSearchBtn.style.display = 'unset';
	fromSearchRecord = false;
	}//end if fromSearching
		else {
			noteId = Number(e.target.parentNode.getAttribute('data-note-id'));
		}//end if from searching
		
  // open a database transaction and delete the task, finding it using the id we retrieved above. First Activate the notes-os for readwrite actions.
  let transaction = db.transaction([objectStoreName], 'readwrite');
  //reference/put the activated 'notes-os' object store into the variable objectStore
  let objectStore = transaction.objectStore(objectStoreName);
 
 let request = objectStore.get(noteId);
//var request = objectStore.get();
request.onerror = function(event) {
  // Handle errors!
  console.log("delete failed");
};//end request.onerror
request.onsuccess = function(event) {
	//original note in data variable
	var data = event.target.result;
	//create the tools for warning re delete
	//TypeError: undefined is not an object (evaluating 'data.id')
console.log('Will display item # ' + data.id + ' ' + data.body);
 
 const fullViewBanner = document.querySelector('h2.fullView');
const textToBeCompletelyViewed = document.querySelector('#fullTxt');
const finishedReading = document.querySelector('#finishedReading');
const fullViewP = document.querySelector('p.fullViewInstruction'); //removed this because button off screen if note title >3 lines
//const editFromSearchBtn = document.querySelector('#editFromSearch');
//editFromSearchBtn.style.display = 'none';
//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	displayFullNote.style.backgroundColor = "black";
	displayFullNote.style.color = "white";
	textToBeCompletelyViewed.style.color = "black";//txt gets changed to white in dark mode whih does not show on yellow background of full view text
} else {
	displayFullNote.style.backgroundColor = "#eee";
	displayFullNote.style.color = "black";
}//end if else screenDark
textToBeCompletelyViewed.textContent = data.body;

//textToBeCompletelyViewed.addEventListener('click', function () { doesn't work after a repeat view so had to use an .onclick event!
	
	textToBeCompletelyViewed.onclick = function () {
	if (!toggley) {
		toggley = true;
		textToBeCompletelyViewed.textContent = data.xtraField;
	} else if (toggley) {
		toggley = false;
		textToBeCompletelyViewed.textContent = data.body;
	}//end else if toggllex
};//end function textToBeCompletelyViewed.onclick


if(xtraField === 0) {
	fullViewBanner.textContent = 'Complete view of the Existing Record with Title:' + '  ' + data.title;
} else if (xtraField === 1) {
 fullViewBanner.textContent = 'Complete view of the Existing Record with Title:' + '  ' + data.title ;
 fullViewP.textContent = ' Tap window to see contents of extra Field named: ' + newFieldName;
}//end else if

 finishedReading.setAttribute('class', 'showing');
//textToBeCompletelyViewed.textContent = data.body;
//fullViewP.textContent = 'Tap the OK RETURN button after viewing this record.';
 
 
doneReadingButton = document.querySelector('#okReturn');
goToSearchBtn = document.querySelector('#goToSearch');
// editFromSearchBtn = document.querySelector('#editFromSearch');
 
 editFromSearchBtn.onclick = function () {
 fromSearchRecord = true;
 editFromSearchBtn.style.display = 'none';
 displayFullNote.setAttribute('class','hidden');
 editItem(e,noteId);
 }
 doneReadingButton.onclick = function () {
	toggley = false;//so on return to fullView function there is no 'stall' on viewing after tap
	//textToBeCompletelyViewed.textContent = "";
	finishedReading.setAttribute('class','hidden'); displayFullNote.setAttribute('class','hidden');
	};//end doneReadingButton.onclick
	
goToSearchBtn.onclick = function() {
	if(DTBtnTappedOnce ===0 & tableExists){initializeTable();}
	
	//fix loop hole of table screen getting messed up if user adds new note prior to first initialization of table
	// if(DTBtnTappedOnce ===0 & tableExists){
	// 	alert('The pre-existing table has to be initialized first before searching a record! Tap the DISPLAY TABLE button.');
	// 	tableScreenOptions();
	// }//end if if(DTBtnTappedOnce ===0 & tableExists)
	
//in aid of preventing repeat registering of addEventListener in searchRecords() REMOVE IF MESSES UP,!!Jan22 2021

searchWindow.setAttribute('class','showing');
//Check if screenDark mode..don't need this here because already happens in searchRecords()
// checkScreenMode();
// if(screenDark) {
// 	searchWindow.style.backgroundColor = "black";
// 	searchWindow.style.color = "white";
// } else {
// 	searchWindow.style.backgroundColor = "#eee";
// 	searchWindow.style.color = "black";
// }//end if else screenDark
	//pre-load search record input field with current full view record
	// searchTitleInput.value = "";
	console.log('data.title = ' + data.title);
	searchTitleInput.value = data.title;
	// console.log('searchTitleInput.value' = searchTitleInput.value);
	
finishedReading.setAttribute('class','hidden'); displayFullNote.setAttribute('class','hidden');
	searchRecords();//to help asthetics of search screen..extra p element won't appear otherwise
};//end function goToSearchBtn.onclick


//adding capability to EDIT note from searched item vv

//editFromSearchBtn.onclick = editItem;

//adding capability to EDIT note from searched item ^^

//might this Alert be cause of program hang up when viewing complete note???
	//alert('Scroll up or down if RETURN TO NOTES Button is not on screen! (Move scroll bar on right to bottom of screen.)');

};//end of request.onsuccess
  // a request to view the object store identified with noteId.

}//end of fullItemView function

//view settings window (the first note)
function viewSettings(e) {
	aboutDBWindow.setAttribute('class','hidden');
//make full view window appear	!!!!
settingsScreen.setAttribute('class','showing');

  // retrieve the name of the task we want to view. We retrieve the ID of the record to be viewed. We need
  // to convert it to a number before trying it use it with IDB; IDB key
  // values are type-sensitive. Recall that the ID of the record was saved in a data-note-id attribute on the <li> when it was first displayed. See this code line in display function....'listItem.setAttribute('data-note-id', cursor.value.id);'The <li> list item is the parentnode of the event (e) targetted item..the button. We do however need to pass the attribute through the global built-in Number() object as it is of datatype string, and therefore wouldn't be recognized by the database, which expects a number.
 // let noteId = Number(e.target.parentNode.getAttribute('data-note-id'));
let noteId = 1;
  // open ai database transaction and delete the task, finding it using the id we retrieved above. First Activate the notes-os for readwrite actions.
  
  //InvalidStateError: Failed to execute 'transaction' on 'IDBDatabase': The database connection is closing.BECAUSE I USED THE SAME db variable in delete code
  let transaction = db.transaction([objectStoreName], 'readwrite');
  //reference/put the activated 'notes-os' object store into the variable objectStore
  let objectStore = transaction.objectStore(objectStoreName);
 
 let request = objectStore.get(noteId);
//var request = objectStore.get();
request.onerror = function(event) {
  // Handle errors!
  console.log("view Settings failed");
};//end request.onerror
request.onsuccess = function(event) {
	//original note in data variable
	//to prevent reload of program wii an e.prevent.default propacation work here
	var data = event.target.result;
	//create the tools for warning re delete
	console.log('Will display settings screen item # ' + data.id + ' ' + data.body);
 
 const viewSettingsBanner = document.querySelector('h2.viewSettings');
 const settingsScreenHeader = document.querySelector('#settingsScreenHeader');
 // const dbNameInfo = document.createElement('p'); made global
 
const variablesViewed = document.querySelector('#variables');
const theListHeading = document.querySelector('#theListHeading');

const theList = document.querySelector('#theList');

const finishedReadingSettings = document.querySelector('#finishedReadingSettings');

//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	settingsScreen.style.backgroundColor = "black";
	settingsScreen.style.color = "white";
	
	variablesViewed.style.color = "black";
	//settingsScreenHeader.style.color = "white";
	viewSettingsBanner.style.color = "white";
	//viewSettingsBanner and settingsScreenHeader are the same!!!!Dec22
	dbNameInfo.style.color = "black";
} else {
	settingsScreen.style.backgroundColor = "#eee";
	settingsScreen.style.color = "black";
	viewSettingsBanner.style.color = "black";
	dbNameInfo.style.color = "black";
}//end if else screenDark


//references below for new code to list variables

let cvString1 = 'xtraField: = '+ xtraField;
let cvString2 = 'Extra Field Label: = ' + newFieldName;
let cvString3 = 'Database Table Name is: '+ dbTableName.value;//this is actually also the title heading in notes data display h2 section notesdisplay (html)
let cvString4 = 'Database setup completed? = '+ setup;
let cvString5 = '';
if (DTBtnTappedOnce ===0) {
	cvString5 = "The table is NOT currently INITIALIZED."; 
} else if (DTBtnTappedOnce ===1) {
	cvString5 = 'The Table is INITIALIZED.';
}//end if DTBtnTappedOnce
let cvString6 = 'Internal database Filename is  = '+ dbName;
let cvString7 = "";
if(setup === 3) {
	cvString7 = "The Preferences Settings have been SAVED for this database.";
} else if (setup === 1) {
	cvString7 = "The Preference Settings have NOT been Saved for this database."
}//end if setup = 3
let cvArray = [cvString1,cvString2,cvString3,cvString4,cvString5,cvString6,cvString7];
let cvItem = document.createElement('li');

//above for new code to list variables
//const fullViewP = document.querySelector('p.fullViewInstruction'); removed this because button off screen if note title >3 lines

 // viewSettingsBanner.textContent = 'The Settings screen reveals the values of variables as currently set in database: ' + dbName;
  viewSettingsBanner.textContent = 'The Settings screen reveals the values of variables as currently set in database: ';
  // dbNameInfo.setAttribute('class','titleBanner'); made global
  
  dbNameInfo.textContent = dbName;
  viewSettingsBanner.appendChild(dbNameInfo);
 //trying to get title light pink
/* let pinkTitle = document.createElement('p.yellowonly');
 
 document.fullViewBanner.appendChild(pinkTitle);
 */
 finishedReadingSettings.setAttribute('class', 'showing');
  variablesViewed.textContent = 'The  extraField is enabled if the xtraField variable is set to 1 and not enabled if set to 0. Value of xtraField variable = ' + xtraField +'. ' + 'The previous label of the Extra Field =  ' + data.body + '.   The current label is ' + newFieldName + '. This Database Table is named = ' + dbTableName.value + '.The database setup is completed if setup = 1 and not done if = 0. If the setup variable is set to 3, this means that the preferences settings have been saved for this individual database. setup = ' + setup + 
	'. A table has been created if = 1. The database was created/last modified on : ' + data.created + '.';
	console.log('data.created = ' + data.created) ;
//fullViewP.textContent = 'Tap the OK RETURN button after viewing this record.';
 //the variable list
 
//re-writing code for listing variables. the original is marked off with /**/so it can be restored if needed


for(let i = 0; i < numberOfCVtoList; i++) {
	cvItem = document.createElement('li');
 	cvItem.textContent = cvArray[i];
	cvValues.appendChild(cvItem);
	
}//end of for loop

 
doneSettingsButton = document.querySelector('#okSettingsViewed');

 
 doneSettingsButton.onclick = function () {
	//clear cv list in case running again
	while (cvValues.firstChild) {
    cvValues.removeChild(cvValues.firstChild);
}//end while*/
	finishedReadingSettings.setAttribute('class','hidden');
	settingsScreen.setAttribute('class','hidden');
	aboutDBWindow.setAttribute('class','showing');
	};//end doneSettingsButton.onclick

	alert('Scroll up or down if RETURN TO NOTES Button is not on screen! (Move scroll bar on right to bottom of screen.)');

//remove up to here


};//end of request.onsuccess
  // a request to view the object store identified with noteId.

}//end of viewSettings function

//the editItem function could look something like this
//define the editItem function
//you should combine the clear and the write into a single transaction

function editItem(e,noteId) {
NotesEditBtn.setAttribute('class','tdEdit');//set to flashing in createNewDB added Feb12 2023
//trying to fix fields getting messed up in displayTable if viewing main db table after viewing a new table Mar7
//noteId = Number(e.target.parentNode.getAttribute('data-note-id'));
//alert("noteId =  " + noteId);
// recordId = noteId ;
// scrollHere = true;
if(fromNewTable) {
resetFields = true;//flag used at reconstuction of displayTable
fromNewTable = false;
}//end if fromNewTable

		if (newDBGuidance) {
		//clearInterval(flashing);	
		
		NotesEditBtn.setAttribute('class','tdEdit');//this does not seem to work? in. ReateNewDB? Not sure why?
		//turn off blinking border of displayDataBtn
		displayDataBtn.setAttribute('class','borderBlink');
	}//end if newDBGuidance reset edit btn after create new db css button, .tdEdit
	console.log('In editItem. xtraFieldBtnExists (not yet) = ' + xtraFieldBtnExists);
		NotesEditBtn.setAttribute('class','tdEdit');
	//make edit window appear
	editWindow.setAttribute('class','showing');
	
	//trying to fix field header display going awry if edit notes before table initiated July 26 2021
	if(DTBtnTappedOnce ===0 & tableExists){initializeTable();}
	//trying to fix field header display going awry if edit notes before table initiated	
	
	//from updating an entry in the database
//if(!fromSearchRecord) {
//TypeError: undefined is not an object (evaluating 'e.target')
//SyntaxError: Cannot declare a let variable twice: 'noteId'.

//code below added Sept 20 2022 to fix edit from search vrs edit from display data issue.
if(!fromSearchRecord) {
noteId = Number(e.target.parentNode.getAttribute('data-note-id'));	
// alert("noteId =  " + noteId)
recordId = noteId ;
scrollHere = true;
scrollBtn.textContent = "Scroll to Last EDIT";
 }//end if(!fromSearchRecord) {

if (fromSearchRecord) {
noteId = Number(searchNote);
    fromSearchRecord = false;
//	alert('fromSearchRecord - noteId = ' + noteId + " fromSearchRecord variable = " + fromSearchRecord);
recordId = noteId ;
scrollHere = true;
scrollBtn.textContent = "Scroll to Last EDIT";
	}//end if (fromSearchRecord)



  // open a database transaction and delete the task, finding it using the id we retrieved above. First Activate the notes-os for readwrite actions.
  let transaction = db.transaction([objectStoreName], 'readwrite');
  //reference/put the activated 'notes-os' object store into the variable objectStore
  let objectStore = transaction.objectStore(objectStoreName);
  //create a request to get the object store identified with noteId.
  let request = objectStore.get(noteId);
//var request = objectStore.get();
request.onerror = function(event) {
  // Handle errors!
  console.log("edit failed");
};
request.onsuccess = function(event) {
	//original note in data variable
	var data = event.target.result;
	//create the tools for doing the edit
	//TypeError: undefined is not an object (evaluating 'data.id')
	//console.log('Will edit item # ' + data.id + ' ' + data.body);
	//reference editTitle input this works even if spelled Tile??!!!?why?
	const editTitle = document.querySelector('#editTitle');
	const editInput = document.querySelector('#changes');
	//put input element visible on screen
	//first clear screen
	//  while (list.firstChild) {
    //list.removeChild(list.firstChild);
//}//end while statement


/*main.removeChild(main.firstChild);
console.log('cleared note display'); */
//put input on screen
const editBanner = document.querySelector('h2.edBan');
const originalBodyTextP = document.querySelector('#originalTxt')
const editInputP = document.querySelector('p.editInstruction');
//const enterButton = document.querySelector('#submit');//make scope wider ..variable not found
/*record.appendChild(editBanner);
record.appendChild(originalBodyTextP);
record.appendChild(editInputP);
record.appendChild(editInput); */
//set up edit for extra field
//const xtraFieldBtn = document.createElement('button');//make this a global variable? Mar7
//references for edit newField
const editNewFieldBanner = document.querySelector('h2.edNewFieldBan');
const originalNewFieldTextP = document.querySelector('#originalNewFieldTxt')
const editNewFieldInputP = document.querySelector('p.editNewFieldInstruction');
const previewNewFieldBtn = document.querySelector('#previewNewField');
 //Check if screenDark mode
checkScreenMode();
if(screenDark) {
	editWindow.style.backgroundColor = "black";
	editWindow.style.color = "white";
	originalBodyTextP.style.color = "black";//not needed for light mode
} else {
	editWindow.style.backgroundColor = "#eee";
	editWindow.style.color = "black";
}//end if else screenDark


// Set an event handler so that when the button is clicked, the editXtraField() is run
// only set this up if xtraField === 1;
if (xtraField === 1) {
	
	//to fix accumulating xtraFieldBtn this DID NOT WORK? Maybe because transaction closed?
	// if (!xtraFieldButton) {
	// 	editWindow.appendChild(xtraFieldBtn);
	// 	xtraFieldButton = true;
	// }//end if xtraFieldButton
	// //to fix accumulating xtraFieldBtn
    editWindow.appendChild(xtraFieldBtn);
      xtraFieldBtn.textContent = 'Edit field: ' + newFieldName;
//fixing bug
	xtraFieldBtnExists = true;
	
	//flash xtraFieldBtn if createNewDB
	if (newDBGuidance) {
		xtraFieldBtn.setAttribute('class','borderBlink');
		//xtraFieldBtn.click();//added Feb12 for auto .click
	} else {
		xtraFieldBtn.setAttribute('class','tdEdit');
	}//end if newDBGuidance
	
	console.log('In editItem. Start, if xtraField=1.. xtraFieldBtnExists (true) = ' + xtraFieldBtnExists);
      
      xtraFieldBtn.onclick = editFieldWindow;
  }//end if xtraField === 1

editBanner.textContent = 'Edit the Existing Record with Title:' + '  ' + data.title;
originalBodyTextP.textContent = data.body;
editInputP.textContent = 'Type changes into the Input Window below.';
 // alert('');
 
//to keep title unchanged I probably need to set value of editTitle.value = data.title Same for body text.
editTitle.value = data.title;//fix reference to editTitle const
editInput.value = data.body;
if (newDBGuidance) {
xtraFieldBtn.click();//added Feb12 for auto .click
//edit xtraField code here
}//end if (newDBGuidance) {

function editFieldWindow () {
	console.log('in edit fieldWindow function');
	console.log('In editFieldWindow. xtraFieldBtnExists = ' + xtraFieldBtnExists);
	const editNewFieldWindow = document.querySelector('#editNewFieldWin');
	const editNewFieldInput = document.querySelector('#editNewFieldChanges');
	//editXtraField window set class 'showing'
	//make editXtraField window appear
	//make edit window appear
//remove the editXtraFieldBtn otherwise it accumulates!
//fix xtraFieldBtn bug
if (xtraFieldBtnExists) {
	editWindow.removeChild(xtraFieldBtn);
	xtraFieldBtnExists = false;
	console.log('In if xtraFieldBtnExists. Removed xtraFieldBtn. xtraFieldBtnExists = ' + xtraFieldBtnExists);
}//end if xtraFieldBtn
//end fix xtraFieldBtn bug

//editWindow.removeChild(xtraFieldBtn);
editNewFieldWindow.setAttribute('class','showing');
//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	editNewFieldWindow.style.backgroundColor = "black";
	editNewFieldWindow.style.color = "white";
	originalNewFieldTextP.style.color = "black";//not needed for light mode
} else {
	editNewFieldWindow.style.backgroundColor = "#eee";
	editNewFieldWindow.style.color = "black";
}//end if else screenDark

	
	editNewFieldBanner.textContent = 'Edit the Current Data of the ' + newFieldName + ' Field.';
originalNewFieldTextP.textContent = data.xtraField;

//LEFT OFF HERE!!!!!!
editNewFieldInputP.textContent = 'Type changes into the Input Window below.';
//alert("Type changes into the Input Window—data.xtraField = " + data.xtraField);
//ADDED mar15 remove if messes up
if (newDBGuidance && data.xtraField === "" || newDBGuidance && data.xtraField === null || newDBGuidance && data.xtraField === undefined) {
editNewFieldInput.value = "TAP HERE TO ENTER DATA.";
} else {
	editNewFieldInput.value = data.xtraField;
}//END if (newDBGuidance && data.xtraField === "")
//ADDED mar15 remove if messes up and uncomment editNewFieldInput.value = data.xtraField;
	
//editNewFieldInput.value = data.xtraField;	

commitButton = document.querySelector('#commit');
// commitButton.setAttribute('class','borderBlink');
editNewFieldInput.onfocus = function () {commitButton.setAttribute('class','borderBlink');}//end editNewFieldInput.onchange

clearEditNewFieldBtn = document.querySelector('#clearEditNewField');

cancelCommitBtn = document.querySelector('#cancelCommit');
 // enterButton.addEventListener('click', makeChanges); Use button.onclick because the eventListener registers all clicks and causes makeChanges to re-iterate twice or more?
 
 //cancel disabled if if (newDBGuidance) {
	 
	 if (newDBGuidance) {
		 cancelCommitBtn.disabled = true;
		 cancelCommitBtn.textContent = "Cancel disabled"
	} else {
		cancelCommitBtn.disabled = false;
		cancelCommitBtn.textContent = "Cancel";
	}//end if (newDBGuidance) {cancel disabled
 
 //Show edits in top window as you go
  //Show edits in top window as you go
  previewNewFieldBtn.onclick = function () {
 originalNewFieldTextP.textContent = editNewFieldInput.value;
 	}//end function previewNewFieldBtn.onclick
 //REMOVE ABOVE IF MESSED UP NOV14
 
  commitButton.onclick = function () {
  NotesEditBtn.setAttribute('class','tdEdit');
	 commitButton.setAttribute('class','tdEdit'); 
	  if (newDBGuidance) {
		//clearInterval(flashing);	
		NotesEditBtn.setAttribute('class','tdEdit');//this does not seem to work? in. ReateNewDB? Not sure why?
		//saveBtn.setAttribute('class','borderBlink');
		//Feb12 removed line above because don't want SAVE btn flashing when .click() has triggered it. … just asthetics!RESTORED IN TRYING TO BACKTRACK TO CORRECT GLITCH IN PROCESS
		enterButton.setAttribute('class','borderBlink');
			
	}//end if newDBGuidance reset edit btn after create new db css button, .tdEdit
	
	  console.log('commitButton pressed. editNewFieldInput.value = ' + editNewFieldInput.value);
	  
	 data.xtraField = editNewFieldInput.value;
//	editWindow.removeChild(xtraFieldBtn); 
console.log('data.xtraField = ' + data.xtraField);
//fix xtraFieldBtn bug
if (xtraFieldBtnExists) {
	editWindow.removeChild(xtraFieldBtn);
	xtraFieldBtnExists = false;
}//end if xtraFieldBtn
//end fix xtraFieldBtn bug
console.log('In commitBtn.onclick. Just past  If xtraFieldBtnExists. Removed xtraFieldBtn. xtraFieldBtnExists = ' + xtraFieldBtnExists);
//data.xtraField = Tsunami2 TSU-1100: This is the SECOND EDIT! Did it work?now back in testEdit version. This is the first edit!This edit works so I did something wrong in fixing accumulating xtraFieldButton! edit field decoder!
enterButton.setAttribute('class','attentionBtn');
//flash border of save btn if createNewDB
if (newDBGuidance) {
	enterButton.setAttribute('class','borderBlink');
}//end flash border save btn

editNewFieldWindow.setAttribute('class','hidden');

if(dbTableName.value.includes("creatingDB")) {
		enterButton.click();
		//saveBtn.click();
		}//end if(dbTableName.value.includes("creatingDB")) for automate click function Feb12 2023 //REMOVED TO BACKTRACK TO FIX GLITCH
  };//end commitBtn.onclick
 //LEFT OFF HERE JULY 25 2020 
  cancelCommitBtn.onclick = cancelEditNewField;
  function cancelEditNewField () {
	  commitButton.setAttribute('class','tdEdit'); 
	  NotesEditBtn.setAttribute('class','tdEdit');//set to flashing in createNewDB added Feb12 2023
	  //to correct error of retaining previous record for edit if coming from search
	  fromSearchRecord = false;
//editWindow.removeChild(xtraFieldBtn);//Jan 11 
//fix xtraFieldBtn bug
if (xtraFieldBtnExists) {
	editWindow.removeChild(xtraFieldBtn);
	xtraFieldBtnExists = false;
}//end if xtraFieldBtn
//end fix xtraFieldBtn bug
editNewFieldWindow.setAttribute('class','hidden');
	
}//end cancelEditNewField function

//clear edit ewFieldInput
clearEditNewFieldBtn.onclick = function () {
	editNewFieldInput.value = '';
	}//end clearEditNewFieldBtn.onclick
}//end function editNewField
 



//alert('I am at editInput submit');
//a variables called submitBtn previously
//const enterButton = document.querySelector('#submit');//make scope wider ..variable not found


clearBtn = document.querySelector('#clear');
clearTitleBtn = document.querySelector('#clearTitle');
cancelBtn = document.querySelector('#cancel');
 // enterButton.addEventListener('click', makeChanges); Use button.onclick because the eventListener registers all clicks and causes makeChanges to re-iterate twice or more?
 
 //cancel disabled if if (newDBGuidance) {
	 
	 if (newDBGuidance) {
		 cancelBtn.disabled = true;
		 cancelBtn.textContent = "Cancel disabled"
	} else {
		cancelBtn.disabled = false;
		cancelBtn.textContent = "Cancel";
	}//end if (newDBGuidance) {cancel disabled
 
 previewBtn = document.querySelector('#preview');
 
 
  //Show edits in top window as you go
  previewBtn.onclick = function () {
 originalBodyTextP.textContent = editInput.value;
}//end function previewBtn.onclick
 //REMOVE ABOVE IF MESSED UP NOV14
 
 editInput.onfocus = function () {enterButton.setAttribute('class','borderBlinkGrn');}//end editNewFieldInput.onchange
 
  enterButton.onclick = makeChanges;
  cancelBtn.onclick = cancel;
 //need end request.onsuccess get note 
 clearTitleBtn.onclick = clearTitle;
	clearBtn.onclick = clear;
	
alert('Scroll up or down if data is not on screen!');

//editInput.onclick = function() {}
function makeChanges () {
scrollHere = true;//have notes data scroll down to where edit was.added Mar26 2023
scrollBtn.textContent = "Scroll to Last EDIT";
	console.log('in makeChanges after enterBtn.onclick.');
	console.log('data.xtraField = ' + data.xtraField);
	//fix xtraFieldBtn bug
if (xtraFieldBtnExists) {
	editWindow.removeChild(xtraFieldBtn);
	xtraFieldBtnExists = false;
}//end if xtraFieldBtn
//end fix xtraFieldBtn bug
	//data.xtraField = Tsunami2 TSU-1100: now back in testEdit version. This is the first edit!This edit works so I did something wrong in fixing accumulating xtraFieldButton! edit field decoder!
	//flag to force update of table if edit note done but make sure table exists first otherwise table is not created properly on an initial run Jan 12
	enterButton.setAttribute('class','normalBtn');
	if (tableExists) {
		editNote = true;
	}//end if tableExists
	
	//let editItem = {title: data.title, body: editInput.value};
	//alert('I am at editInput after changes submit');
	let transaction = db.transaction([objectStoreName], 'readwrite');
  //reference/put the activated 'notes-os' object store into the variable objectStore
  let objectStore = transaction.objectStore(objectStoreName);
  //getting any title change
    data.title = editTitle.value;
	data.body = editInput.value;
	editBanner.textContent = 'Record with Title:' + '  ' + data.title + ' changed to: ';
	originalBodyTextP.textContent = data.body;
	
	
	console.log('new data edited! Data.body now = '+ data.body);
	// Put this updated object back into the database.
  //the object can not be cloned!!!!
  
  //create a request to put the object store identified with noteId.
  var requestUpdate = objectStore.put(data);
   requestUpdate.onerror = function(event) {
     // Do something with the error
	 editBanner.textContent = 'Whoops! ERROR! Transaction now inactive!'
   };
   requestUpdate.onsuccess = function(event) {
     // Success - the data is updated!
	 console.log("The record is updated!");
	//remove EDIT WINDOW
	editWindow.setAttribute('class','hidden');
	/*main.removeChild(main.firstChild);
	console.log('cleared note display'); */
	//alert('got to end requestUpdate.onsuccess');
	
	///*
	editInput.value = data.body; //"";
	//should I clear previous screen here to?
	//clearTitleBtn.onclick = clearTitle;
	//clearBtn.onclick = clear;
	
	while (list.firstChild) {
    list.removeChild(list.firstChild);
}
	displayData();
     };//end requestUpdate.onsuccess
	//force tableUpdate if notes edited Jan11 
	
	 // if(tableExists) {
		//  refreshTable();
	 // }//end if tableExists
	 
	  }//end makeChanges function. !!!!
	 //clear editTitle input
	 function clearTitle () {editTitle.value = " ";}//end clearTitle function
	function clear () {editInput.value = "";}//end clear function was editInput.value = " ";
//was here }//end makeChanges function
};//end request.onsuccess getNoteId
//redisplay the screen
//alert('got to redisplay the screen);')
//displayData();
function cancel () {
enterButton.setAttribute('class','tdEdit');	editWindow.setAttribute('class','hidden');
	//fix xtraFieldBtn bug
	console.log('In Cancel. At start of if xtraFieldBtnExists. Removed xtraFieldBtn. xtraFieldBtnExists = ' + xtraFieldBtnExists);
if (xtraFieldBtnExists) {
	editWindow.removeChild(xtraFieldBtn);
	xtraFieldBtnExists = false;
	//ReferenceError: Can't find variable: xtraFieldBtn line 1671
	console.log('In if xtraFieldBtnExists. Cancel Btn.  Removed xtraFieldBtn. xtraFieldBtnExists = ' + xtraFieldBtnExists);
//flash xtraFieldBtn if createNewDB
	if (newDBGuidance) {
		xtraFieldBtn.setAttribute('class','tdEdit');
		NotesEditBtn.setAttribute('class','tdEdit');//set to flashing in createNewDB added Feb12 2023
	}//end if newDBGuidance	
}//end if xtraFieldBtn
//end fix xtraFieldBtn bug
	//editWindow.removeChild(xtraFieldBtn);//Jan11
}//end cancel function

NotesEditBtn.setAttribute('class','tdEdit');//set to flashing in createNewDB added Feb12 2023
if(dbTableName.value.includes("creatingDB")) {
		//enterButton.click();
		saveBtn.click();
		}//end if(dbTableName.value.includes("creatingDB")) for automate click function Feb12 2023
 }//end function editItem

 
 

//document.getElementById("percent").value = '(Service Worker disabled in this testing version...Not running in Safari so not able to return )';

//preferences window section code for rename title, addField, changeColour

settingsBtn.onclick = options;


function options () {
showTable.setAttribute('class', 'hidden');//added Feb 28 2023 so table screen will not obscure prefs window if preferences tapped while viewing a table
//	if(newDBflag && fromDoneBtn) {fromDoneBtn = false;displayDataBtn.click();saveBtn.click()}//added Feb11 2023 to simulate click
	console.log("Just entered function options after tapping preferences button. newDBGuidance flag = " + newDBGuidance + " trigger = " + trigger);
	//creating new db: At preferences, newDBflag = false newDBGuidance = undefined xtraField = 0 dbName = New database
	
	//code to update pref variable values everytime you enter preferences
	prefVariablesArray = [viewDateWritten,dateShade,showExtraField,showScroll,centerTitle,tableDateTime,linkLabel,scrollTable,bkgrdImage,trigger,caseSensitive,includesSubstring];
	console.log('prefVariablesArray = ' + prefVariablesArray);
	console.log('viewDateWritten =' + viewDateWritten);
	
	
	//reset the variables from the saved prefVariablesArray
	
	viewDateWritten = prefVariablesArray[0];
	dateShade = prefVariablesArray[1];
	showExtraField = prefVariablesArray[2];
	showScroll = prefVariablesArray[3];
	centerTitle = prefVariablesArray[4];
	tableDateTime = prefVariablesArray[5];
	linkLabel = prefVariablesArray[6];
	scrollTable = prefVariablesArray[7];
	bkgrdImage = prefVariablesArray[8];
	trigger = prefVariablesArray[9];
	caseSensitive = prefVariablesArray[10];
	includesSubstring = prefVariablesArray[11];
	
	
	//code to update pref variable values everytime you enter preferences
	
	if(dbName === undefined && !newDBflag) {
		alert('No database has been selected! Select or create a database to make preferences available.');
	//prefWindow.setAttribute('class','hidden');
		//getFileNames();
		return;
	} //end if dbName===undefined
	
	//Aug25 restore status quo of preferences and add note btns after new db creation done Aug25
	
  if (prefBtnGreen) {
addNoteBtn.setAttribute('class','attentionBtn');
  addNoteBtn.disabled = false;
  settingsBtn.setAttribute('class', 'normalBtn');//preferences
  prefBtnGreen = false;
  
}//end if (newDBGuidance === undefined && !newDBflag && xtraField === 0)
//restore statusbquo after finishing creating new db



//const printOptionBtn = document.querySelector('#printOption');
//let enablePrint = false;

	const renameBtn = document.querySelector('#renameDB');
	//const workDiv = document.querySelector('#workDiv');
	const reNameWin = document.querySelector('#reNameWin');
	const dbTitle = document.querySelector('#dbTitle');
	const newTitle = document.querySelector('#newTitle');
	const prefWindow = document.querySelector('#prefWin');//'div id="prefWin" //IS THIS DECLARED TWICE???
	const prefLandscapeP = document.querySelector('#prefLandscape');
	const clearPrefWindow = document.querySelector('#clearPrefWindow');
	const changeColoursBtn = document.querySelector('#background');
	//const addFieldBtn = document.querySelector('#newField');//moved to global
	const addFieldWin = document.querySelector('#newFieldWin');
	const changeColoursWin = document.querySelector('#changeColoursWin');
	const chooseColoursWin = document.querySelector('#chooseColoursWin');
	
	//const displayDataBtn = document.querySelector('#displayData');
	//const displayDataBtn = document.querySelector('#displayData'); made global because used in createNewDB to stop border blink in reset sisplay btn after EDIT
	const showExtraFieldBtn = document.querySelector('#resetNewField');
	const scrollBtns = document.querySelector('#scrollBtns');
	const centerTitleBtn = document.querySelector('#centerTitle');
	const tableDateTimeBtn = document.querySelector('#tableTime');//moved to global variables
	const timeIndicator = document.querySelector('#timeIndicator');
	let timeIndicatorStr = "";
	const showLinkLabelBtn = document.querySelector('#useLinkLabel');
	const scrollTableBtn = document.querySelector('#scrollTable');
	const calculationAlertsBtn = document.querySelector('#calculationAlerts');
	//let calculationAlerts = false;//flag options .. show or don't show alerts when calculating sums or averaging DON'T WANT THIS FLAG HERE BECAUSE EVERYTIME YOU TAP PREFERENCES FLAG IS MADE FALSE
	const bkupAlertsBtn = document.querySelector('#bkupAlerts');
	//let bkupAlertsFlag = true;//flag to set bkup warnings on in preferences//moved to top because called upon before this statement is read
	const bkgrdImageBtn = document.querySelector('#bkgrdImage');
	const bodyImage = document.querySelector('#bodyImage');
	//const editTDTriggerBtn = document.querySelector('#editTDTrigger');//this is the btn in preferences used to switch between copy and dblclick for edit table data cells. The trigger variable is declared at start of prgm AND THE tdEditTriggerP var is also made global because it is used in tableScreenOptions..not just in the function options made global
	// const tdEditTriggerP = document.querySelector('#tdEditTrigger');//made global
	//set font color for dark mode Dec20
	if(screenDark) {
		tdEditTriggerP.style.color = "orange";
		totalInfoP.style.color = "orange";
		sumAcrossInfoP.style.color = "orange";
	} else {
		tdEditTriggerP.style.color = "blue";
		totalInfoP.style.color = "blue";
		sumAcrossInfoP.style.color = "blue";
	}//end if screenDark
	//set font color for dark mode
	
	const primeTableSP = document.querySelector('#primeTable');
	const viewDark = document.querySelector('#viewDark');
	const caseSensitiveSwitch = document.querySelector('#caseSensitive');
	const no = document.querySelector('#no');
	const yes = document.querySelector('#yes');
	const includesSubstringSwitch = document.querySelector('#includesSubstring');
	const noSS = document.querySelector('#noSS');
	const yesSS = document.querySelector('#yesSS');
	//let searchCaseSensitive;	//make global
	
	
	
	//code to allow for prefs window to fit in Landscape mode
	
	let prefWindowHeight = prefWindow.clientHeight;
	console.log('prefWindowHeight = ' + prefWindowHeight);
	
	if(prefWindowHeight == 620) {
		prefLandscapeP.textContent = "SCROLL UP ⬆️ TO SEE BOTTOM OF PREFERENCES WINDOW ";
	} else {
		prefLandscapeP.textContent = "";
		
	}//end if prefWindowHeight ==620
	
if(setup === 3)	{
//below setup prefs screen to reflect current values Date: Nov 9
	if(viewDateWritten) {
		creationDateBtn.textContent = 'Hide Creation Date';
		notifyP.textContent = "Creation dates will now be visible in " + dateShade;
		prefWindow.appendChild(notifyP);
	} else {
		creationDateBtn.textContent = 'Show Creation Date';
		notifyP.textContent = "Creation dates will now be hidden ";
		prefWindow.appendChild(notifyP);
	}//end of if viewDateWritten
	
	if(showExtraField === 1) {
		showExtraFieldBtn.textContent = 'Hide ExtraField';
		togglex = 0;//what is togglex see showExtraFieldBtn.onclick
	} else {
		showExtraFieldBtn.textContent = 'Show ExtraField';
		togglex = 0;//only works if set to 0 and I am not sure what I am using this for in the first place. Maybe should just make showExtraField Boolean??
	}//end showExtraField===1
	
	if(showScroll) {
		scrollBtns.textContent = 'Hide scroll btns';
	}else {
		scrollBtns.textContent = 'Show scroll btns';
	}//end if showScroll
	
	// if(enablePrint) {
	// 	printOptionBtn.textContent = "Disable Print";
	// 	printBtn.style.display = "unset";
	// 	} else {
	// 	printOptionBtn.textContent = "Enable Print";
	// 	printBtn.style.display = "none";
	// }//end if(enablePrint) {

	if(centerTitle) {
		centerTitleBtn.textContent = 'Title to Left';
	}else {
		centerTitleBtn.textContent = 'Center Record Title';
	}//enf if centerTitle
	
	if(!tableDateTime) {
		timeIndicatorStr = " PLUS ";
		tableDateTimeBtn.textContent = "TableDate" + timeIndicatorStr + "time";
		timeDateFlagP.textContent = "The edit DATE in table will NOT include the time.";
	} else {
		timeIndicatorStr = " WITHOUT ";
			tableDateTimeBtn.textContent = 'TableDate' + timeIndicatorStr +'time';
			timeDateFlagP.textContent = "The edit DATE in table will now  INCLUDE the time.";
	}//end if else tableDateTime

	
	if(!linkLabel) {
		showLinkLabelBtn.textContent = 'Use Link Labels';//switched textContent was Show link itself
		timeDateFlagP.textContent = "Active descriptive text now replaces the table links";
			} else {
		showLinkLabelBtn.textContent = 'Show link itself';
			
		timeDateFlagP.textContent = "The table now shows the real link (url)";
	}//end if else !linkLabel
	
	if(scrollTable) {
		scrollTableBtn.textContent = 'Disable Scroll Table';
		timeDateFlagP.textContent = "Horizontal Table scroll now enabled";
	} else {
		scrollTableBtn.textContent = 'Enable Scroll Table';
		timeDateFlagP.textContent = "Horizontal Table Scroll is now disabled.";
	}//end if else scrollTable

//NOTE RE BACKGROUND IMAGES. SAVED SETTING IN PREFERENCES FOR EACH BACKGROUND IMAGE IS NOT REFLECTED UNTIL PREFERENCES IS ENTERED, AND THEN SETTING TAKES EFFECT. IF I MOVE THE CODE ELSEWHERE IT WON'T LET THE DATABASE LOAD IN. WHY ? Nov11 2021
	
	if(bkgrdImage) {
		bkgrdImageBtn.textContent = 'Clear Background Image';
		bodyImage.setAttribute('class','bkgrdImage');
	} else {
		bkgrdImageBtn.textContent = 'Show background image';
		bodyImage.setAttribute('class','noBkgrdImage');
	}//end if else bkgrdImage
	
	if(trigger === 'dblclick') {
		editTDTriggerBtn.textContent = "Select-Copy";
		timeDateFlagP.textContent = "CURRENT SETTING: Double Tap to EDIT the Table data cells.";
	tdEditTriggerP.textContent = "Double Tap on the table's data cell to initiate EDIT mode and EDIT its contents. This is the default trigger choice. To change edit trigger to 'Select-Copy' go to Preferences.\r\nFIXED fields = columns 1-4; DYNAMIC fields = columns 5 and up.\r\nUse keywords TOTAL AVERAGE COST in field title (Dynamic fields only) for added functionality! (COST needs to be used with TOTAL or AVERAGE). Use TELEPHONE (in 3rd FIXED field only) or use EMAIL (in 4th FIXED field only) for activating telephone calling or email addresses. TELEPHONE and EMAIL keywords can also be used in ANY DYNAMIC field. The sumAcross keyword placed in the last column of the table will SUM all numbers (100 but NOT 100% or 100!) in that record across the table. Avaiable tags to flash filename are: -tag,*,!,✅,♥️,🔴,❗️. See documentation or ABOUT section.";	//editTDTriggerBtn.setAttribute('class','colorBtn');
	} else {
		editTDTriggerBtn.textContent = "Double Tap/Click";
		timeDateFlagP.textContent = "Use Select-Copy action to EDIT the Table data cells.";
		tdEditTriggerP.textContent = "To edit date or other cell contents 'SELECT' the contents, then tap 'COPY', Clear/Initialize the input element, then enter new text into the input element. (or 'paste' to enter original).";
		}//end if else trigger === 'dblclick'
		
		if(caseSensitive) {
			searchCaseSensitive = "1";
			caseSensitiveSwitch.value = "1";
		caseSensitive = true;
		console.log('caseSensitive = ' + caseSensitive);
		yes.setAttribute('class', 'colorBtn');
		no.setAttribute('class', 'normalBtn');
		} else {
			searchCaseSensitive = "0";
		caseSensitiveSwitch.value = "0";
		caseSensitive = false;
		console.log('caseSensitive = ' + caseSensitive);
		yes.setAttribute('class', 'normalBtn');
		no.setAttribute('class', 'colorBtn');
		}//end if else caseSensitive
		
		if(includesSubstring) {
			searchIncludesSubstring = "1";
			includesSubstringSwitch.value = "1";
			//includesSubstring = true;
		console.log('includesSubstring = ' + includesSubstring);
		yesSS.setAttribute('class', 'colorBtn');
		noSS.setAttribute('class', 'normalBtn');
		} else {
			searchIncludesSubstring = "0";
		includesSubstringSwitch.value = "0";
		//includesSubstring = false;
		console.log('includesSubstring = ' + includesSubstring);
		yesSS.setAttribute('class', 'normalBtn');
		noSS.setAttribute('class', 'colorBtn');
			
		}//end if else includesSubstring
		
		
	
//above setup prefs screen to reflect current values
}//end if setup === 3


	scrollBtns.onclick = function (){
		
		if(!showScroll) {
			scrollBtns.textContent = 'Hide scroll btns';
			showScroll = true;
			scrollBtns.setAttribute('class','colorBtn');
			scrolling.appendChild(scrollBtn);
			scrolling.appendChild(mybutton);
		} else {
			showScroll = false;
			scrollBtns.textContent = 'Show scroll btns';
			scrollBtns.setAttribute('class','attentionBtn');
			//alert('removing buttons');
			//ERROR: TypeError: Argument 1 ('child') to Node.removeChild must be an instance of Node
			
			scrolling.removeChild(scrollBtn);
		scrolling.removeChild(mybutton);	
			
		}//end if else showScroll
		
	}//end function scrollBtns.onclick
	
	// printOptionBtn.onclick = function () {
	// if(enablePrint) {
	// printBtn.style.display = "unset";	
	// enablePrint = false;
	// printOptionBtn.textContent = "Disable Print";
	// //resetFields = true;
	// //clearTableRows();
	// //displayTable();
	// } else {
	// 	printBtn.style.display = "none";
	// 	enablePrint = true;
	// 	printOptionBtn.textContent = "Enable Print";
	// 	//resetFields = true;
	// 	//clearTableRows();
		
	// 	//displayTable();
	// }//end if else 	if(enablePrint) {
	// }//end function printOptionBtn.onclick
	
	
	centerTitleBtn.onclick = function (){
		
		if(!centerTitle) {
			centerTitleBtn.textContent = 'Title to Left';
			centerTitle = true;
			centerTitleBtn.setAttribute('class','colorBtn');
			displayData();
			
		} else {
			centerTitle = false;
			centerTitleBtn.textContent = 'Center Record Title';
			centerTitleBtn.setAttribute('class','attentionBtn');
			//alert('removing buttons');
			//ERROR: TypeError: Argument 1 ('child') to Node.removeChild must be an instance of Node	
			displayData();
		}//end if else !centerTitle
		
	}//end function centerTitleBtn.onclick
	
//code to clear/show background image Oct11
//const bkgrdImageBtn = document.querySelector('#bkgrdImage');
//const bodyImage = document.querySelector('#bodyImage')
	bkgrdImageBtn.onclick = function (){
		
		if(bkgrdImage) {
			bkgrdImageBtn.textContent = 'Show background image';
			bkgrdImage = false;
		bodyImage.setAttribute('class','noBkgrdImage');
		//check status of dark mode
		checkScreenMode();
		//alert("At preferences-clear backImage..usingDarkMode = " + usingDarkMode + " screenDark = "+ screenDark);
		console.log("usingDarkMode = " + usingDarkMode + " screenDark = " + screenDark);
		// const usingDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
		// if (usingDarkMode) {bodyImage.style.backgroundColor= "black";}
		// if (!usingDarkMode) {bodyImage.style.backgroundColor= "white";}
			//getFileNames();
			
		} else {
			bkgrdImage = true;
			bkgrdImageBtn.textContent = 'Clear Background Image';
			bodyImage.setAttribute('class','bkgrdImage');
			bkgrdImageBtn.setAttribute('class','attentionBtn');
			//check status of screen mode
			checkScreenMode();//?in effective because srcmbackground image probably ditates background?
			//alert("At preferences-SHOW backImage..usingDarkMode = " + usingDarkMode + " screenDark = "+ screenDark);
			console.log("At show backImage usingDarkMode = " + usingDarkMode + " screenDark = "+ screenDark);
			//alert('removing buttons');
			//ERROR: TypeError: Argument 1 ('child') to Node.removeChild must be an instance of Node	
			//getFileNames();
		}//end if else bkgrdImageBtn.onclick
		
	}//end function bkgrdImageBtn.onclick
	
	bkgrdImageBtn.ondblclick = function (){
		
		if(bkgrdImage) {
			bkgrdImageBtn.textContent = 'Show background image';
			bkgrdImage = false;
		//bodyImage.setAttribute('class','noBkgrdImage');
		bodyImage.setAttribute('class','elmer');
		bkgrdImageBtn.setAttribute('class','colorBtn');
			//getFileNames();
			
		} else {
			bkgrdImage = true;
			bkgrdImageBtn.textContent = 'Clear Background Image';
			
			bodyImage.setAttribute('class','elmer');
			//bodyImage.setAttribute('class','bkgrdImage');
			bkgrdImageBtn.setAttribute('class','attentionBtn');
			//alert('removing buttons');
			//ERROR: TypeError: Argument 1 ('child') to Node.removeChild must be an instance of Node	
			//getFileNames();
		}//end if else bkgrdimage.ondblclick
		
	}//end function background image.ondblclick
	
//code to clear/show background image
	
//code below to switch addEventListener event type in edit td of table	
// const editTDTriggerBtn = document.querySelector('#editTDTrigger');//this is the btn in preferences used to switch between copy and dblclick for edit table data cells. The trigger variable is declared at start of prgm
if(DTBtnTappedOnce ===0) {
	editTDTriggerBtn.disabled = true;
	primeTableSP.textContent = " Initiate Table first!";
}else {
	editTDTriggerBtn.disabled = false;
	primeTableSP.textContent = "";
}//end else if DTBtnTappedOnce ===0 & tableExists to prevent messed up table

// const tdEditTriggerP = document.querySelector('#tdEditTrigger');
	editTDTriggerBtn.onclick = function () {
	//reset borderblink if blinking initiated by a TELEPHONE EMAIL keyword activation
	
	editTDTriggerBtn.setAttribute('class','tdEdit');
	
		editNote = true;//flag to refreshTable if notes editededitNote = false;//flag to refreshTable if notes edited also triggers table refresh if edit TD cell action is changed in preferences so ittakes effect imediately if changed in preferences. Otherwise you would have to wait for table refresh before new trigger is effective. 
		if(trigger==='copy') {
			trigger = 'dblclick';
			editTDTriggerBtn.textContent = "Select-Copy";
		timeDateFlagP.textContent = "CURRENT SETTING: Double Tap to EDIT the Table data cells.";
	tdEditTriggerP.textContent = "Double Tap on the table's data cell to initiate EDIT mode and EDIT its contents. This is the default trigger choice. To change edit trigger to 'Select-Copy' go to Preferences.\r\nFIXED fields = columns 1-4; DYNAMIC fields = columns 5 and up.\r\nUse keywords TOTAL AVERAGE COST or $ in field title (Dynamic fields only) for added functionality! (COST needs to be used with TOTAL or AVERAGE). Use TELEPHONE (in 3rd FIXED field only) or use EMAIL (in 4th FIXED field only) for activating telephone calling or email addresses. TELEPHONE and EMAIL keywords can also be used in ANY DYNAMIC field. The sumAcross keyword placed in the last column of the table will SUM all numbers (100 but NOT 100% or 100!) in that record across the table. Avaiable tags to flash filename are: -tag,*,!,✅,♥️,🔴,❗️. See documentation or the ABOUT section.";//note ` quote to enable \n	editTDTriggerBtn.setAttribute('class','colorBtn');
		}//end if trigger === 'copy'
		
		else if(trigger === 'dblclick') {
			trigger = 'copy';
			editTDTriggerBtn.textContent = "Double Tap/Click";
		timeDateFlagP.textContent = "Use Select-Copy action to EDIT the Table data cells.";
	tdEditTriggerP.textContent = "To edit date or other cell contents 'SELECT' the contents, then tap 'COPY', Clear/Initialize the input element, then enter new text into the input element. (or 'paste' to enter original). NOTE: TELEPHONE and EMAIL keywords ONLY WORK IN DBL-CLICK EDIT MODE!";	editTDTriggerBtn.setAttribute('class','colorBtn');
			
		}//end if trigger==='dblclick'
		
		//go to display table to update table to prevent table being messed up if you change databases at this point Nov17 2021
			tableScreenOptions();
			//added Oct5
			resetFields = true;//flag used in displayTable to keep fields being messed up if edit notes after viewing a new table
			
	};//end editTDTriggerBtn.onclick

//code above to switch addEventListener event type in edit td of table	

//save Settings
const saveSettingsBtn = document.querySelector('#saveSettings');

if(makeContactsTable || loadFromTableOptions) {
	saveSettingsBtn.style.backgroundColor = "lightgrey";
	saveSettingsBtn.disabled = true;	
	} else {
	saveSettingsBtn.style.backgroundColor = "rgb(240, 248, 255)";
	saveSettingsBtn.disabled = false;
}//end if makeContactsTable || loadFromTableOptions

//-xxxx-xxx

saveSettingsBtn.onclick = function () {
	setup = 3;
	saveVariables();
	saveSettingsBtn.setAttribute('class','colorBtn');
	
}//end function saveSettingsBtn.onclick
	
	//code for show link labels

//const showLinkLabelBtn = document.querySelector('#useLinkLabel');

if(DTBtnTappedOnce ===0 && tableExists) {
	showLinkLabelBtn.disabled = true;
}else {
	showLinkLabelBtn.disabled = false;
}//end else if DTBtnTappedOnce ===0 & tableExists
	showLinkLabelBtn.onclick = function (){
	//to safe gard going to table prior to initializing
//if(DTBtnTappedOnce ===0 & tableExists){initializeTable();}	


		if(!linkLabel) {
			showLinkLabelBtn.textContent = 'Show link itself';//was Show link itself.. Use Link Labels
			linkLabel = true;
			
	//borrowed timeDateFlagP.textContent = from the table Date section to give information re link labels June 9
	timeDateFlagP.textContent = "Active descriptive text now replaces the table links";
	//end of timeDateFlagP.textContent =
	showLinkLabelBtn.setAttribute('class','colorBtn');
			refreshed=1;
			editCurrentTable = 0; //Nov 22 so added field name headings are not generated twice
			while (STrows.firstChild) {
    STrows.removeChild(STrows.firstChild);
}//end while
//to maintain header after refresh
STtableHeader.textContent = dbTableName.value;
STtableHeader.setAttribute('class','attentionBtn');
STrows.appendChild(STtableHeader);
STrows.appendChild(STheadRow);
			displayTable();
			refreshed = 0;
			
		} else {
			linkLabel = false;
			showLinkLabelBtn.textContent = 'Use Link Labels';
			
	//borrowed timeDateFlagP.textContent = from the table Date section to give information re link labels June 9
	timeDateFlagP.textContent = "The table now shows the real link (url)";
	//end of timeDateFlagP.textContent =
			showLinkLabelBtn.setAttribute('class','attentionBtn');
			//alert('removing buttons');
			refreshed=1;
			editCurrentTable = 0; //Nov 22 so added field name headings are not generated twice
			while (STrows.firstChild) {
    STrows.removeChild(STrows.firstChild);
}//end while
//to maintain header after refresh
STtableHeader.textContent = dbTableName.value;
STtableHeader.setAttribute('class','attentionBtn');
STrows.appendChild(STtableHeader);
STrows.appendChild(STheadRow);
			displayTable();
			refreshed = 0;
		}//end if else showScroll
		
	}//end function scrollBtns.onclick
	
//end code for show link labels

//code for horizontal Table scroll option

//const scrollTableBtn = document.querySelector('#scrollTable');

if(DTBtnTappedOnce ===0 && tableExists) {
	scrollTableBtn.disabled = true;
}else {
	scrollTableBtn.disabled = false;
}//end else if DTBtnTappedOnce ===0 & tableExists
	scrollTableBtn.onclick = function (){
	//to safe gard going to table prior to initializing
//if(DTBtnTappedOnce ===0 & tableExists){initializeTable();}	

		if(!scrollTable) {
			scrollTableBtn.textContent = 'Disable Scroll Table';
			scrollTable = true;
			
	//borrowed timeDateFlagP.textContent = from the table Date section to give information re link labels June 9
	timeDateFlagP.textContent = "Horizontal Table scroll now enabled";
	//end of timeDateFlagP.textContent =
	scrollTableBtn.setAttribute('class','colorBtn');
			refreshed=1;
			editCurrentTable = 0; //Nov 22 so added field name headings are not generated twice
			while (STrows.firstChild) {
    STrows.removeChild(STrows.firstChild);
}//end while
//to maintain header after refresh
STtableHeader.textContent = dbTableName.value;
STtableHeader.setAttribute('class','attentionBtn');
STrows.appendChild(STtableHeader);
STrows.appendChild(STheadRow);
			displayTable();
			refreshed = 0;
			
		} else {
			scrollTable = false;
			scrollTableBtn.textContent = 'Enable Scroll Table';
			
	//borrowed timeDateFlagP.textContent = from the table Date section to give information re link labels June 9
	timeDateFlagP.textContent = "Horizontal Table Scroll is now disabled.";
	//end of timeDateFlagP.textContent =
			scrollTableBtn.setAttribute('class','attentionBtn');
			//alert('removing buttons');
			refreshed=1;
			editCurrentTable = 0; //Nov 22 so added field name headings are not generated twice
			while (STrows.firstChild) {
    STrows.removeChild(STrows.firstChild);
}//end while
//to maintain header after refresh
STtableHeader.textContent = dbTableName.value;
STtableHeader.setAttribute('class','attentionBtn');
STrows.appendChild(STtableHeader);
STrows.appendChild(STheadRow);
			displayTable();
			refreshed = 0;
		}//end if else scroll Table
		
	}//end function scrollTableBtn.onclick
	
	
//END code for horizontal Table scroll option	


//REMOVE IF SCREW UP DATE FEB 11 2021 this code is to fix show extra field on load when extra field is already set and showing!
if (showExtraField ===1) {
	showExtraFieldBtn.textContent = "Hide extra field";
	togglex = 1;
}//end if showExtraField =1
//remove above if screw up


addFieldBtn.setAttribute('class','attentionBtn');
if(newDBGuidance) {//was if(newDBflag..changed to if(newDBGuidance))
	addFieldBtn.setAttribute('class','borderBlink');
}//end if newDBflag
	if(saveBtn.textContent === 'SAVED') {
		saveBtn.textContent ='SAVE';
	}//end if saveBtn.textContent

	//const tableDateTimeBtn = document.querySelector('#tableTime');//moved to global variables
	
	tableDateTimeBtn.setAttribute('class', 'attentionBtn');
	//const timeDateFlagP = document.querySelector('#timeDateFlag');//moved to global variables
	//const timeIndicator = document.querySelector('#timeIndicator');
	//let timeIndicatorStr = "";
	
	//TypeError: null is not an object (evaluating 'timeIndicator.setAttribute')
	//timeIndicator.setAttribute('class','attentionBtn');
	
	tableDateTimeBtn.onclick = function () {
	
	
			
		if (tableDateTime) {
			//prefWindow.removeChild(timeDateFlagP);
		tableDateTime = false;
		//TypeError: null is not an object (evaluating 'timeIndicator.textContent = " plus "')
		//timeIndicator.textContent = " plus ";
			timeIndicatorStr = " PLUS ";
			
		//TypeError: null is not an object (evaluating 'timeIndicator.setAttribute')	timeIndicator.setAttribute('class','attentionBtn');
			
		tableDateTimeBtn.textContent = "TableDate" + timeIndicatorStr + "time";
		timeDateFlagP.textContent = "The edit DATE in table will NOT include the time.";
		//prefWindow.appendChild(timeDateFlagP);
		
		}
		else {
			//prefWindow.removeChild(timeDateFlagP);
			tableDateTime = true;
			timeIndicatorStr = " WITHOUT ";
			//TypeError: null is not an object (evaluating 'timeIndicator.textContent = " without "')
			//timeIndicator.textContent = " without ";
			//timeIndicator.setAttribute('style','background-color: red');
			//timeIndicator.setAttribute('class','attentionBtn');
			//for some reason I can’t set attribute of timeIndicator ?span HTML?
			tableDateTimeBtn.textContent = 'TableDate' + timeIndicatorStr +'time';
			timeDateFlagP.textContent = "The edit DATE in table will now  INCLUDE the time.";
			//prefWindow.appendChild(timeDateFlagP);
		}//end tableDateTime
	}//end tableTimeBtn.onclick
	
	//let notifyP = document.createElement('p');//declared here so variable is recognized by clear preferences function
	
	
	//workDiv.setAttribute('class','showing');

	prefWindow.setAttribute('class','showing');
	if(newDBflag) {
		renameBtn.setAttribute('class','borderBlink');//if creating newDB do this first
		//renameBtn.setAttribute('class','attentionBtn');//if creating newDB do this first
		
		addFieldBtn.setAttribute('class','normalBtn');
		addFieldBtn.disabled = true;
		//for guidance creating newDB
		newDBGuideP.textContent = " Tap RENAME DATABASE, tap RESET DISPLAY, then SAVE (now high-lighted in yellow) ";
	prefWindow.appendChild(newDBGuideP);
	}//end if newDBflag
	
	//when creating newDB arriving in preferences after add note stage, make condition for displaying next newDBGuidance that newDBflag has been ccancelled (back at saveVariables), and that newDBGuidance is stii active(true)bThen in addField remove this guidanceP
	console.log("In options: newDBGuidance = " + newDBGuidance + " newDBflag = " + newDBflag);
	//In options: newDBGuidance = falsenewDBflag = false reset newDBGuidance after rerun and make true again to complete guidance until DONEbutton Aug 25
	
	//add a condition indicating from createNewDab.i.e. dbName = "Create nwe database….????"dbName will = the new database name if coming from cretedb so making condition && dbName !== undefined will let the newDBGuidance statement be shown when creating a new db but not shown if going to preferences from a start of dougiebase or after a cancel of the getfilenames screen Oct 11 Also should disable preferences btn in crete ewDBBtn.onclick and reenable after cretenewDB btn name entry input clicked
	
	if (newDBGuidance === undefined && !newDBflag && xtraField === 0 && dbName !== undefined) {
		console.log('At preferences, newDBflag = ' + newDBflag + ' newDBGuidance = ' + newDBGuidance + ' xtraField = '+ xtraField + ' dbName = ' + dbName);
	//At preferences again..for Add Relabel notes second data field:
	//At preferences, newDBflag = false newDBGuidance = undefined xtraField = 0 dbName = Donald Duck line 3285
	//at this stage of create newDb xtraField will = 0
//addFieldBtn.textContent = "Now TAP HERE!"	addFieldBtn.setAttribute('class','borderBlink');
//SyntaxError: Unexpected identifier 'addFieldBtn'

		newDBGuideP.textContent = "When creating a new database, now tap 'ADD/RELABEL FIELD' button to initialize the Notes second data field.";
		newDBGuideP.setAttribute('class','borderBlinkGrn');
		prefWindow.appendChild(newDBGuideP);
		newDBGuidance = true;
		
		//addFieldBtn.setAttribute('class','borderBlinkGrn');//did not work
		
	}//end if newDBGuidance && !newDBflag
	
	//put search case sensitive stuff here???
	
	//Left off here Jan 24
	
	// const caseSensitiveSwitch = document.querySelector('#caseSensitive');
	// const no = document.querySelector('#no');
	// const yes = document.querySelector('#yes');
	
	//let searchCaseSensitive;	//make global
	caseSensitiveSwitch.onchange = function(){
		searchCaseSensitive = caseSensitiveSwitch.value;
		console.log('searchCaseSensitive = ' + searchCaseSensitive);
	//NOTE! caseSensitiveSwitch.value returns a number as type string so conditional below must use quotes around the number!!	
	//}//end function caseSenseSitive.onchange
	
	//console.log('caseSensitive = ' + caseSensitive);
	if (searchCaseSensitive === "1") {
		caseSensitive = true;
		console.log('caseSensitive = ' + caseSensitive);
		yes.setAttribute('class', 'colorBtn');
		no.setAttribute('class', 'normalBtn');
		
	} //end if searchCaseSensitive === 1
	else if (searchCaseSensitive === "0") {
	
		caseSensitive = false;
		console.log('caseSensitive = ' + caseSensitive);
		yes.setAttribute('class', 'normalBtn');
		no.setAttribute('class', 'colorBtn');
		
	}//end if searchCaseSensitive === 0
	console.log('caseSensitive = ' + caseSensitive);
	};//end function caseSenseSitive.onchange
	//}//end function caseSenseSitive.onchange
	//search case sensitive code above
	
		//put contains sub string stuff here???
		
		//SS = SubString
	
	// const includesSubstringSwitch = document.querySelector('#includesSubstring');
	// const noSS = document.querySelector('#noSS');
	// const yesSS = document.querySelector('#yesSS');
	//let searchCaseSensitive;	//make global
	includesSubstringSwitch.onchange = function(){
		searchIncludesSubstring = includesSubstringSwitch.value;
		console.log('searchIncludesSubstring = ' + searchIncludesSubstring);
	//NOTE! caseSensitiveSwitch.value returns a number as type string so conditional below must use quotes around the number!!	
	//}//end function caseSenseSitive.onchange
	
	//console.log('caseSensitive = ' + caseSensitive);
	if (searchIncludesSubstring === "1") {
		includesSubstring = true;
		console.log('includesSubstring = ' + includesSubstring);
		yesSS.setAttribute('class', 'colorBtn');
		noSS.setAttribute('class', 'normalBtn');
		
	} //end if searchCaseSensitive === 1
	else if (searchIncludesSubstring === "0") {
	
		includesSubstring = false;
		console.log('includesSubstring = ' + includesSubstring);
		yesSS.setAttribute('class', 'normalBtn');
		noSS.setAttribute('class', 'colorBtn');
		
	}//end if searchCaseSensitive === 0
	console.log('includesSubstring = ' + includesSubstring);
	};//end function caseSenseSitive.onchange
	//}//end function caseSenseSitive.onchange
	//search case sensitive code above
	
	
	clearPrefWindow.onclick = function () {
		//Tap here to return to notes
	/*prefWindow.removeChild(notifyP);*/
   displayDataBtn.setAttribute('class', 'normalBtn');	prefWindow.setAttribute('class','hidden');
   //update prefVariables values if any changes were made
   prefVariablesArray = [viewDateWritten,dateShade,showExtraField,showScroll,centerTitle,tableDateTime,linkLabel,scrollTable,bkgrdImage,trigger,caseSensitive,includesSubstring];
	}; //end clearPrefWindow.onclick
	
	//decorate buttons
	if (xtraField === 0) {
		
		showExtraFieldBtn.disabled = true;
		//For createNewDB
//	addFieldBtn.setAttribute('class','borderBlink');
	addFieldBtn.setAttribute('class','attentionBtn');
	}//end if xtraField =0
	else if (xtraField === 1) {
		//why did I disable showExtraField Btn here? Is this a mistake? Date: Aug 6 2020 CHANGED TO false on May24 2021!,!
	showExtraFieldBtn.disabled = false;	showExtraFieldBtn.setAttribute('class','colorBtn');
	addFieldBtn.setAttribute('class','colorBtn');
	displayDataBtn.setAttribute('class','tdEdit');
	addFieldBtn.textContent = 'Relabel Field';
		
}//end if xtraField =1

	//renameBtn.onclick = renameTitle;
	
//REWRITING renameBtn.onclick code because rename btn in preferences no longer works as previously……….so if not creating a new db will use to go to renameDataBaseName function BUT if creating new db will go to renameTitle function	
renameBtn.onclick = function () {

//alert("newDBGuidance = " + newDBGuidance + " newDBflag =  " + newDBflag + " dbTableName.value = " + dbTableName.value);

	if(newDBGuidance === undefined && !newDBflag && !(dbTableName.value.includes("creatingDB")) ) {
	dataBaseName = dbTableName.value;
	
	//alertbkup("dataBaseName = " + dataBaseName);
	//renameDbFileNameButton.click();//did not work so go direct to function
	prefWindow.setAttribute('class','hidden');
	selectedDBNameP.textContent = "RENAMING database ...";
			
			dbFileNameInfo.textContent = dataBaseName;
			selectedDBNameP.appendChild(dbFileNameInfo);
renameDataBaseFileName(dataBaseName);	
	dbFileNameRenamed = true;//flag to make notice in Current Database File Names window
			//backupDataBase(dataBaseName);
			//keep track of what old filename was
			dbFileNameRenamedName = dataBaseName;//preserve for deleted notice in getFileNames May10	
	}else {
		renameTitle();
	}//end else renameBtn.onclick = function ()
	
}//end renameBtn.onclick = function ()


	changeColoursBtn.onclick = changeColours;
	addFieldBtn.onclick = addField;
	creationDateBtn.onclick = function () {
		//alert('doneOnce = ' + doneOnce);
		if (doneOnce === 1) {
		 doneOnce = 0; prefWindow.removeChild(dateColorBtn);
				}//end if doneOnce
		
		viewCreationDate();//referenced at top of code;
		
	};//end creationDateBtn.onclick
	/*function handleDate () { 
		//if(prefWindow.dateColorBtn){ prefWindow.removeChild(dateColorBtn);
		//}//end if dateColorBtn
		viewCreationDate;//referenced at top of code
	}//end function handleDate */
	
//toggle calculation alerts
	calculationAlertsBtn.onclick = function () {
	if(calculationAlerts) {
	calculationAlertsBtn.textContent = " Turn Calculation alerts ON";
	timeDateFlagP.textContent = "Calculation Alerts are now OFF.";
	calculationAlertsBtn.style.backgroundColor = "yellow";
		calculationAlerts = false;
	} else {
		calculationAlertsBtn.textContent =
		"Turn Calculation alerts OFF";
		timeDateFlagP.textContent = "Calculation Alerts are now ON.";
		calculationAlertsBtn.style.backgroundColor = "lightgreen";
		calculationAlerts = true;
		}//end if calculationAlerts
		
	}//end calculationAlertsBtn.onclick
//toggle calculation alerts

//toggle bkup alerts
	bkupAlertsBtn.onclick = function () {
	if(bkupAlertsFlag) {
	bkupAlertsBtn.textContent = " Turn Backup alerts ON";
	timeDateFlagP.textContent = "Backup Alerts are now OFF.";
	bkupAlertsBtn.style.backgroundColor = "yellow";
		bkupAlertsFlag = false;
	} else if(!bkupAlertsFlag) {
		bkupAlertsBtn.textContent =
		"Turn Backup alerts OFF";
		timeDateFlagP.textContent = "Backup Alerts are now ON.";
		bkupAlertsBtn.style.backgroundColor = "lightgreen";
		bkupAlertsFlag = true;
		}//end if else if bkup Alerts
//alertbkup("At preferences - bkupAlertsFlag = " + bkupAlertsFlag);
		
	}//end bkupAlertsBtn.onclick
//toggle bkup alerts



// flashBtn.onclick = function () {
// 	//toggle flashing tagged filename
// Turn flashing OFF	
// 	if(!flashing) {
// 	flashBtn.textContent = "Turn flashing OFF";
// 	timeDateFlagP.textContent = "Tagged files now flashing.";
// 	flashBtn.style.backgroundColor = "yellow";
// 		flashing = true;
// 	} else {
// 		flashBtn.textContent =
// 		"Flash tagged filenames";
// 		timeDateFlagP.textContent = "Flashing filenames now OFF.";
// 		flashBtn.style.backgroundColor = "lightgreen";
// 		flashing = false;
// 		}//end if (!flashing) 
		
// 	}//end flashBtn.onclick = function ()
//toggle flashing filenames




	displayDataBtn.onclick = function () {
		prefWindow.setAttribute('class','hidden');	
		displayData();
		if(newDBflag) {
		saveBtn.click();//added Feb 12 2023 click function 4
		}//end if(newDBflag)
	};//end displayDataBtn.onclick
	
	//reset newField
	//disable show extra field btn until setup complete added !newDBflag because if creating a new db from scratch on first run in Safarii you otherwise can not ever add a new second fieldfield May 24
	if(setup===0 && !newDBflag) {
		showExtraFieldBtn.disabled = true;
		addFieldBtn.disabled = true;
	}//end if setup =0
	else if (xtraField === 1) {
		showExtraFieldBtn.disabled = false;
		addFieldBtn.disabled = false;
	}//end else
	showExtraFieldBtn.onclick = function () {
	if (!togglex) {
		togglex = 1;
		showExtraFieldBtn.textContent = 'Hide ExtraField';
		showExtraField = 1;
	}//end if togglex
	else if (togglex) {
		togglex = 0;
		showExtraFieldBtn.textContent = 'Show ExtraField';
		showExtraField = 0;
	}//end else if toggllex
	prefWindow.setAttribute('class','hidden');
		
		displayData();
	};//end showExtraField.onclick
	
	//function renameTitle
	function renameTitle () {
	
	let doneBtn = document.createElement('button');
      doneBtn.textContent = 'DONE';
      reNameWin.appendChild(doneBtn);
     doneBtn.style.display = "none";//DONE btn won't show until after title input taken careof 
      
		if(newDBflag) {
		// doneBtn.style.display = "none";//DO E btn won't show until after title input taken careof
			renameBtn.setAttribute('class','normalBtn');
		//} //end if newDBflag
		displayDataBtn.setAttribute('class','borderBlink');
		saveBtn.setAttribute('class', 'colorBtn');
	settingsBtn.setAttribute('class', 'normalBtn');	addNoteBtn.setAttribute('class','normalBtn');
	
	} //end if newDBflag
	if(!newDBflag){
		addNoteBtn.disabled = false;//for create new db, add note btn was disabled in onupgradeneeded
		addNoteBtn.setAttribute('class','attentionBtn');
	}//end if !newDBflag..to make sure save is done before add new note in create newDB May23
	
	//Nov27 2021 retain old code just in case
	// if(newDBflag) {
	// 		renameBtn.setAttribute('class','normalBtn');
	// 	} //end if newDBflag
	// 	saveBtn.setAttribute('class', 'colorBtn');
	// settingsBtn.setAttribute('class', 'normalBtn');	addNoteBtn.setAttribute('class','attentionBtn');
	// if(!newDBflag){
	// 	addNoteBtn.disabled = false;//for create new db, add note btn was disabled in onupgradeneeded
	// }//end if !newDBflag..to make sure save is done before add new note in create newDB May23
	// //retain old code just in case
	
	displayDataBtn.setAttribute('class','borderBlink');
	
	// displayDataBtn.setAttribute('class','colorBtn');
	

	prefWindow.setAttribute('class','hidden');
	 reNameWin.setAttribute('class','showing');
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	reNameWin.style.backgroundColor = "black";
	reNameWin.style.color = "white";
} else {
	reNameWin.style.backgroundColor = "#eee";
	reNameWin.style.color = "black";
}//end if else screenDark 
	// alert("dbTableName.value = " + dbTableName.value + " dbTitle.textContent = " + dbTitle.textContent + " dbName = " + dbName);
	 //dbTableName.value set to 'Notes' at top of code
const newTitlePara = document.createElement('p');
 newTitlePara.setAttribute('class','borderBlinkGrn');//to emthazize importance of sequence for entering database name
 newTitlePara.style.color = "black";//added Feb 12 2023
	if(newDBflag) {
	// newTitlePara.setAttribute('class','borderBlink');//to emthazize importance of sequence for entering database name
	//dbTitle.textContent = dbTableName.value;//changed to dataBaseName Feb17 2023
	dbTitle.textContent = dataBaseName;
	newTitlePara.textContent = "Re-enter the new database name here - TAP THE INPUT ELEMENT ABOVE for default entry. If you change the name again be sure to retain the '.creatingDB' extension, which will be removed by DougieBase later in the process."
	//newTitle.value = dbTitle.textContent;
	//newTitle.value = dbName;
	newTitle.value = dataBaseName;
	
	// doneBtn.style.display = "unset";
	}//end if(newDBflag) {  
	 
if(!newDBflag) {
	 //added Nov24 2022 to set table name to database name as default
	 //dbTableName.value = dbName;
	 newTitlePara.textContent = "Re-enter the new database name here - tap input element above and enter SPACE bar for default entry. The database table is now named : "
	 newTitle.value = dbName;
	 //REMOVE ABOVE LINE IF MESSED UP!!!!
	 
	//dbTitle.textContent = dbTableName.value;
	dbTitle.textContent = dbName;
//const previousTitlePara = document.createElement('p');
	 previousTitlePara.textContent = 'The database table previously named : ' + dbTableName.value; 
	 // const cancelTableTitleBtn = document.createElement('button');
	 cancelTableTitleBtn.textContent = "CANCEL name table";
	reNameWin.appendChild(cancelTableTitleBtn);
	}//end if(!newDBflag) {
	
	// dbTitle.textContent = 'Notes';
	 // let newTitlePara = document.createElement('p');
	 
	// newTitlePara.textContent = "⚠️ After entering new title, follow the flashing button prompts to register the new table title!"
	 //get new title
	// newTitle.addEventListener('input', function () {
	 
	 newTitle.addEventListener('focus', function () {
	 doneBtn.style.display = "unset";
	 dbTitle.textContent = newTitle.value;
	 
	 //code below does not work!
	 // if(newTitle.value === '\n'|| '\r') {
		//  newTitle.value = dbName;
	 // }
		 //dbTableName variable declared as global on line 16? removed this line 16 because it caused error: 'attempting to assign to a readonly property? then code worked. so where is this variable declared?'maybe getElementByID takes care of it??
		 
		// !!!REMOVE .textContent fron dbTableName
		
		
	 dbTableName.value = newTitle.value.trim();
	 
	// dbTableName.textContent = newTitle.value;
	if(!newDBflag) {
	 newTitlePara.textContent = 'The database table is now named : ' +  dbTitle.textContent; 
	 }//end if(!newDBflag) {
	 
	 if(newDBflag) {
	 newTitlePara.textContent = 'The new database is now named : ' +  dbTitle.textContent + ". Now tap the DONE button, then follow the flashing prompt buttons!"; //removed Tap RESET DISPLAY in Preferences, then tap the flashing SAVE button Feb 12 2023
	 }//end if(newDBflag) {
	 //<h3>The current title of this database is: <scan id="dbTitle"></scan></h3>
	 
	 // alert("dbTableName.value  = " + dbTableName.value + " newTitle.value = " + newTitle.value + " dbTableName.textContent = " + dbTableName.textContent + " dbTitle.textContent = " + dbTitle.textContent);
	 
	 });//end newTitle.addEventListener CHANGED dbTableName to dbTitle.textContent
	 
	// alert(dbTitle.textContent);
	 //dbTitleName = newTitle.value;
	if(!newDBflag) { 
	//alertrnf("newDBflag = "+newDBflag);
	
	 reNameWin.appendChild(previousTitlePara);
	 }//end if(!newDBflag) {
	 
	 reNameWin.appendChild(newTitlePara);
	 
	 
	 // let doneBtn = document.createElement('button');
     //  doneBtn.textContent = 'DONE';
     //  reNameWin.appendChild(doneBtn);
	  doneBtn.onclick = function () {
	  newTitlePara.setAttribute('class','attentionBtn');//to emthazize importance of sequence for entering database name
		 document.getElementById("dbTableName").innerHTML = dbTableName.value;
		//get ready for next instance of rename dbTablName
	//alertrnf("dbTableName.value = " + dbTableName.value);
		//added Dec14 to clear input field of renameDB
		//fromDoneBtn = true;//testing .click() for click function 3? ?not used
		newTitle.value ="";
			//added Dec14
			saveBtn.setAttribute('class', 'borderBlink');
			
		reNameWin.removeChild(newTitlePara);
		reNameWin.removeChild(doneBtn);
if(!newDBflag) { 
reNameWin.removeChild(previousTitlePara);
reNameWin.removeChild(cancelTableTitleBtn);
 }//end if(!newDBflag) { 
        
      reNameWin.setAttribute('class','hidden');
	  prefWindow.setAttribute('class','showing');
	  displayDataBtn.click();//added Feb 12 for .click click function 3
  };//end doneBtn.onclick
  
 if(!newDBflag) {  
  cancelTableTitleBtn.onclick = function () {
	 newTitle.value ="";
	 newTitlePara.setAttribute('class','attentionBtn');//to emthazize importance of sequence for entering database name Date; Jan22 2023
	 reNameWin.removeChild(newTitlePara);
		reNameWin.removeChild(previousTitlePara);
        reNameWin.removeChild(doneBtn);
        reNameWin.removeChild(cancelTableTitleBtn);	reNameWin.setAttribute('class','hidden');
	  prefWindow.setAttribute('class','showing');
 		 }//end cancelTableTitleBtn.onclick
	 }//end if(!newDBflag) { 
	 
	}//end function renameTitle
	
	//start function changeColours()
function changeColours () {
	dbNameInfo.textContent = dbName;
	changeColoursWin.appendChild(dbNameInfo);
	const changeColourListItem = document.querySelector('#changeColourListItem');
	const changeColourNoteTitle = document.querySelector('#changeColourNoteTitle');
	const changeColourBody = document.querySelector('#changeColourBody');
	let xtraFieldPara = document.createElement('p');
	prefWindow.setAttribute('class','hidden');
		changeColoursWin.setAttribute('class','showing');
		
		//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	changeColoursWin.style.backgroundColor = "black";
	changeColoursWin.style.color = "white";
	dbNameInfo.style.color = "black";
} else {
	changeColoursWin.style.backgroundColor = "#eee";
	changeColoursWin.style.color = "black";
}//end if else screenDark
		
		//js code for change colours here
		changeColourListItem.addEventListener('click', function() {
  var rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
  changeColourListItem.style.backgroundColor = rndCol;
  //set global variable
  noteListItemColour = rndCol;
});//end brace bracket for changeColourListItem.addEventListener
		


changeColourNoteTitle.addEventListener('click', function() {
  var rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
  changeColourNoteTitle.style.backgroundColor = rndCol;
  //set global variable
  noteTitleColour = rndCol;
  });//end brace bracket for changeColourNote.addEventListener
  
  changeColourBody.addEventListener('click', function() {
  var rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
  changeColourBody.style.backgroundColor = rndCol;
  
  //set global variable
  bodyColour = rndCol;
});//end brace bracket for changeColourNote.addEventListener

if (xtraField === 1) {
	changeColourListItem.appendChild(xtraFieldPara);
	xtraFieldPara.textContent = 'Tap here to change current background colour of the ( ' + newFieldName + ' ) extra field.'
	xtraFieldPara.addEventListener('click', function() {
  var rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
  xtraFieldPara.style.backgroundColor = rndCol;
  
  //set global variable
  xtraFieldColour = rndCol;
});//end brace bracket for xtraFieldPara.addEventListener
}//end if xtraField === 1

let fontColourBtn = document.createElement('button');
      fontColourBtn.textContent = 'Text - WHITE/BLACK';
      changeColoursWin.appendChild(fontColourBtn);	  

let defaultBtn = document.createElement('button');
      defaultBtn.textContent = 'DEFAULT COLOURS';
      changeColoursWin.appendChild(defaultBtn);

let doneBtn = document.createElement('button');
      doneBtn.textContent = 'DONE';
      changeColoursWin.appendChild(doneBtn);
	  
let cancelChangeColorsBtn = document.createElement('button');
      cancelChangeColorsBtn.textContent = 'CANCEL';
      changeColoursWin.appendChild(cancelChangeColorsBtn);
	  
let chooseColorBtn = document.createElement('button');
       chooseColorBtn.textContent = 'CHOOSE COLOUR';
      changeColoursWin.appendChild(chooseColorBtn);
	  
let saveCurrentBtn = document.createElement('button');
      saveCurrentBtn.textContent = 'SAVE CURRENT COLOURS';
      changeColoursWin.appendChild(saveCurrentBtn);

// let restoreSavedBtn = document.createElement('button');//made global so disable would work in getFileNames
      restoreSavedBtn.textContent = 'RESTORE SAVED COLOURS';
	 changeColoursWin.appendChild(restoreSavedBtn);
	fontColourBtn.onclick = function () {
		if (toggle === 0) {
			toggle = 1;
		changeColourListItem.style.color = "white";
	//changeColourNoteTitle.style.color = "white";
  //set global variable 
	//changeColourBody.style.color = "white";
   //set global variable
   fontColour = "white";
   fontColourBtn.textContent = 'Text - BLACK';
  // displayData(); 
 		}//end if !toggle
		
	else if (toggle === 1) {
		toggle = 0;
		changeColourListItem.style.color = "black";
	//changeColourNoteTitle.style.color = "black";
  //set global variable 
	//changeColourBody.style.color = "black";
   //set global variable
   fontColour = "black";
   fontColourBtn.textContent = 'Text - WHITE';
 //  displayData(); 
	}//end if toggle=1
	
	
  };//end fontColourBtn.onclick  
	  
	  defaultBtn.onclick = function () {
		  saveBtn.setAttribute('class', 'colorBtn');
	changeColourListItem.style.backgroundColor = "yellow";
		  noteListItemColour = "yellow";	
	changeColourNoteTitle.style.backgroundColor = "yellow";
  //set global variable
          noteTitleColour = "yellow";  
	changeColourBody.style.backgroundColor = "yellow";
   //set global variable
          bodyColour = "yellow";
		  
	if (xtraField === 1) {
	xtraFieldPara.style.backgroundColor = "yellow";
  
  //set global variable
  xtraFieldColour = "yellow";	
		
	}//end if xtraField = 1
	//set font colour to default black
changeColourListItem.style.color = "black";
fontColour = "black";
fontColourBtn.textContent = 'Text - WHITE';

	changeColoursWin.removeChild(doneBtn);
	changeColoursWin.removeChild(defaultBtn);
  changeColoursWin.removeChild(fontColourBtn);
 changeColoursWin.removeChild(chooseColorBtn);
changeColoursWin.removeChild(cancelChangeColorsBtn);
changeColoursWin.removeChild(saveCurrentBtn);
changeColoursWin.removeChild(restoreSavedBtn);

  if (xtraField === 1) {
	  changeColourListItem.removeChild(xtraFieldPara);
  }//end if (xtraField ===1)
   changeColoursWin.setAttribute('class','hidden');
	  prefWindow.setAttribute('class','showing');
	  displayData();  
		  
	  };//end defaultBtn.onclick
	  
	  
		  //code for done here
		
		  
	  doneBtn.onclick = function () {
		  saveBtn.setAttribute('class', 'colorBtn');
		  doneBtn.setAttribute('class','tdEdit');
		  
		//code for done here
		changeColoursWin.removeChild(doneBtn);
	changeColoursWin.removeChild(defaultBtn);
  changeColoursWin.removeChild(fontColourBtn);
 changeColoursWin.removeChild(chooseColorBtn);
 changeColoursWin.removeChild(saveCurrentBtn);
changeColoursWin.removeChild(restoreSavedBtn);
changeColoursWin.removeChild(cancelChangeColorsBtn);
 
  if (xtraField === 1) {
	  changeColourListItem.removeChild(xtraFieldPara);
  }//end if (xtraField ===1)
  changeColoursWin.setAttribute('class','hidden');
	  prefWindow.setAttribute('class','showing');
	  displayData();
  };//end doneBtn.onclick
  
 //CANCEL BUTTO
 cancelChangeColorsBtn.onclick = function () {
		  saveBtn.setAttribute('class', 'colorBtn');
		//code for done here
		changeColoursWin.removeChild(doneBtn);
	changeColoursWin.removeChild(defaultBtn);
  changeColoursWin.removeChild(fontColourBtn);
 changeColoursWin.removeChild(chooseColorBtn);
 changeColoursWin.removeChild(saveCurrentBtn);
changeColoursWin.removeChild(restoreSavedBtn);
changeColoursWin.removeChild(cancelChangeColorsBtn);
 
  if (xtraField === 1) {
	  changeColourListItem.removeChild(xtraFieldPara);
  }//end if (xtraField ===1)
  changeColoursWin.setAttribute('class','hidden');
	  prefWindow.setAttribute('class','showing');
	  displayData();
  };//end cancelChangeColorsBtn.onclick
  
  
  //choose colors
  chooseColorBtn.onclick = function () {
		  saveBtn.setAttribute('class', 'colorBtn');
		//code for done here
		changeColoursWin.removeChild(doneBtn);
	changeColoursWin.removeChild(defaultBtn);
  changeColoursWin.removeChild(fontColourBtn);
 changeColoursWin.removeChild(chooseColorBtn);
changeColoursWin.removeChild(cancelChangeColorsBtn); 

  if (xtraField === 1) {
	  changeColourListItem.removeChild(xtraFieldPara);
  }//end if (xtraField ===1)
  
 dbNameInfo.textContent = dbName;
 chooseColoursWin.appendChild(dbNameInfo); changeColoursWin.setAttribute('class','hidden');
  chooseColoursWin.setAttribute('class','showing');
  
  //equate colors to selector choices
//   const noteFrameColor = document.querySelector('#noteFrame');
// const noteTitleColor = document.querySelector('#noteTitle');
// const firstDataFieldColor = document.querySelector('#firstDataField');
// const secondDataFieldColor = document.querySelector('#secondDataField');

noteListItemColour = noteFrameColor.value;
noteTitleColour = noteTitleColor.value;
bodyColour = firstDataFieldColor.value;//notes first field
xtraFieldColour = secondDataFieldColor.value;//notes second field
fontColour = notesFontColor.value;

  //equate colors to selector choices
  doneChooseColorsBtn.onclick = function() {
	  
	  //this saves altered colors after choosing!
	  noteListItemColour = noteFrameColor.value;
noteTitleColour = noteTitleColor.value;
bodyColour = firstDataFieldColor.value;//notes first field
xtraFieldColour = secondDataFieldColor.value;//notes second field
fontColour = notesFontColor.value;
	  changeColoursWin.removeChild(saveCurrentBtn);
	  changeColoursWin.removeChild(restoreSavedBtn);
	  
	  saveBtn.setAttribute('class', 'colorBtn');
	  changeColoursWin.setAttribute('class','hidden');
	  chooseColoursWin.setAttribute('class','hidden');
	  prefWindow.setAttribute('class','showing');
	  displayData();
  };//end doneChooseColorsBtn.onclick
  displayData();
};//end chooseColorBtn.onclick
  //choose colors
  
  
 //code for SAVE CURRENT and RESTORE SAVED  colors
 
 saveCurrentBtn.onclick = function (){
	 restoreSavedBtn.disabled = false;
	 restoreSavedBtn.setAttribute('class','colorBtn');
		savedCurrentnoteListItemColour = noteListItemColour;
	 savedCurrentnoteTitleColour = noteTitleColour;
	 savedCurrentbodyColour = bodyColour;
	 if(xtraField === 1) {
	 savedCurrentxtraFieldColour = xtraFieldColour;
	  }//end if xtraField = 1
	  savedCurrentfontColour = fontColour;
	 
	 alert('The CURRENT background colours have been SAVED! Tap the RESTORE SAVED button if you want to revert back to these saved colours.');
		//do I need if xtraField = 1??	saveCurrentBtn.setAttribute('class','colorBtn');
			//displayData();
			
		}; //end saveCurrentBtn.onclick
	
	restoreSavedBtn.onclick = function (){
	 noteListItemColour = savedCurrentnoteListItemColour;
	 noteTitleColour = savedCurrentnoteTitleColour;
	 bodyColour = savedCurrentbodyColour;
	 if(xtraField === 1) {
		xtraFieldColour = savedCurrentxtraFieldColour; 
	 }//end if xtraField = 1
	 fontColour = savedCurrentfontColour;
	 
	 //collect backgrd.styles 
changeColourListItem.style.backgroundColor = savedCurrentnoteListItemColour;
changeColourNoteTitle.style.backgroundColor = savedCurrentnoteTitleColour;
changeColourBody.style.backgroundColor = savedCurrentbodyColour;
if(xtraField === 1) {
xtraFieldPara.style.backgroundColor = savedCurrentxtraFieldColour;
	}//end if xtraField === 1
changeColourListItem.style.color = savedCurrentfontColour;
//collect backgrd.styles
	restoreSavedBtn.setAttribute('class','tdEdit');
	 alert('The SAVED background colours have been RESTORED! Tap the DONE button if you want to revert back to these saved colours.');
	 
	doneBtn.setAttribute('class','colorBtn');
	 
		//do I need if xtraField = 1??	saveCurrentBtn.setAttribute('class','colorBtn');
			//displayData();
			
		}; //end restoreSavedBtn.onclick	
		
  //code for SAVE CURRENT and RESTORE SAVED  colors
		
  //need random function in the change colour section
  function random(number) {
        return Math.floor(Math.random()*number);
	}//end curly brace of function random
	
}//end curly bracket function changeColours
		//end function changeColours
	
	//start function addField from addFieldBtn.onclick via settings.preferences window
	function addField () {
//code added Sept13 to add a cancel button to the addField window
let cancelAddFieldBtn = document.createElement('button');
      cancelAddFieldBtn.textContent = 'CANCEL';
      addFieldWin.appendChild(cancelAddFieldBtn);
	//  addFieldWin.appendChild(doneRelabelBtn);
	//code added above Sept13 to add a cancel button 
	if(dbTableName.value.includes("creatingDB")) {
	addFieldWin.removeChild(cancelAddFieldBtn);	
	}//end if(dataBaseName.includes("creatingDB"))
		
		
		const enterNewFieldName = document.querySelector('#newFieldName');
		const confirmNewFieldName = document.querySelector('#confirm');
		displayDataBtn.setAttribute('class','colorBtn');
		
		if(newDBGuidance) {
			displayDataBtn.setAttribute('class','borderBlink');
			newDBGuideP.setAttribute('class','attentionBtn');
			}//end if(newDBGuidance)
	//color save btn yellow so user knows to save xtraField variable now = 1	prefWindow.setAttribute('class','hidden');
	saveBtn.setAttribute('class', 'colorBtn');
	console.log("In addField function: newDBGuidance = " + newDBGuidance + "newDBflag = " + newDBflag);
	
	//Aug25 make prefbtn green so user is directed to prefs after creating first record of db
	console.log("at make pref btn green");
	console.log("In wanting to restore to status quo (make pref btn green): newDBGuidance = " + newDBGuidance + " newDBflag = " + newDBflag);
if (newDBGuidance === undefined && !newDBflag && xtraField === 0) {
addNoteBtn.setAttribute('class','attentionBtn');
  addNoteBtn.disabled = false;
  settingsBtn.setAttribute('class', 'normalBtn');//preferences
}//end if (newDBGuidance === undefined && !newDBflag && xtraField === 0) {
	//make prefbtn green so user is directed to prefs after creating first record of db…reset back to status quo Aug25
	
	
	
	
	//do I need to add xtraField === 0 condition here too? Aug 25 2021
	if (newDBGuidance && !newDBflag) {
		newDBGuideP.textContent = "When creating a new database, after tapping the DONE button, return to the first record and tap EDIT (highlighted GREEN) to enter data into the second Notes data field. Finally Tap the main menu TABLE button..(It will be flashing). Your new database is created! Remember to return to Preferences to enable 'Show Extra Field'. THE LAST PART OF THE PROCESS CREATES THE TABLE FOR THE NEW DATABASE. THIS MUST BE DONE BEFORE ADDING ANY NEW RECORDS! (Follow the flashing prompt buttons.)";
		prefWin.removeChild(newDBGuideP);
		addFieldWin.appendChild(newDBGuideP);
	//added addFieldWin to prefWin group in CSS to make room for newGuideP
	}//end if newDBGuidance && !newDBflag
	
		addFieldWin.setAttribute('class','showing');
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	addFieldWin.style.backgroundColor = "black";
	addFieldWin.style.color = "white";
	newDBGuideP.style.color = "black";
} else {
	addFieldWin.style.backgroundColor = "#eee";
	addFieldWin.style.color = "black";
	newDBGuideP.style.color = "black";
}//end if else screenDark
	
		//js code for addField here
		
	//	const enterNewFieldName = document.querySelector('#newFieldName');
	//	const enterNewFieldData = document.querySelector('#newFieldData');
		enterNewFieldName.addEventListener('input', function () {
			
			//flag to highlight Done btn if user enteres new name
			highlightDoneBtn = true;
			//alert('in addField newFieldName = ' + enterNewFieldName.value);
			newFieldName = enterNewFieldName.value;
		confirmNewFieldName.textContent = 'New NOTES data Field name entered is ' + newFieldName;
			//alert('newFieldName = ' + newFieldName);
			
			
	// });//end enterNewFieldName.onsubmit
	 
	 
	/*	enterNewFieldData.onsubmit = function () {
			xtraFieldData = enterNewFieldData.value;
		};//end enterNewFieldData.onsubmit */
		//finished with addField
		//let doneRelabelBtn = document.createElement('button');//made global
		
      doneRelabelBtn.textContent = 'DONE';
	   // if (highlightDoneBtn) {
	   
		//doneRelabelBtn.setAttribute('class','attentionBtn');
		 doneRelabelBtn.setAttribute('class','borderBlinkGrn');
		 //resetdisplayDataBtn back to normal Nov28
		 //nope not here!
		//displayDataBtn.setAttribute('class','colorBtn'); 
	//	 highlightDoneBtn = false;
	// }//end if highlightDoneBtn
      addFieldWin.appendChild(doneRelabelBtn);
	  
	 const rerunNotice = document.querySelector('#resetAddField');
	  rerunNotice.textContent = 'Tap DONE when finished.';
	  doneRelabelBtn.onclick = function () {
		  doneRelabelBtn.setAttribute('class','normalBtn'); 
		  //code for done here
		//get app code to rerun?!!
	//	alert('newFieldName = ' + newFieldName);
	xtraField = 1;
	//ver = 2;//commented out in fileNamesTableNotesVer21 ?? Not sure of its purpose????Apr4 because early on addField reset the objectStore, but I changed that so there is always an xtraField, but it contains the admin record data for first record. So onupgradeneeded never runs here now so I commented out the appropriate code including verb= 2 which was designed to force onupgradeneeded
		  addFieldWin.removeChild(doneRelabelBtn);
		  highlightDoneBtn = false;
	if(!(dbTableName.value.includes("creatingDB"))) {
		   addFieldWin.removeChild(cancelAddFieldBtn);
		}//end if(!(dbTableName.value.includes("creatingDB")))  
		  
	if (newDBGuidance && !newDBflag) {
		newDBGuideP.textContent = "";
		addFieldWin.removeChild(newDBGuideP);
		
		//will set newDBGuidance = false in new table code section
		newDBGuidance = true;
		//alert("Remember to  create the table for the new database BEFORE ADDING ANY NEW RECORDS!");
		
		//disable ADD NOTE and activate TABLE
	addNoteBtn.setAttribute('class','normalBtn');
  addNoteBtn.disabled = true;
  settingsBtn.setAttribute('class', 'normalBtn');//preferences	
  tableScreenBtn.setAttribute('class','attentionBtn');
  	tableScreenBtnGrn = true;//flag used in saveVariables
  if(newDBGuidance) {
	  alert('Next tap EDIT (highlighted Green) in the NOTES window when it appears, to enter data in the SECOND DATA FIELD of Notes, then AFTER DOING THIS, tap TABLE (flashing) in the Main menu!');
 // NotesEditBtn.setAttribute('class','tdEdit');
 NotesEditBtn.setAttribute('class','borderBlinkGrn');
}//end if(newDBGuidance)

  //ReferenceError: Can't find variable: NotesEditBtn so make global
	//ReferenceError: Can't find variable: NotesEditBtn	
displayDataBtn.click();//added Feb12 for auto .click		
	}//end if newDBGuidance && !newDBflag	 
	 addFieldWin.setAttribute('class','hidden');//change back to hidden!!!
	 //commented out hide pref window here so user can tap reset display after relabelling secondary field Marh 21
	 //prefWindow.setAttribute('class','hidden');//change back to hidden
	// displayData();//to reset display after added field Mar27 this line is present in fileNamesTableNotesVer21%


//I THINK I SHOULD REMOVE ALL CODE FROM HERE DOWN APRIL8 2021

	
// 	  //code to reset database with new field
// 	  let request = window.indexedDB.open(dataBaseName, ver); //seems to then go to start of code ? to onupgradeneeded??
// 	  request.onerror = function() {
//   console.log('Database failed to open');
// };
// request.onsuccess = function() {
//   console.log('Database opened after addField successfully');
   
// db = request.result;
// //why do I need displayData below. does it cause a repeat display of record 1?.?
// displayData();
// };//end request.onsuccess handler function .. a success event has triggered the success callback; 
// request.onupgradeneeded = function(e) {
	 
// let db = e.target.result;
// let objectStore = db.createObjectStore(objectStoreName, { keyPath: 'id', autoIncrement:true });
// objectStore.createIndex('title', 'title', { unique: false });
  
//   //addind date of note creation
//   objectStore.createIndex('created', 'created', { unique: false });
//   //end code for adding date created
//   objectStore.createIndex('body', 'body', { unique: false });
//   //CODE FOR xtraField basically substituting xtraField for body
//   if (xtraField===1) {
// 	  objectStore.createIndex('xtraField', 'xtraField', { unique: false });
//   }//end if xtraField
//    //createIndex() takes an optional options object that refines the type of index that you want to create
 
   
//    //PLAN FOR XTRA FIELD: Create xtraField (body), xtraField (body). use if xtraField true create a string with first line fieldName rtn then data input from entry. version number will be set to 2 to trigger onupgradeneeded

//   console.log('Database setup after addField complete');
//   //why do I need displayData here?
//   displayData();
// };//end request.onupgradeneeded handler

// //addData;//creates newItem object

//I THINK I SHOULD REMOVE ALL CODE FROM HERE UP APRIL 8 2021




  };//end doneRelabelBtn.onclick
  
   });//end enterNewFieldName.onsubmit  
 

 //more cancel addField code
cancelAddFieldBtn.onclick = function () {
	addFieldWin.removeChild(cancelAddFieldBtn);
	if(highlightDoneBtn){
		addFieldWin.removeChild(doneRelabelBtn);
		highlightDoneBtn = false;
	}//end if 
	//addFieldWin.removeChild(doneRelabelBtn);
saveBtn.setAttribute('class', 'normalBtn');	addFieldWin.setAttribute('class','hidden');
	
	
};//end cancelAddFieldBtn.onclick
//end cancel addField
		
}//end curly bracket function addField
		//end function addField
		
//view creation date option set
function viewCreationDate () {
	//dateP.style.color = 'black';
	//alert('in viewCreationDate after creationDateBtn.onclick');
	//dateColorBtn declared at top of code
	//const dateColorBtn = document.createElement('button');
	//if (dateColorBtn) {prefWindow.removeChild(dateColorBtn);}
dateColorBtn.textContent = 'Toggle Date Colour';
//notifyP.appendChild(dateColorBtn);
	if (!viewDateWritten) {
	viewDateWritten = true;//tell dateP to display in displayData()
	creationDateBtn.textContent = 'Hide Creation Date';
	//let notifyP = document.createElement('p');
	notifyP.textContent = "Creation dates will now be visible..Choose colour.";
	prefWindow.appendChild(notifyP);
	prefWindow.appendChild(dateColorBtn);
	doneOnce = 1;
	}//end if !viewDataWritten
	else if (viewDateWritten) {
		viewDateWritten = false;
		creationDateBtn.textContent = 'Show Creation Date';
	
	notifyP.textContent = "Creation dates will now be hidden";
	displayData();
	//line below gives error object can not be found here but program still works with it here. also works after removing it!
	//prefWindow.removeChild(dateColorBtn);
	
	/*This code to change color of creation date*/
		prefWindow.appendChild(notifyP);
	/*	if (doneOnce === 1) {
		prefWindow.removeChild(dateColorBtn);
	}//end if doneOnce */
		//prefWindow.removeChild(dateColorBtn);
	}//end else if
	
	dateColorBtn.onclick = dateColor;
	
		function dateColor () {
		
		if (boggle) {
			dateShade = "white";//dateP inWHITE displayData
			
			dateColorBtn.textContent = 'Date Colour -> Black';
			boggle = false;
			notifyP.textContent = "Creation dates will now be visible in white.";
			displayData();
		} else if (!boggle) {
			dateShade = "black";//BLACK
		
			dateColorBtn.textContent = 'Date Colour -> White';
			boggle = true;
			notifyP.textContent = "Creation dates will now be visible in black.";
			displayData();
		}//end else if
		
		displayDataBtn.setAttribute('class', 'colorBtn');
	}//end function dateColor
	//prefWindow.removeChild(dateColorBtn);
	//if remove btn here it never appears!
	//put code to redisplay notes here after choosing view creation date or not-- NOT; see line 634

  }//end function viewCreationDate
  
if(dbTableName.value.includes("creatingDB")) {
showExtraField = 1;//force always show extra field otherwise may lose ability to show extra field if there is no data in it? Added Feb13 2023
	addFieldBtn.click();//click function 6
	//addNoteBtn.click();
}//end function if(dbTableName.value.includes("creatingDB"))

if(newDBflag) {renameBtn.click();}//added Feb11 2023 to simulate .click() click function 2	

}//end options function ...  all code using const variables including change colour and addField has to be included in the pref options function so variables are identified

//end preferences window section

//add note section variables declared in menu section ..from main menu

changeMonthBtn2.onclick = changeMonthBudgetSheet;

addNoteBtn.onclick = function () {
	console.log('At addNoteBtn.onclick: dbName = ' + dbName + 'newDBflag = '+ newDBflag + 'newDBGuidance = ' + newDBGuidance);
	
	showTable.setAttribute('class','hidden');
	//
	//if user taps add note btn before a database has been selected!
	//newDBGuidance shuold be true if going through create new db process
	//At Add Note in createNew db process line 3864
	//At addNoteBtn.onclick: dbName = undefinednewDBflag = falsenewDBGuidance = true
	if(dbName === undefined && !newDBflag && !newDBGuidance) {
		alert('No database has been selected! Select or create a database to make ADD NOTE available.');
		
		return;
	} //end if dbName===undefined
	
	//fix loop hole of table screen getting messed up if user adds new note prior to first initialization of table
	
	if(DTBtnTappedOnce ===0 && tableExists && !(dbTableName.value.includes("creatingDB"))){
		alert('The pre-existing main table has to be initialized first before adding a new note! Tap the DISPLAY TABLE button.');
		tableScreenOptions();
	}//end if if(DTBtnTappedOnce ===0 & tableExists)
//saveBtn.disabled = false;//change back to false remove if messed up
	counter = counter + 1;

console.log('at addNoteBtn.onclick');

//createNewDBGuide
//for guidance creating newDB
if(newDBGuidance) {
newDBGuideP.textContent = "After entering the first record's title and text for NOTES' first data segment', tap the 'Create new record' button. When the list of database names appears, tap the green flashing database name ' " + dbTitle.textContent + "' to reload it, and continue the process. The first record will display with a flashing green PREFERENCES button. Tap PREFERENCES to continue. \n IF YOU ARE OFFLINE, YOU WILL GET A LOAD FAILED ERROR. IN THIS CASE JUST SHUT DOWN DOUGIEBASE AND RESTART.";
addNoteWindow.appendChild(newDBGuideP);
// settingsBtn.setAttribute('class','borderBlinkGrn');//was attentionBtn
addFieldBtn.setAttribute('class','borderBlink');
//At addNoteBtn.onclick: newDBGuidance = true newDBflag = false xtraField = 0
addNoteBtn.setAttribute('class','normalBtn');
}//end if newDBGuidance

//trying to fix secondary field input from showing in sitation where repeating a CreateNewDB
if (newDBGuidance && xtraField === 0 && instructionPxtraFieldData.textContent !== "") {
	addNoteWindow.removeChild(inputXtraFieldData);
	instructionPxtraFieldData.textContent = "";
	
}//end instructionPxtraFieldData.textContent !==""

// //AUG 25 make prefbtn green so user is directed to prefs after creating first record of db
// console.log("at make pref btn green");
// console.log("In wanting to restore to status quo (make pref btn green): newDBGuidance = " + newDBGuidance + " newDBflag = " + newDBflag);
// if (newDBGuidance === undefined && !newDBflag && xtraField === 0) {
// addNoteBtn.setAttribute('class','normalBtn');
//   addNoteBtn.disabled = true;
//   settingsBtn.setAttribute('class', 'attentionBtn');//preferences
// }//end if (newDBGuidance === undefined && !newDBflag && xtraField === 0) {
// 	//make prefbtn green so user is directed to prefs after creating first record of db

//end for guidance creating newDB

//createNewDBGuide
addNoteWindow.setAttribute('class','showing');
//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	addNoteWindow.style.backgroundColor = "black";
	addNoteWindow.style.color = "white";
} else {
	addNoteWindow.style.backgroundColor = "#eee";
	addNoteWindow.style.color = "black";
}//end if else screenDark

 //add date button here?
 addDateBtn = document.querySelector('#addDate');
	addDateBtn.onclick = function (e) {
		addDateBtn.disabled = true;
//had to add let for let date = to avoid assign to read only error
//date already declared
	// let date = new Date();
/*	 //add code to remove GMT PDT from date here remove this section if messed up
	 let string =
	 alert(string);
	  //remove this section if messed up
	*/ 
	 
	 noteDate = true;
	 alert(date);
};//end addDateBtn.onclickBtn.onclick
/**/
 //CODE FOR XTRA FIELD INPUT FOR NEW NOTE
console.log("At addNoteBtn.onclick: newDBGuidance = " + newDBGuidance + " newDBflag = " + newDBflag + " xtraField = " + xtraField);
 if (xtraField===1 && !newDBflag) {

addNoteWindow.appendChild(inputXtraFieldData);
	instructionPxtraFieldData.textContent = 'Add data for ' +  newFieldName + ' here:';
	inputXtraFieldData.onsubmit = function () {
		xtraFieldData = inputXtraFieldData.value;
		//form.onsubmit (createnote button should now take you to addData()
	//Aug26 if creating newDB twice in a row the newDb gets the added field added before it should so remove from the last time Aug26
	addNoteWindow.removeChild(inputXtraFieldData);
	instructionPxtraFieldData.textContent = "";
	
	};//end inputXtraFieldData.onsubmit
 }//end if xtraField
 
 //END CODE FOR XTRA FIELD INPUT NEW NOTE
	cancelNewNoteBtn = document.querySelector('#cancelNewNote');
	if(dataBaseName.includes("creatingDB")) {
cancelNewNoteBtn.style.display = "none";
} else {
cancelNewNoteBtn.style.display = "unset";
	//deleteDataBase(dataBaseName);//added Feb20 to cover cancel of create new db at this juncture
	//settingsBtn.setAttribute('class','normalBtn');
	//resetVariables();//added Feb20
}//end if(dataBaseName.includes("creatingDB"))
	cancelNewNoteBtn.onclick = function (e) {
	 //added preventDefault to prevent keyboard from appearing after pressing cancel button.
		e.preventDefault();
		
	//for guidance creating newDB
	if(newDBGuidance) {
newDBGuideP.textContent = "";
addNoteWindow.removeChild(newDBGuideP);
newDBGuidance = false;
settingsBtn.setAttribute('class','normalBtn');
}//end if newDBGuidance flag
//end for guidance creating newDB



	addNoteWindow.setAttribute('class','hidden');
		};//end cancelNewNoteBtn.onclick
		
};//end addNoteBtn.onclick

//About Database section
aboutDBBtn.onclick = choices;

function choices () {
fileNamesWindow.setAttribute('class','hidden');//added Mar25 2023
	aboutDBBtn.disabled = true;
	const getMemoryBtn = document.querySelector('#getMemory');
	//const memoryWindow = document.querySelector('#memoryWindow');
	const getDocumentationBtn = document.querySelector('#documentation');
	// const viewSettingsBtn = document.querySelector('#viewSettings');//made global because it is referenced outside this scope
	const aboutDBInfoP = document.querySelector('#aboutDBInfoP');
	const versionInfoP = document.querySelector('#versionInfoP');
	
	const clearAboutDBWindow = document.querySelector('#clearAboutDBWindow');
	// const numberNotes = document.createElement('p');//made global because referenced outside this scope Dec24
	const memoryBtn = document.querySelector('#memory');
  const memoryWindow = document.querySelector('#memoryWindow');
  const whatMemory = document.querySelector('p#amtMemory');
  const calculation = document.querySelector('#calcMemory');
  // const whatsNewWindow = document.querySelector('#whatsNewWin');
  // const newUpdatesBtn = document.querySelector('#newUpdates');
	// const closeUpdateWindow = document.querySelector('#closeUpdateWindow');
	// const whatsNewInfoP = document.querySelector('#whatsNewInfoP');
	
//disable aboutDatabase button so that it can't be clicked again while showing the about database window

aboutDBWindow.setAttribute('class','showing');

//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	aboutDBWindow.style.backgroundColor = "black";
	aboutDBWindow.style.color = "white";
	aboutDBInfoP.style.color = "black";
	versionInfoP.style.color = "black";
	memoryWindow.style.color = "black";
} else {
	aboutDBWindow.style.backgroundColor = "#eee";
	aboutDBWindow.style.color = "black";
}//end if else screenDark


	getMemoryBtn.onclick = getMemory;//this function is in script section of main html file
	
	newUpdatesBtn.onclick = whatsNew;
	
	getDocumentationBtn.onclick = documentation;
	//view settings prior to setup causes blank page and error
	//alert('at view settings button..setup = ' + setup);
	if(setup===0) {viewSettingsBtn.disabled = true;
	} else if (setup===1 || setup===3) {
		viewSettingsBtn.disabled === false;
	}//end if setup
//trying to prevent viewSettings btn getting disabled if user taps aboutDB without a database being loaded Aug 17
if(dataBaseName === "" || dataBaseName === null) {
	viewSettingsBtn.disabled === true;
} else {
	viewSettingsBtn.disabled === false;
}
	
//CHANGE BACK TO viewSettings;	Apr10
	viewSettingsBtn.onclick = viewSettings;
	
	numberNotes.textContent = 'Number of Records in Database ' + dbName + ' = ' + counter;
	aboutDBWindow.appendChild(numberNotes);
	
	clearAboutDBWindow.onclick = function () {
		aboutDBWindow.removeChild(numberNotes);
	aboutDBBtn.disabled = false;
	//trying to prevent viewSettings btn getting disabled if user taps aboutDB without a database being loaded Aug 17
	viewSettingsBtn.disabled = false;
	aboutDBWindow.setAttribute('class','hidden');}; //end clearAboutDBWindow.onclick
	// }//end function choices MOVED FROM JUST BEFORE GETMEMORY FUNCTION SO GET MEMORY FUNCTION SEES DECLARED VARIABLES
	closeUpdateWindow.onclick = function () {
		whatsNewWindow.setAttribute('class','hidden');
	};//end closeUpdateWindow.onclick function
	
	function getMemory () {
	  //alert('in getMemory function');
  // const memoryBtn = document.querySelector('#memory');
  // const memoryWindow = document.querySelector('#memoryWindow');
  // const whatMemory = document.querySelector('p#amtMemory');
  // const calculation = document.querySelector('#calcMemory');
  memoryWindow.setAttribute('class','showing');
  //Check if screenDark mode
checkScreenMode();
if(screenDark) {
	memoryWindow.style.backgroundColor = "black";
	memoryWindow.style.color = "white";
	
} else {
	memoryWindow.style.backgroundColor = "#eee";
	memoryWindow.style.color = "black";
}//end if else screenDark
  
  memoryBtn.onclick = amtMemory;
  
 /* function help () {document.getElementById("percent").value = 'You are not running in Safari so memory capacity calculation is not available.';}
  */
  
  function amtMemory() {
	 if('storage' in navigator) {
		 alert('navigator.storage.estimate returns true!')
	 }else{alert('navigator.storage.estimate = no storage in navigator' )}
	 
  	  if('storage' in navigator && 'estimate' in navigator.storage) {
		 alert('about to calculate memory'); navigator.storage.estimate().then(function(estimate) {
  document.getElementById("percent").value =
      (estimate.usage / estimate.quota * 100).toFixed(2);
  });//end storageManagerEstimate	
  
  
  	  } else {
		  document.getElementById("percent").value = '(The browser currently is not supporting storage.estimate so memory capacity calculation is not available.)';
		  calculation.textContent = "Memory left function is not available, or the browser does not yet possess a storage Manager? To EXIT Tap the DONE BTN.";
  	  	
  	  }//end if storage in navigator
	  
	  
	 //done button to allow return to notes window .. just hide the memory window to go back to the aboutDBWindow
	  let doneMemoryBtn = document.createElement('button');
      doneMemoryBtn.textContent = 'DONE';
      memoryWindow.appendChild(doneMemoryBtn);
	  doneMemoryBtn.onclick = function () {
		 
		//get ready for next instance of viewing documentation
		memoryWindow.removeChild(doneMemoryBtn);
		calculation.textContent ="";
	
      
	  document.getElementById("percent").value = ''; memoryWindow.setAttribute('class','hidden');
		aboutDBWindow.setAttribute('class','showing');
		 };//end doneBtn.onclick
	 }//end amtMemory functionmemoryBtn.onclick 
 }//end function getMemory called from line640 in js file
 
 }//end function choices MOVED FROM JUST BEFORE GETMEMORY FUNCTION SO GET MEMORY FUNCTION SEES DECLARED VARIABLES Dec22
 
 function whatsNew () {
	 checkScreenMode();
if(screenDark) {
	whatsNewWindow.style.backgroundColor = "black";
	whatsNewWindow.style.color = "white";
	whatsNewInfoP.style.color = "black";
	newVersionInfoP.style.color = "black";
} else {
	whatsNewWindow.style.backgroundColor = "#eee";
	whatsNewWindow.style.color = "black";
}//end if else screenDark
	 aboutDBWindow.setAttribute('class','hidden');
	 aboutDBBtn.disabled = false;
	//trying to prevent viewSettings btn getting disabled if user taps aboutDB without a database being loaded Aug 17
	viewSettingsBtn.disabled = false;
	aboutDBWindow.removeChild(numberNotes);

	 whatsNewWindow.setAttribute('class','showing');
 }//end function whatsNew

function documentation () {
	const documentationWindow = document.querySelector('#documentationWin');
	const documentationHeading = document.querySelector('#documentationHeading');	documentationWindow.setAttribute('class','showing');
	
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	documentationWindow.style.backgroundColor = "black";
	documentationWindow.style.color = "white";
	documentationHeading.style.color = "black";
} else {
	documentationWindow.style.backgroundColor = "#eee";
	documentationWindow.style.color = "black";
}//end if else screenDark


	let doneBtn = document.createElement('button');
      doneBtn.textContent = 'DONE';
      documentationWin.appendChild(doneBtn);
	  doneBtn.onclick = function () {
		 
		//get ready for next instance of viewing documentation
		documentationWin.removeChild(doneBtn);
      	documentationWin.setAttribute('class','hidden');
//if coming from HELP btn (previous LOAD btn don't open aboutDBwindow because this locks program flow
	if(!fromHELP) {
	aboutDBWindow.setAttribute('class','showing');
	}//end if(!fromHELP)

  };//end doneBtn.onclick
	//documentation manual code goes here
	fromHELP = false;
}//end documentation function

//addDate function keep here until deciding if needed in edit note section
function addDate () {
	addDateBtn.disabled = true;
	date = new Date();
	noteDate = true;
	alert(date);
}//end date function


//probably can remove function saveUpdate
//end function saveUpdate

//second try saveVariables

function saveVariables () {
	//alert("Beginning function saveVariables ….tableID = "+ tableID + ".  Because of resetFromContacts function,  makeContactsTable = " + makeContactsTable + " … loadFromTableOptions = " + loadFromTableOptions +  ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + "  newTableSpecificVariables[tableID][1] = " + newTableSpecificVariables[tableID][1] + ".   newTableSpecificVariables[loadTableIndex][2] = " + newTableSpecificVariables[loadTableIndex][2] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex]);
	
//	alert("in saveVariables");
	
	//create newDB guidance
	// if (newDBflag) {
		
	// newDBGuideP.textContent = "Now ADD NOTE";	list.appendChild(newDBGuideP);
	// }//end if newDBFlag
		//create newDB guidance
	
	// 	if (tableExists) {
// 		copyOfTableArray = tableArray.slice();
//  copyOfTableTitle = tableTitle.slice();
// //copyOfFieldNamesArray = fieldNamesArray.slice();
// console.log('copyOfTableArray = ' + copyOfTableArray);
// console.log('copyOfTableTitle = ' + copyOfTableTitle);
// 	}//end if tableExists
	
	//setup = 1;
	//aboutDBBtn.disabled = false;
	//ReferenceError: Can't find variable: viewSettingsBtn
	//viewSettingsBtn.disabled === false;
	console.log('In saveVariables .. ')
	saveBtn.setAttribute('class', 'normalBtn');
	saveBtn.textContent = 'SAVED';
	if(tableScreenBtnGrn) {
		tableScreenBtn.setAttribute('class','borderBlink');
		//remove if messed up Mar6
		clearTableWindowEditBtn.setAttribute('class','borderBlink');
		
/*	if(newDBGuidance) {
		displayTableBtn.setAttribute('class','tdEdit');//added May25
	}//end if newDBGuidance
	*/
	
		tableScreenBtnGrn = false;
	}//end if tableScreenBtnGrn
	
	alert('Saving Variables. Tap OK/CLOSE to continue.');
	
	//SHOULD CODE HERE CHECK dbTableName ! Include .blocked? At line 7465
	if(!(dbTableName.value.includes("blocked"))) {
dataNotBackedUp = true;
	dataAltered = false;//flag to provide warning if data changed but not saved 
}//end if(!data.variable1.includes("blocked"))
	
	//dataNotBackedUp = true;
	//dataAltered = false;//flag to provide warning if data changed but not saved 
	//newItem might not have to be here??
	newItem = { title: xtraField,
		created: todayString, body: newFieldName };
	//keyPath.value = Number('variables');
 //created: new Date() changed to todayString
	//cursor.value.id = Number('variables');
//or try keyPath: 'variables'	
//or keyPath: Number('variables');

//FIRST activating then saving to 1st record of notes-variables

//repeat code to SAVE TABLE VARIABLES
//start one transaction to work on both _os..otherwise you get errors about transaction inactive etc
//IF COMMING FROM CREATENEW DATABASE, AND SAVE BTN IS TAPPED AS PER INSTRUCTION YOU GET THIS ERROR: NotFoundError: Failed to execute 'transaction' on 'IDBDatabase': One of the specified object stores was not found. BECAUSE I HAD NOT PUT 'dataBaseName' variable in transaction instead od 'notes-os' Apr 7
//In SaveVariables, doing transaction. objectStoreName variable = Stuffed Rabbits_os
console.log('In SaveVariables, doing transaction. objectStoreName variable = ' + objectStoreName);
//TypeError: undefined is not an object (evaluating 'db.transaction')
//alertflm("objectStoreName = " + objectStoreName);

//AFTER A CREATE NEW DB,(NEW Database) THEN RENAMING THE NEW DB, the alert reveals objectStoreName = Green Peppers_os!! …whoops!  So now if you do transaction below you are in the wrong database!!
let transaction = db.transaction([objectStoreName], 'readwrite');
//  let objectStoreV = transaction.objectStore('notesVariables_os');
  
  // requestV = objectStoreV.get(1);
  // requestV.onsuccess = function(event) {
	//   console.log('Now in onsuccess of saveTableVariables');
	otherVariablesArray = [tableExists,originalNumberRecords,nextFieldName,numberOfFields,numberOfDynamicFields,tableTitle,paraBody,displayXtraFieldData];
	if(setup===3) {
	prefVariablesArray = [viewDateWritten,dateShade,showExtraField,showScroll,centerTitle,tableDateTime,linkLabel,scrollTable,bkgrdImage,trigger,caseSensitive,includesSubstring];
	}//end if setup===3
		variable3 = showExtraField;
		
		//update tableVariablesArray only want to run once for initializing newly created db at first save setup=0 changes to 1 after transaction saved newDBGuidance changes toundefined after code re-run and you have to tap newly created db to continue..after add/relabel field newDBGuidance is back to true (newDBflag = false )..in second SAVE setup is now =1 ..but maybe should skip the initialization of the newtable variables a second time ????? Feb23..because newDBGuidance is true again. Maybeok to initialize twice??..a third save..after table is created 
if(newDBflag || newDBGuidance) {
//alertx("In saveVariables initializing newTable variables..setup =  " + setup);
//these lines altered comented out  Mar 21 v
//if(tableExists) {
	savedTablesArray.length = 0;
	newTableSpecificVariables.length = 0;
//}//end if(tableExists)
//savedTablesArray = [,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,];

//	newTableSpecificVariables = [-1,[],0],[-1,[],0],[-1,[],0],[-1,[],0],[-1,[],0],[-1,[],0],[-1,[],0],[-1,[],0],[-1,[],0],[-1,[],0];
	
//SHOULD I PUT [] in the assigned array above for the fieldNames array	date Feb23 AND SHOULD I PUT []around newTableSpecificVariables!! Because only 1 iteration of the 10 appears in the console notes

//ANOTHER OPTION: USE THE TWO RESET FUNCTIONS: redefinenewTableSpecificVariables(); and redefineSavedTablesArray();

redefinenewTableSpecificVariables();
//function above retains data from previous db
	newTableVariablesArray = [-1,[],false];
	
	//newTableVariablesArray = [-1,"CONTACTS",false];
	
} else {//end if newDBflag || newDBGuidance

newTableVariablesArray[0] = tableIndex;
newTableVariablesArray[1] = newTableNames; 
newTableVariablesArray[2] = tableListExists;
//changed loadTableIndex to tableID Feb28 2022

if(!deleteFromTableOptions) {
newTableSpecificVariables[tableID][0] = newTableEdit;//not using this variable as of Feb13
//got this error when in Victoria Restaurants database editing Telephone field changing it to TELEPHONE. Also in Family Day database
//TypeError: undefined is not an object (evaluating 'newTableFieldsArray.slice')
newTableSpecificVariables[tableID][1] = newTableFieldsArray.slice();
newTableSpecificVariables[tableID][2] = numberOfNewTableAddedFields;
	}//end if!deleteFromTableOptions = true;//flag indicates deletion of new table

}//end if else  newDBflag || newDBGuidance	

//alertx("saveVariables after [1] equated to newTableFieldsArray …… loadFromTableOptions = " + loadFromTableOptions + ".  makeContactsTable = " + makeContactsTable + ".  loadTableIndex = " + loadTableIndex + " tableID = " + tableID + ".  newTableSpecificVariables = " + newTableSpecificVariables + ".  savedTablesArray = " + savedTablesArray + ".  newTableVariablesArray[1] = " + newTableVariablesArray[1]+ ".  savedTablesArray.length = " + savedTablesArray.length + ". newTableSpecificVariables.length = " + newTableSpecificVariables.length);

console.log("saveVariables after [1] equated to newTableFieldsArray …… loadFromTableOptions = " + loadFromTableOptions + ".  makeContactsTable = " + makeContactsTable + ".  loadTableIndex = " + loadTableIndex + " tableID = " + tableID + ".  newTableSpecificVariables = " + newTableSpecificVariables + ".  savedTablesArray = " + savedTablesArray + ".  newTableVariablesArray[1] = " + newTableVariablesArray[1]+ ".  savedTablesArray.length = " + savedTablesArray.length + ". newTableSpecificVariables.length = " + newTableSpecificVariables.length);
//	var dataV = event.target.result;
//	ReferenceError: Can't find variable: variable3
//use if setup===0 so these object members are initialized to "0" only if this is a new db never setup before. Otherwise these variables will always be reset to initial values rather than the values you want to keep stored.
//if(setup===0) {//need to declare datav otherwise you get this error:TypeError: undefined is not an object (evaluating 'dataV.tableArray = tableArray')

//date nov23 make dataVObj contain prefVariables from the start even setup=0If setup-1 this meand prefVariable is empty because prefs have not been saved, but still need it setup for creating newdb..a save happens early in stage of creating newdb..so i added || setup = 0
if(setup===3 || setup === 0) {
	dataVobj = {
  tableArray: tableArray,
  fieldNamesArray: fieldNamesArray,
  otherVariables: otherVariablesArray,
  prefVariables: prefVariablesArray,
  variable3: variable3,
  savedTables: savedTablesArray,
  newTableVariables: newTableVariablesArray,
  tableSpecific: newTableSpecificVariables
 };//end declaration of dataV object if setup=1 as in an older previously created database that hasn't had prefs saved, then save dataVObj without preferences ariable OR SAVE WITH PREFSVARIABLE EMPTY AS DECLARED AT TOP OF PROGRAM?
} else {
	dataVobj = {
  tableArray: tableArray,
  fieldNamesArray: fieldNamesArray,
  otherVariables: otherVariablesArray,
//add prefVariablesArray anyway even if empty? Date Nov 23????

  variable3: variable3,
  savedTables: savedTablesArray,
  newTableVariables: newTableVariablesArray,
  tableSpecific: newTableSpecificVariables
};//end declaration of dataV object
	
}//end if setup===3
// }//end if setup===0
//assign data to the dataV object members prior to saving
//maybe need if gotName =1 make assignments below?
dataVobj.tableArray = tableArray;
	dataVobj.fieldNamesArray = fieldNamesArray;
	//save dbtable name
	dataVobj.otherVariables = otherVariablesArray;
	if(setup===3) {
		dataVobj.prefVariables = prefVariablesArray;
	}//end if setup===3
	dataVobj.variable3 = variable3;
	//alert("at dataVobj.savedTables = savedTablesArray which is : " + savedTablesArray);
	dataVobj.savedTables = savedTablesArray;
	dataVobj.newTableVariables = newTableVariablesArray;
	dataVobj.tableSpecific = newTableSpecificVariables;
	console.log('Tablevariables edited! dataVobj.tableArray now = '+ dataVobj.tableArray + "dataVobj.newTableVariables = " + newTableVariablesArray);
	console.log("in saveVariables: newTableSpecificVariables =  " + newTableSpecificVariables);
//Tablevariables edited! dataVobj.tableArray now = dataVobj.newTableVariables = -1,,false
//in saveVariables: newTableSpecificVariables =  -1,,0–should this be 10 of theses?
//	in saveVariables: newTableSpecificVariables =  false,CONTACT NAME,DATE,TELEPHONE,EMAIL,0,false,CONTACT NAME,DATE,TELEPHONE,EMAIL,0,-1,CONTACT NAME,DATE,TELEPHONE,EMAIL,0,-1,,0,-1,,0,-1,,0,-1,,0,-1,,0,-1,,0,-1,,0

	//alert("In saveVariables…newTableVariablesArray = " +newTableVariablesArray);
	//TransactionInactiveError: Failed to store record in an IDBObjectStore: The transaction is inactive or finished.
	//so I will repeat setting up transaction again here
	//return false;
	
	//ReferenceError: Can't find variable: requestUpdateV
	//I THINK THIS SHOULD READ 'var requestUpdateV = objectStoreV.put (dataV);' !!!!!!!	might this be the cause of the added admin records?before was objectStore not objectStoreV
	// var requestUpdateV = objectStoreV.put(dataV);
	  
	
 //   requestUpdateV.onerror = function(event) {
 //     // Do something with the error
	//  console.log('Whoops! ERROR! saving Table variables. Transaction now inactive!');
 //   };//end requestupdate.onerror
 //   requestUpdateV.onsuccess = function(event) {
 //     // Success - the data is updated!
	//  console.log("In requestUpdate.onsuccess of save TABLE Variables after put data in requestUpdate. The record is updated! showExtraField = " + showExtraField + " otherVariablesArray[1] = " + otherVariablesArray[1]);
 // }//end requestUpdate.onsuccess
	//  transaction.oncomplete = function() {
	// 	 console.log('Transaction completed: database TABLE variables modification finished. In saveVariables function..now opening notes_os');
	// 	 }//end transaction.oncomplete
	// }//end request.onsuccess
	// 	 //end code to SAVE TABLE VARIABLES



//now carrying on to activate and then save to 1st record of notes_os 

  
  let objectStore = transaction.objectStore(objectStoreName);
  
   request = objectStore.get(1);
   //above is asynchronous so it appears code returns to top and then getDatabaseNameeven though setup has not yet been set to 0 by saveVariables?
  request.onsuccess = function(event) {
	  console.log('Now in onsuccess of saveVariables');
	//original note in data variable
	var data = event.target.result;
	//create the tools for doing the edit
	//console.log('Will edit item # ' + data.id + ' ' + data.body);
	
		//setup = 1; moved to after data object assigned values if setup = 0 !!!!

	//setup = 1;
//variable2Array now declared at start ? should remove this??
   	variable2Array = [setup,noteListItemColour, noteTitleColour, bodyColour, xtraFieldColour, fontColour, tableExists];
	
	// if(data.title === undefined) {
	// 	alert('Database is initializing!' + data.title);
	// 	data.title = 'initialize';
	// 	data.created = 'initialize';
	// 	data.body = 'initialize';
	// 	data.variable1 = 'initialize';
	// 	data.variable2 = 'initialize';
	// 	var requestInitialize = objectStore.put(data);
	// 	requestInitialize.onsuccess = function () {alert('Database is initializing');}
	// }//end if data.title = undefined
	
	// 	const objectName = {
//   member1Name: member1Value,
//   member2Name: member2Value,
//   member3Name: member3Value
// };

// !!!!!code below if left without 0 condition,  causes save to add an extra administion window to bottom of display after each tap of the save button. 0 condition is added so it only runs if new uninitialized database.(setup = 0) Not tested. This is to avoid Type Error: data.body is not an object when evaluating data.body undefined!!!!
if (setup === 0) {
data = {
  title: xtraField,
  created: todayString,
  body: newFieldName,
  variable1: dbTableName.value,
  variable2: variable2Array,
  dataV: dataVobj
  };//end declaration of data object
}//end if setup =0
	
if(changeMonth) {
data.created = todayString;//to update creation date for a new budget sheet	THIS INFO ONLY APPEARS IN THE VIEW SETTINGS INFORMATION ABOUT THIS DATABASE. IT DOES NOT APPEAR IN THE DATE OF INDIVIDUAL NOTES RECORDS…THIS DATE IS ONLY CREATED WHEN THE RECORD ITSELF IS CREATED!?,!?,?,?,
}//end if changeMonth
    data.title = xtraField;
	data.body = newFieldName;
	//save dbtable name
	data.variable1 = dbTableName.value;
	
	//alertblk("data.variable1 = " + data.variable1);
	//data. arianle2
	//alert("In saveVariables: data.variable1 = " + data.variable1);
	//line below was ..  data.variable2t = setup;
	//to save setup variable as 1 you have to make variable2Array[0] = 1 prior to assigning new values to data.variable2

	// //allow for setup =3 this code changed as below to make createNewDB work Nov23
// if(setup === 3 && setup!==0) {
// 	variable2Array[0] = 3;//setup variable
// } else if (setup === 1) {
// 	variable2Array[0] = 1;
// }//end if setup ===3
	
	
// 	data.variable2 = variable2Array;
// 	data.dataV = dataVobj;
// 	if(setup===3) {setup=3;
// 	}else {
// 	setup = 1; //moved to after ? object assigned values if setup = 0 !!!!
// 	}//end if setup =3
	
	
	//allow for setup =3
if(setup === 3) {
	variable2Array[0] = 3;//setup variable
} else if (setup === 1 || setup === 0) {
	variable2Array[0] = 1;
}//end if setup ===3
	
//SETUP HAS TO = 1 or 3 for pickOldNew function to work if creating a new db Nov23	setup takes its value from variable2Array[0] in pickOldNew function

	data.variable2 = variable2Array;
	data.dataV = dataVobj;
	if(setup===3) {setup=3;
	}else {
	setup = 1; //moved to after data object assigned values if setup = 0 !!!!
}//end if setup =3
//alert("About to save! .. savedTablesArray after deletion is now " + savedTablesArray);
//alert("About to save dataVobj.savedTables which is : " + dataVobj.savedTables);

// REMEMBER AT THIS POINT MAKEcontactsTable and loadFromTableOptions are both false because of resetFromContacts call prior to a save!	
	console.log('dataBaseName_os variables edited! About to put (data) in next line of code. variables edited! Data.body (should be newFieldName) now = '+ data.body+ ' tableArray (data.dataV.tableArray) = ' + data.dataV.tableArray + ' variable3 (data.dataV.variable3) = ' + data.dataV.variable3);
	//variables edited! Data.body now = undefined
//TypeError: undefined is not an object (evaluating 'newTableSpecificVariables[loadTableIndex][1]')
	//alert("saveVariables just before put(data) after [1] equated to newTableFieldsArray …… loadFromTableOptions = " + loadFromTableOptions + ".  makeContactsTable = " + makeContactsTable + ".  loadTableIndex = " + loadTableIndex + " tableID = " + tableID + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + ".  newTableVariablesArray[1] = " + newTableVariablesArray[1]);
	

//	alert("saveVariables immediately prior to put(data) … … loadFromTableOptions = " + loadFromTableOptions +  ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + ".  savedTablesArray = " + savedTablesArray);
	//return false;
	//adding put statement because before an admin note was added to display after tap of save btn
	//request = objectStore.get(1);
	  var requestUpdate = objectStore.put(data);
	  
	
   requestUpdate.onerror = function(event) {
     // Do something with the error
	 console.log('Whoops! ERROR! Transaction now inactive!');
   };//end request.onerror
   requestUpdate.onsuccess = function(event) {
     // Success - the data is updated!
	 console.log("In requestUpdate.onsuccess of saveVariables .. dataBaseName_os, after put data in requestUpdate. The record is updated!");
	//displayData();
	 titleInput.value = '';
	 bodyInput.value = '';
	 inputXtraFieldData.value = '';
	 newTitle.value = '';//clear newTitle input 
 		};//end requestUpdate.onsuccess #2
			
//		}//end function changeVariables
	
	
  transaction.oncomplete = function() {
    console.log('Transaction completed: database variables and Table variables modification finished. This instance of transaction.oncomplete is after put (data) to notes_os. Transaction completed: database variables in dataBaseName_os, and Table variables in dataVobj. Modification finished. In saveVariables function..going to displayData. If coming from onupgradeneeded, after saveVariables, the first (admin) record will have been created, so there will be a cursor, so setup will be = 1. Note however that setup = 1 in the saveVariables code after assigning all the variables.');

	
	
	
	//trying to prevent repeat display of records REMOVE IF MESSED UP!!!!! |
while (list.firstChild) {
    list.removeChild(list.firstChild);
}
//remove above if it messes up!

//maybe need to make displayData below conditional on not having had a record deleted????Date: Dec 9 2020 see line 1066
//Left off here Dec 10 FIND WHERE DISPLAYDATA NEEDED AFTER RETURN TO HOME SCREEN,!!
if (!deleteTableRecord) {
	displayData();
}//end if !deleteTableRecord..to prevent repeat of end element if displayData runs concurrently twice?Date:Dec19 NEED THIS TO PREVENT REPEAT LISTING OF RECORDS IN displayData and increasing tableTitle.length after displayTable post a deleteItem..deleted table record

	};//end transaction oncomplete
	transaction.onerror = function() {
		console.log('Transaction not opened due to error');
	};//end transaction onerror
	
};//end request.onsuccess #1  

//code below runs addNote everytime there is a save until db name stripped of .creatingDB … SO will run after each save up until stripped..try changing newDBGuidance..probably simClick avoided this because of return when forced to run tableScreenOptions because of initialize table message?

 // if(dbTableName.value.includes("creatingDB")) {
	// //fromcreatingNewDb = false;//not used
	// addNoteBtn.click();//to automate click click function 5
 // }//end if(dbTableName.value.includes("creatingDB"))
 
 if(newDBGuidance) {
	//fromcreatingNewDb = false;//not used
	addNoteBtn.click();//to automate click click function 5
 }//end if(newDBGuidance)
 
//TURN ON BKUP WARNINGS IF SET ON IN PREFERENCES
//alertbkup("bkupAlertsFlag = " + bkupAlertsFlag);
//alert("After save - blockEdit = " + blockEdit + " loadFromTableOptions = " + loadFromTableOptions);

if(bkupAlertsFlag && !blockEdit && !newDBGuidance && !convertingOldFile) {//to allow backupBtn to appear if saving a new table edit .added !blockEdit to avoid scenario of tapping bkup before resetting a clearTableBtn in editing a new table. This also hides backup btn for new tables..maybe not what you want?

 //code for backup request
 backupBtn1.style.display = "unset";
 backupBtn2.style.display = "unset";
 //code for backup request
 } else {//end if bkupAlerts
 backupBtn1.style.display = "none";
 backupBtn2.style.display = "none";
 }//end if(bkupAlerts)  
 
}//end saveVariables

//search records code section

function searchRecords () {
	//error code to prevent search if no db selected Dec21
	if(dbName === undefined && !newDBflag) {
		alert('No database has been selected! Select or create a database to make SEARCH available.');
	//prefWindow.setAttribute('class','hidden');
		//getFileNames();
		return;
	} //end if dbName===undefined
	
	//includesSubstring = false;//not implemented!
//should I add a count to find record clicks to force clearing of resultList after so many elements appear to not allow btns to disappear off screen? Jan 22
let matchTDCell = "";
let gotIt = 0;//counter to keep track of number of hits in search if more than one
//if first run check that table has been initialized March 21 2021
// let hits[];//hits array used in display - highlight table has to be global
let x = 0;//hits index counter

if(DTBtnTappedOnce ===0 & tableExists && !makeContactsTable && !loadFromTableOptions){initializeTable();}
if (tableExists & tableTitle.length>originalNumberRecords || editNote) {
	alert('⚠️ Update and SAVE the table first prior to Search.');
	tableScreenOptions();
}//end if upDateNeeded

//code to allow for search window to fit in Landscape mode
	
	let searchWindowHeight = searchWindow.clientHeight;
	console.log('searchWindowHeight = ' + searchWindowHeight);
	
	if(searchWindowHeight == 620) {
		searchLandscapeP.textContent = "SCROLL UP ⬆️ TO SEE BOTTOM OF SEARCH WINDOW ";
	} else {
		searchLandscapeP.textContent = "";
		
	}//end if prefWindowHeight ==620

searchWindow.setAttribute('class','showing');
//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	searchWindow.style.backgroundColor = "black";
	searchWindow.style.color = "white";
} else {
	searchWindow.style.backgroundColor = "#eee";
	searchWindow.style.color = "black";
}//end if else screenDark

	const cancelSearchBtn = document.querySelector("#cancelSearch");
	cancelSearchBtn.onclick = function (){
	clearFoundRecordListFunc();	searchWindow.setAttribute('class','hidden');
	//resetFromContacts();
	//should this also go to RESET FROM CONTACTS FUNCTION?
		//THIS CODE WILL CLEAR HIGHLIGHT IF CANCEL NOT TRIED YET,!!!!!Feb 7 2021 maybe should be separate button on table screen?
	// 	refreshed = 1;
	// 	renewed = 1;
		
	// 	showTable.setAttribute('class', 'hidden');
	// 	while (STrows.firstChild) {
   // STrows.removeChild(STrows.firstChild);
	// 	}//end while

	// 	displayTable();
	// 	renewed = 0;
	// 	refreshed = 0;
		
	}//end cancelSearchBtn.onclick
	
	const clearSearchTitleBtn = document.querySelector("#clearSearchTitle");
	const searchTitleInput = document.querySelector('#inputSearchRecord'); //should this variable be  made global (at top of code) so it can be used br fullItemView major crash program stops running here????
	
	
	
	const searchForRecordBtn = document.querySelector('#searchForRecord');
	clearSearchTitleBtn.onclick = function () {
		searchTitleInput.value = "";
		searchRecords();//REMOVE IF MESSED UP JAN24 fixes repeat registration of addEventListener!
			}//end clearSearchTitleBtn.onclick
			
	const highLightTableBtn = document.querySelector('#viewRecordTable');
	highLightTableBtn.onclick = function(){
		highLightTableBtn.setAttribute('class','normalBtn');
		searchForRecordBtn.setAttribute('class','normalBtn');
		highlightTable();
	}//end function highlightTableBtn.onclick 
		
	//}//end highLightTableBtn.onclick
	
	//this code added June9
	searchTitleInput.onclick = function (){
		searchForRecordBtn.setAttribute('class','colorBtn');
	}//end function searchTitleInput.onchange
	//this code added June9
	
//probable need resultList to be a global variable?
//let resultList ;= document.querySelector("#result-list");	

//clear found records list
	const clearRecordListBtn = document.querySelector('#clearFoundList');
		
	//const liMatchedRecord = document.querySelector('#matchedRecord');//made global used in outside function clearFoundRecordListFunc
	const matchedRecord = document.createElement('li');
	const addP = document.createElement('p');
	//let caseSensitive = false;	//make global
	const caseIndicator = document.querySelector('#caseIndicator');
	if (caseSensitive && includesSubstring) {
		caseIndicator.textContent = "Search is CASE SENSITIVE and CONTAINS search phrase!";
	} else if (!caseSensitive && includesSubstring) {
		caseIndicator.textContent = "Search is NOT CASE SENSITIVE and CONTAINS search phrase.";
	} else if (caseSensitive && !includesSubstring) {
		caseIndicator.textContent = "Search is CASE SENSITIVE and SPECIFIC for Search Phrase !";
	} else if (!caseSensitive && !includesSubstring) {
		caseIndicator.textContent = "Search is NOT CASE SENSITIVE but SPECIFIC for Search Phrase.";
	}//end if caseSensitive

//LEFT OFF HERE JAN22 now need to make caseSensitive Btn!!	
console.log('caseSensitive = ' + caseSensitive);
	searchForRecordBtn.onclick = function () {	highLightTableBtn.setAttribute('class','attentionBtn');
		//remove if screw up..trying to prevent repeaT alerts after addEventListener registers more than once on target element. addP does help but not alwaysthe trick because a new element is created each time? Will keep for aesthetics. I think what happens is if you just clear the input and then enter another record for search, the record title is put in the same li element as before and a second addEventListener is added to this element. BUT if after entering the record title as input AND THEN go to table to see highlight OR go to view full record, the next record title that is searched for is put in a new addP and no extra addEventListener is registered. I think because searchRecordc() is called afresh when coming from table or viewFullNote. n So how to avoid clearing the input without going to table or viewFullWindow??Suggest disable clearInput Btn after a tap and Renable after tapping all the other" btns
		
		resultList.appendChild(addP);
		//remove above if screw up Jan 22 2021
	console.log('searchTitleInput = ' + searchTitleInput.value);
		let searchFor = searchTitleInput.value;
		searchFor = searchFor.trim();//added Jan6 2023 so a space at end of 1st field search does not mess up found item!
		//let searchedRecordTitle = [];
		if (!caseSensitive) {
			query = searchFor.toLowerCase();
		} else {
			query = searchFor;
		}//end if !caseSensitive
	console.log('query = ' + query);
	// let resultList = document.querySelector("#result-list");
	resultList.innerHTML.textContent = "";
	//TypeError: null is not an object (evaluating 'resultList.innerHTML = ""')
	// tableTitle.map(function(algo){
   //      query.split(",").map(function (word){
   // //Everytime the ‘if’ condition passes, we need to add the ‘algo’ to the result list in the html page. For this, we can create a DOM object of the list and update its ‘innerHTML’.  
   //WILL HAVE TO EXTRACT ARRAY TO BE SEARCHED AFTER cursor.value.I’d is extracted
   
   // console.log('tableTitle[1] = ' + tableTitle[1]);
   // let stringToSearch = tableTitle[1].toString();
   // console.log('stringToSearch = ' + stringToSearch);
   // let position = stringToSearch.indexOf('>');
   // console.log('position = ' + position);
   // searchedRecordTitle[1] = tableTitle[1].slice(position+1);
   // console.log('searchedRecordTitle[1] = ' + searchedRecordTitle[1]);
   // alert('stop here');
   //trim tableTitle of recordId so search entry at input will match
   //FOR CONTACTS TABLE tableTitle.length is sent to searchRecord..tableTitle array is not
   for(let i = 0; i < tableTitle.length; ++i) {
	 //strip off noteId so search will match query Use +1 because otherwise the < is included. If you add a space this should be 2?
	 //The string method slice() takes two arguments: the start index where you will start copying characters and the end index where the copying ends. The second argument character index is not included, which means when you copy a string's characters from index 1 to index 5, it will only copy from index 1 to index 4. Remember the string index starts at 0
	//FOR CONTACTS TABLE USE  tableArray[i][0] instead of tableTitle[i]Jan2 because there will be no > character
	//add || loadFromTableOptions ? It worked without loadFromTableOptions? BUT IF HITS>Table on a new table derived from a search of main db then tableArray[i][0] WILL CONTAIN A > so lets strip it out! MAY3 2022
	if(makeContactsTable || loadFromTableOptions) {
	
		if(tableArray[i][0].includes('>')) {searchedRecordTitle[i] = tableArray[i][0].slice(tableArray[i][0].indexOf('>')+2);}else{searchedRecordTitle[i]=tableArray[i][0];}
	
		//searchedRecordTitle[i]=tableArray[i][0];
		
	} else {//end if else makeContactsTable
	   searchedRecordTitle[i] = tableTitle[i].slice(tableTitle[i].indexOf('>')+2);
   }//end if else makeContactsTable
   
	   if (!caseSensitive) {
		   searchedRecordTitle[i] = searchedRecordTitle[i].toLowerCase(); 
	   }//end if !caseSensitive
   }//end for i
   
  // let matchedRecordIndex = searchedRecordTitle.indexOf(query);
  // if (caseSensitive) {
	  
  
  //  	matchedRecordIndex = searchedRecordTitle.indexOf(query);
  //  console.log('matchedRecordIndex = ' + matchedRecordIndex);
   
	// } //end if caseSensitive

	console.log('searchedRecordTitle = ' + searchedRecordTitle);
	console.log(' query = ' + query);
	 
	matchedRecordIndex = searchedRecordTitle.indexOf(query);
	console.log('matchedRecordIndex = ' + matchedRecordIndex);


   //if(algo.toLowerCase().indexOf(word.toLowerCase()) != -1){
	  // resultList.innerHTML.textContent = tableTitle[matchedRecordIndex];
	  //  resultList.innerHTML += `<li class="list-group-item">tableTitle[matchedRecordIndex]</li>`;
	  if (matchedRecordIndex === -1) {
	//changed query to searchTitleInput.value so the actual search input is shown..not the corrected lowercase input Date: Feb 11	 
//query = "Econami PNP "	
	//console.log("tableArray[2][10] = " + tableArray[2][10]);
	//In displayTable.  tableArray[2][10] = undefined
for(i = 0; i < tableTitle.length; ++i) {
	for (c = 0 ; c < fieldNamesArray.length; ++c) {
		matchTDCell = tableArray[i][c];
		if(matchTDCell === "" || matchTDCell === null || matchTDCell === undefined) {matchTDCell = "XXX"}//to prevent undefined is not an object when evaluating etc should this be "0" vrs 0 type mismatch????
		console.log("i = " + i + " matchTDCell = " + matchTDCell);
		if(!caseSensitive) {
			matchTDCell = matchTDCell.toLowerCase()
			//TypeError: matchTDCell.toLowerCase is not a function. (In 'matchTDCell.toLowerCase()', 'matchTDCell.toLowerCase' is undefined)
			//In displayTable.  tableArray[2][10] = undefined
		}//end if caseSensitive
		console.log("matchTDCell = " + matchTDCell);
		//matchTDCell = query;
		//trim() removes all white space from start and end of string
		
//currently defaults to includesSubstring = true No code written to switch flag in preferences trim will strip beginning and end spaces
if(includesSubstring) {
		if(matchTDCell.trim() === query.trim() || matchTDCell.includes(query)) {
			matchedRecordIndex = i;
			console.log("A hit! matchedRecordIndex = " + i);
			gotIt = gotIt + 1;
			//alert("stop gotIt = " + gotIt);
			
			hits[x]= i;
			x = x+1;
	//	} else {
	//		matchedRecordIndex = -1;
		}//end if matchTDCell=query
	}//end if(includesSubstring)	
	
if(!includesSubstring) {
	if(matchTDCell.trim() === query.trim()) {
			matchedRecordIndex = i;
			console.log("A hit! matchedRecordIndex = " + i);
			gotIt = gotIt + 1;
			//alert("stop gotIt = " + gotIt);
			
			hits[x]= i;
			x = x+1;
	//	} else {
	//		matchedRecordIndex = -1;
		}//end if matchTDCell=query	
	}//end if(!includesSubstring)		
		
		
	}//end of for c=1..changed to c = 0 Sept26 2021 so record title is included in substring search
}//end of for i=0

}//end of if (matchedRecordIndex === -1)


console.log("matchedRecordIndex = " +matchedRecordIndex);
if(makeContactsTable || loadFromTableOptions) {liMatchedRecord.textContent = "There are no notes for Contacts or new Tables from searched records.";
}else{liMatchedRecord.textContent = "If record containing search phrase found it will appear below:"}//end if makeContactsTable

if(matchedRecordIndex === -1) {
	liMatchedRecord.textContent = searchTitleInput.value + " .. Record  not found";
	//NotFoundError: The object can not be found here.	  resultList.removeChild(matchedRecord);
	  }//end if matchedRecordIndex = -1
	  // liMatchedRecord.textContent = tableTitle[matchedRecordIndex];
	  
//keep track of multiple hits. 
if(gotIt > 1) {
	alert("More than 1 hit for search phrase:  \n" + query + "\n Number of hits = " + gotIt + ". \n \nDougieBase scrolls to the last hit (highlighted) in the table.");
	gotIt = 0;
}//end if gotIt > 1
//keep track of multiple hits
//left off here Jan2 2022
//because I did not create tableTitle fot contacts use tableArray[matchedRecordIndex[0][]
if (makeContactsTable || loadFromTableOptions) {
	findRecord = tableArray[matchedRecordIndex][0];
} else {

	 findRecord = tableTitle[matchedRecordIndex];
  }//end if makeContactsTable else
  
	  console.log("findRecord = " + findRecord);
		matchedRecord.textContent = findRecord;
		


		//trying to prevent repeat alerts from repeat registering of addEventListener which happens if not found event occurs as first search
		//remove if (matchedRecordIndex !== -1) if screw up This prevents matchedRecord from appearing empty as record not found msg appears in matchedRecordLi
	if (matchedRecordIndex !== -1) {
		foundRecordsList = true;//flag to clear a prexisting foundRecordsList so that a fresh loaded db does not use an old foundRecordList June 18 2021
		resultList.appendChild(matchedRecord);
		}//end if (matchedRecordIndex !== -1)
		//record matched
		console.log('Record matched adding to foundRecordList..foundRecordsList = ' + foundRecordsList);
		
		//searchWindow.appendChild('matchedRecord');
		//TypeError: Argument 1 ('node') to Node.appendChild must be an instance of Node
		//ReferenceError: Can't find variable: $algo
		//experiment change resultList to matchedRecord
	//changed dblclick to click Oct5
	//ONLY DO ADDEVENTLISTENER IF NOT A CONTACTS TABLE
	if(!makeContactsTable && !loadFromTableOptions) {
	matchedRecord.addEventListener('click', function (e) {
			//remove if messes up tdying to prevent repeat registration of addEventListener
			
//should I remove the addEventlistener when highlightTable is tapped June1 2022???	

			resultList.appendChild(addP);
			//let once = true;
  // for (let i = 0;i < tableTitle.length; ++i) {
	//   if (searchedRecordTitle[i] === query) {
	//	   searchNote = tableTitle[i].splice(0,indexOf('<'));
			searchNote = findRecord.slice( 0,findRecord.indexOf('>'));
	console.log('searchNote = ' + searchNote);
		   fromSearchRecord = true;
		   fullViewItem();
		   //highlight in table in case you go to table after search
	//REMEMBER IF GOING TO FULLVIEWEDIT FROM A SEARCH OF A MAIN TABLE THAT THE fromSearchRecord variable is made true! Does it need to be made false so ewhere after that? Date June1 2022	  
	
		   
		   searchWindow.setAttribute('class','hidden');
		   
	  //match table highlight to double clicked item REMOVE IF MESSED UP
	  matchedRecordIndex = tableTitle.indexOf(findRecord);
 //  }//end for loop
 
 //code to prevent repeat alerts makes no difference
 console.log(this.className)           // logs the className of my_element
 console.log(e.currentTarget === this) // logs `true
 if (e.currentTarget) {
	//was dblclick Date: Oct5

	matchedRecord.removeEventListener('click', function (e) {
	 	
	 });
 }//end if e.currentTarget
 //end code to prevent repeat alerts
   },true);//end function addEventListener
   //true did not do anything
	   //remove if screws up!
	searchRecords();//REMOVE IF MESSED UP JAN24 fixes repeat registration of addEventListener! If re-entering query into input without any action on previous item in recordList   
  }//END if(!makeContactsTablej..so addEventListener is not added to a found contact which does not have a 'note'
}////end searchForRecoedBtn.onclick function

clearRecordListBtn.onclick = function() {
	console.log('At clearRecordListBtn.onclick');
	foundRecordsList = false;//flag to clear a prexisting foundRecordsList so that a fresh loaded db does not use an old foundRecordList June 18 2021
	while (resultList.firstChild) {
    resultList.removeChild(resultList.firstChild);
}//end while
console.log('Clearing the record list after clearRecordListBtn.onclick..foundRecordsList = ' + foundRecordsList);

liMatchedRecord.textContent = "If record found it will appear below: Tap record title to view its notes";
}//end clearFoundRecordLizt




//functions used in searchRecords function

//This will keep adding items to the list as the function is called. The items will keep stacking up. To avoid this, we need to truncate the list at beginningning of the function itself. So, finally your code should look like this.
}//END FUNCTION SEARCHRECORDS
	
	// Iterate through the array to linearly check each element if the entered words match the array elements. To check if it matches, you can use the Array.indexOf() function. If it returns -1 it doesn’t match. We need to call the indexOf() function f or each of the words the user enters. We can do that by using the split() and map() functions. Don’t forget to use String.toLowerCase() to ignore case sensitivity.

//  Don’t forget to use String.toLowerCase() to ignore case sensitivity.

function highlightTable () {
		fromSearchRecord = true;
	hitsTable = true//flag to relabel CONTACTS btn to create a searched hits table
//show CONTACTS btn to allow making a new table from a new table
if(loadFromTableOptions) {
emailBtn.style.display = "unset";
newTableFieldsBtn.style.display = "unset";
	}//end if loadFromTableOptions
	
		refreshed = 1;//to keep field titles from repeating use refresh=1 (same for if edit = 1)
		
		renewed = 1;//variable in refreshTable()to create header row in displayTable when coming from refrehTable ?? Might not need this
		searchWindow.setAttribute('class','hidden');
		showTable.setAttribute('class', 'showing');
		while (STrows.firstChild) {
   STrows.removeChild(STrows.firstChild);
}//end while
//put search phrase in top menu bar
flipMenu.textContent = " ✅ Search phrase: " + query;
$("#flip").css({"border-color": "red"});

//alertx("Highlight just tapped: about to go to displayTable..searchedHitsTableArray = " + searchedHitsTableArray + "number of Hits = " + hits);
console.log("Highlight just tapped: about to go to displayTable..searchedHitsTableArray = " + searchedHitsTableArray + "number of Hits = " + hits);

//set up scrollBtn in NOTES to scroll to a searched record JAN 6 2023
recordId = matchedRecordIndex;
scrollHere = true;//added Dec4
scrollBtn.textContent = "Scroll to Last \n record Searched";
//set up scrollBtn in NOTES to scroll to a searched record JAN 6 2023
//alert("recordId = " + recordId + ". scrollHere = " + scrollHere);

		displayTable();
		renewed = 0;
		refreshed = 0;
		if(hits.length>1) {hits.length = 0;}
		
//should this be hits.length>=1????Date June1 2022

	}//end function highlightTable
// flipMenu.textContent = "Click to show / hide TABLE MENU";

//end search records code section


//load code bypassed currently..not used..load btn now labelled HELP and is directed to documentation .. see loadBtn.onclick at top of program Sept17 2021
function load () {  
	if(saveBtn.textContent === 'SAVED') {
		saveBtn.textContent ='SAVE';
	}//end if saveBtn.textContent
//let noteId = Number('variables');

let transaction = db.transaction([objectStoreName], 'readwrite');
  //reference/put the activated 'notes-os' object store into the variable objectStore
  let objectStore = transaction.objectStore(objectStoreName);
 
let request = objectStore.get(1);
request.onsuccess = function(event) {
	//original note in data variable
	var data = event.target.result;
console.log('at request.onsucces in load function');
console.log('In LOAD...get(1) data.body = '+ data.body + 'newFieldName = ' + newFieldName);

xtraField = data.title;
newFieldName = data.body;

console.log('In LOAD...get(1) after assigment.. data.body = '+ data.body + 'newFieldName = ' + newFieldName);
//alert('newFieldName = ' + newFieldName + ' . The value of variable xtraField = ' + xtraField);
//get dbTableName

dbTableName.value = data.variable1;
variable2Array = data.variable2;
//alert(variable2Array);
setup = variable2Array[0];
noteListItemColour = variable2Array[1];
noteTitleColour = variable2Array[2];
bodyColour = variable2Array[3];
xtraFieldColour = variable2Array[4];
fontColour = variable2Array[5];
tableExists = variable2Array[6];//change to tableExists when needed!!!!!!
//unpack dataVobj

dataVobj = data.dataV;
tableArray = dataVobj.tableArray;
 fieldNamesArray = dataVobj.fieldNamesArray;
 otherVariablesArray = dataVobj.otherVariables;
if(setup===3) {
	prefVariablesArray = dataVobj.prefVariables;
	}//end if setup===3
 variable3 = dataVobj.variable3;
 savedTablesArray = dataVobj.savedTables;
 newTableVariablesArray = dataVobj.newTableVariables;
 newTableSpecificVariables = dataVobj.tableSpecific;
 //remove line below if doesn't work
 showExtraField = variable3;
 
 tableExists = otherVariablesArray[0];
 originalNumberRecords = otherVariablesArray[1];
 
 console.log('In LOAD dataVobj...get(1) otherVariablesArray[1] = '+ otherVariablesArray[1] + ' newFieldName = ' + newFieldName + ' showExtraField (dataVobj.variable3) now = ' + dataVobj.variable3);
 
 nextFieldName = otherVariablesArray[2];
 numberOfFields = otherVariablesArray[3];
 numberOfDynamicFields = otherVariablesArray[4];
 tableTitle = otherVariablesArray[5];
 paraBody = otherVariablesArray[6];
 displayXtraFieldData = otherVariablesArray[7];
 
 //END OF LOAD IN TABLE VARIABLES
 
//load in prefVariables

if(setup===3) {
viewDateWritten = prefVariablesArray[0];
dateShade = prefVariablesArray[1];
showExtraField = prefVariablesArray[2];
showScroll = prefVariablesArray[3];
centerTitle = prefVariablesArray[4];
tableDateTime = prefVariablesArray[5];
linkLabel = prefVariablesArray[6];
scrollTable = prefVariablesArray[7];
bkgrdImage = prefVariablesArray[8];
trigger = prefVariablesArray[9];
caseSensitive = prefVariablesArray[10];
includesSubstring = prefVariablesArray[11];
}//end if setup ===3

tableIndex= newTableVariablesArray[0];
tableListExists = newTableVariablesArray[2];
newTableNames = newTableVariablesArray[1];

newTableEdit = newTableSpecificVariables[loadTableIndex][0];
newTableFieldsArray = newTableSpecificVariables[loadTableIndex][1];
numberOfNewTableAddedFields = newTableSpecificVariables[loadTableIndex][2];
//end load in prefVariables

//can't find variable load error caused by curly brackett below!?!????..therefore commented out because its extra and should not be here..its further down

//};//end request.onsuccess !!!!!Lof objectstore get 1

//LOAD IN TABLE VARIABLES
//repeat code to LOAD TABLE VARIABLES
	
// 	let transactionV = db.transaction(['notesVariables_os'], 'readwrite');
//   let objectStoreV = transactionV.objectStore('notesVariables_os');
  
//   requestV = objectStoreV.get(1);
//   requestV.onsuccess = function(event) {
// 	  console.log('Now in onsuccess of getTableVariables in LOAD function');
// 	  //still have to create tableTitle, paraBody, and displayExtraFieldData arrays
// 	  //may not need to declare otherVariablesArray here because I did at start???!!!!
// 	otherVariablesArray = [tableExists,showExtraField,nextFieldName,numberOfFields,numberOfDynamicFields,tableTitle,paraBody,displayXtraFieldData];
// 	variable3 = "more variables here";
	
// 	var dataV = event.target.result;
// //I DON'T THINK I NEED TO DECLARE dataV variable here?	
// 	dataV = {
//   tableArray: tableArray,
//   fieldNamesArray: fieldNamesArray,
//   otherVariables: otherVariablesArray,
//   variable3: variable3
//  };//end declaration of dataV object
 
//  tableArray = dataV.tableArray;
//  fieldNamesArray = dataV.fieldNamesArray;
//  otherVariablesArray = dataV.otherVariables;
//  variable3 = dataV.variable3;
//  //assign data to the dataV object members prior to saving
//   //assign values to individual variables in from the otherVariablesArray
//  // otherVariablesArray = [tableExists,newFieldName,nextFieldName,numberOfFields,numberOfDynamicFields,tableTitle,paraBody,displayXtraFieldData,];
 
 
//  tableExists = otherVariablesArray[0];
//  showExtraField = otherVariablesArray[1];
 
//  console.log('In LOAD dataV...get(1) otherVariablesArray[1] = '+ otherVariablesArray[1] + 'newFieldName = ' + newFieldName);
 
//  nextFieldName = otherVariablesArray[2];
//  numberOfFields = otherVariablesArray[3];
//  numberOfDynamicFields = otherVariablesArray[4];
//  tableTitle = otherVariablesArray[5];
//  paraBody = otherVariablesArray[6];
//  displayXtraFieldData = otherVariablesArray[7];
 
//  //END OF LOAD IN TABLE VARIABLES
//END OF LOAD IN TABLE VARIABLES


//get saved dbTableName from previous Save by tapping the LOADbutton
document.getElementById("dbTableName").innerHTML = dbTableName.value;
displayData();
	};//end request.onsuccess of load in table Variables ?right place?
}//end load function

//build variable2 array
/*let 
   	variable2Array = [setup,noteListItemColour, noteTitleColour, bodyColour, xtraFieldColour, fontColour];
    */
//get database name
//getDataBaseNamefunctionfunction
function getDataBaseName (key,dataBaseName,objectStoreName) {  
	console.log('Arrived at getDataBaseName...setup = ' +setup);
	//alert("getDataBaseName….savedTablesArray[0] = " + savedTablesArray[0]);
	//OK HERE!
	return new Promise (function(resolve) {
        indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;
		
        var open = indexedDB.open (dataBaseName, 1);

        open.onsuccess = function () {
			console.log('Successfully opened database with name: ' + dataBaseName);
			
	//alert('In getDataBaseName function: Successfully opened database with name: ' + dataBaseName);
		//NotFoundError: Failed to execute 'transaction' on 'IDBDatabase': One of the specified object stores was not found.	
            db = open.result;
            tx = db.transaction([objectStoreName], "readwrite");
            var store = tx.objectStore(objectStoreName);
		console.log('Will now try to open key id 1 first record of its objectStore:  ' + objectStoreName);
		
            store.get(key).onsuccess =  function (event) {
				console.log('onsuccess of store get key 1 Should return data to loadTheDataBase event.target.result = ' + event.target.result);
			//testing REMOVE DISPLAYDATA
			getFileNamesSwitch=false;
				//displayData();
				//testing REMOVE DISPLAYDATA
                return resolve(event.target.result);
            }//end store get(key)
        }//end open.onsuccess function
		
		
		
		
		//onupgradeneeded function here
		open.onupgradeneeded = function (event) {
		                console.log ('in onupgradeneeded which means database is new..not found');
		
//alert("Should not be here unless creating a new db! backingMeUp = " + backingMeUp);

		let db = event.target.result;
		let objectStore = db.createObjectStore(objectStoreName, { keyPath: 'id', autoIncrement:true });
		objectStore.createIndex('title', 'title', { unique: false });
  
  //addind date of note creation
  objectStore.createIndex('created', 'created', { unique: false });
  //end code for adding date created
  objectStore.createIndex('body', 'body', { unique: false });
  //CODE FOR xtraField basically substituting xtraField for body
  
	  objectStore.createIndex('xtraField', 'xtraField', { unique: false });
  objectStore.createIndex('variable1', 'variable1', { unique: false });
  objectStore.createIndex('variable2', 'variable2', { unique: false });
  objectStore.createIndex('dataV', 'dataV', { unique: false });
  console.log('In onupgradeneeded. This means db_name not found and a new database is being created.');
  upgraded = 1;
  //code from setup =0
  redefineTableArray();
 // ReferenceError: Can't find variable: dataVobj so do I have to redefine dataV in upgrade needed for the new database?
 //DO I ALSO NEED redefineSavedTablesArray??
  //console.log('In upgradeneeded;will now go back to getDataBaseName() after creating the objectStore. dataVobj.tableArray = ' +dataVobj.tableArray);
  //need code here to move to TOP of view window so directions are visible
  if(!fromRestore) {
 dbTableName.value = 'Creating new Database. 1. RENAME database (again) and 2. ADD FIRST NOTE. When the file names list reappears Tap on name of newly created database to continue.';

//at this point the program stops because of undefined is not an object in evaluating data.variable1 and I tap SAVE ..then go to saveVariables
//scroll to top so directions for creating new db are visible
 topFunction();
 }//end if !fromRestore

document.getElementById("dbTableName").innerHTML = dbTableName.value;

	//data.variable1 = 'Creating new Database';
	//put automatic SAVE here if newDB.
	//saveVariables();
	
  
  addNoteBtn.setAttribute('class','normalBtn');
  addNoteBtn.disabled = true;
//  settingsBtn.setAttribute('class', 'borderBlinkGrn');//preferences was attentionBtn REMOVED FEB 12 2023 this caused preferences btn to flash during rename database when creating a new database!
  
   //code from setup =0
  //HAVE TO ADD : dataBaseName,objectStoreName
  //IS IT POSSIBLE THIS CAUSES TWO TRACKS OF PROGRAM IF SENDING BACK VIA CALL TO GETDATABASENAME VRS AN AUTOMATIC RETURN VIA ONUPGRADENEEDED ? Apr7
  if(!fromRestore) {
	getDataBaseName (1,dataBaseName,objectStoreName);
		               //reject ();// 2-2. Register reject
		      	}//end if!fromRestore	    
		
		
		  };//end request.onupgradeneeded handler
		            // 2-1. Asynchronous processing
			//onupgradeneeded function above
	
// store.get(key).onerror = function() {
// 		   dbTableName.value = 'Creating new Database. (store.get(key) errorn). In preferences, rename database and tap SAVE to initialize the database.';

// //at this point the program stops because of undefined is not an object in evaluating data.variable1 and I tap SAVE ..then go to saveVariables

// document.getElementById("dbTableName").innerHTML = dbTableName.value;
// addNoteBtn.setAttribute('class','normalBtn');
//   addNoteBtn.disabled = true;
//   settingsBtn.setAttribute('class', 'attentionBtn');
		   
		   
// };//end store.get(key).onerror			
			
    });//promise function resolve
}//end function getDataBaseName
	
//pickOldNew function	
function pickOldNew (data, dataBaseName) {
	variable2Array = data.variable2;
	setup = variable2Array[0];
//IF CREATING NEWDB SETUP SHOULD = 1 at this point but it does not…SETUP = 0!!!	Nov23
	
	console.log('Unpacking variable2Array .. variable2Array[0] = ' + variable2Array[0] + ' setup = '+setup);
	//setup should = 1 but it = 0 here when creating new db
	
	if (setup === undefined|| null) {setup = 0;}//end if setup = undefined

if (setup === 1|| setup === 3) {
dbTableName.value = data.variable1;

//alert("In pick-old-new: dataBaseName = " + dataBaseName + " data.variable1 = " + data.variable1 + " dbName = " + dbName);
//at this point the program stops because of undefined is not an object in evaluating data.variable1 and I tap SAVE ..then go to saveVariables

document.getElementById("dbTableName").innerHTML = dbTableName.value;

//alertx('now leaving notes code..just after dbTableName.value set to data.variable1.  data.variable1 = ' + data.variable1 +' dbTableName.value = ' + dbTableName.value);
//getsecond field name
//console.log('In pickOldNew()...setup is = 1.get(1) data.body = '+ data.body + 'newFieldName = ' + newFieldName);
//In pickOldNew()...get(1) after assignment to data.body = ChipnewFieldName = Chip
newFieldName = data.body;

//console.log('In pickOldNew()...get(1) after assignment to data.body = '+ data.body + 'newFieldName = ' + newFieldName);

xtraField = data.title;
//setup = data.variable2;
//load in values of data.variable2
//variable2Array = data.variable2;
//alert(variable2Array);
//error msg on opening an ."old" db
//TypeError: undefined is not an object (evaluating 'variable2Array[0]')
//setup = variable2Array[0];
//console.log('Unpacking variable2Array .. variable2Array[0] = ' + variable2Array[0] + ' setup = '+setup);
//if (setup === undefined) {setup = 0;}//end if setup = undefined
noteListItemColour = variable2Array[1];
noteTitleColour = variable2Array[2];
bodyColour = variable2Array[3];
xtraFieldColour = variable2Array[4];
fontColour = variable2Array[5];
tableExists = variable2Array[6];// hange to tableExists when needed
//unpack dataVobj
dataVobj = data.dataV;
//TypeError: undefined is not an object (evaluating 'dataVobj.tableArray')
 console.log('After dataVobj = data.dataV ..  dataVobj.tableArray = ' +dataVobj.tableArray);
 
/* if(dataVobj.hasOwnProperty('otherVariables')) {
	 alert("yes otherVariables exists!");
 } else {
	 alert("otherVariables not here!");
 }//end if dataVobj
 */
 
tableArray = dataVobj.tableArray;
console.log("tableArray = " + tableArray);
//alertx("tableArray = " + tableArray);

//mainDBArray = dataVobj.tableArray;//for error check savedOriginal
mainDBArray = tableArray.slice();//for error check savedOriginal
console.log("mainDBArray = " +mainDBArray);
//alertx("mainDBArray = " +mainDBArray);

 fieldNamesArray = dataVobj.fieldNamesArray;
 otherVariablesArray = dataVobj.otherVariables;
 if(setup===3) {
	  prefVariablesArray = dataVobj.prefVariables;
  }//end if setup===3
 variable3 = dataVobj.variable3;
 console.log("just retrieved variable3")
 
 
 //remove line below if doesn't work
 showExtraField = variable3;
 
 tableExists = otherVariablesArray[0];
 originalNumberRecords = otherVariablesArray[1];
// alert("originalNumberRecords = " + originalNumberRecords + " tableTitle.length = " + tableTitle.length);
 console.log('In setup=1 || 3 of pickOldNew(),  originalNumberRecords = otherVariablesArray[1] = '+ otherVariablesArray[1] + ' newFieldName = ' + newFieldName + ' showExtraField (dataVobj.variable3) now = ' + dataVobj.variable3);
 
 nextFieldName = otherVariablesArray[2];
 numberOfFields = otherVariablesArray[3];
 numberOfDynamicFields = otherVariablesArray[4];
 tableTitle = otherVariablesArray[5];
 paraBody = otherVariablesArray[6];
 displayXtraFieldData = otherVariablesArray[7];
 
 //unload newTableVariablesArray
/* tableIndex= newTableVariablesArray[0];
tableListExists = newTableVariablesArray[2];
newTableNames = newTableVariablesArray[1];
 */
 //END OF LOAD IN TABLE VARIABLES
 
 //load in prefVariables
 if(setup===3) {
 viewDateWritten = prefVariablesArray[0];
dateShade = prefVariablesArray[1];
showExtraField = prefVariablesArray[2];
showScroll = prefVariablesArray[3];
centerTitle = prefVariablesArray[4];
tableDateTime = prefVariablesArray[5];
linkLabel = prefVariablesArray[6];
scrollTable = prefVariablesArray[7];
bkgrdImage = prefVariablesArray[8];
trigger = prefVariablesArray[9];
caseSensitive = prefVariablesArray[10];
includesSubstring = prefVariablesArray[11];



//reset background image for each database date Nov11
// if(bkgrdImage) {
// 		bkgrdImageBtn.textContent = 'Clear Background Image';
// 		bodyImage.setAttribute('class','bkgrdImage');
// 	} else {
// 		bkgrdImageBtn.textContent = 'Show background image';
// 		bodyImage.setAttribute('class','noBkgrdImage');
// 	}//end if else bkgrdImage
	
}//end if setup===3

if(newDBflag) {
	redefinenewTableSpecificVariables();
	redefineSavedTablesArray();
	
}//end if(newDBflag)

if(dataVobj.hasOwnProperty('tableSpecific')) {
//alertx("> dataVobj.tableSpecific is intact!");
	newTableSpecificVariables = dataVobj.tableSpecific;
tableIndex = newTableSpecificVariables[loadTableIndex][0];
//newTableFieldsArray will be assigned the newTableFieldsArray values for whatever table is represented by loadTableIndex at the time of the load…which will usually be loadTableIndex = 0. So prior to every save need to make sure newTableFieldsArray reflects the proper values for the correct newTable as referenced by loadTableIndex.

newTableFieldsArray = newTableSpecificVariables[loadTableIndex][1];
//alertx("dataVobj.tableSpecific =  " + dataVobj.tableSpecific + ".  newTableFieldsArray for new table #[" + loadTableIndex +"] = " +  newTableFieldsArray);
numberOfNewTableAddedFields = newTableSpecificVariables[loadTableIndex][2];

} else {
	//alertx("dataVobj.tableSpecific is not here! Going to redefinenewTableSpecificVariables();");
	
	redefinenewTableSpecificVariables();
	console.log("back from redefineSavedTablesArray…did I make it?");
	 console.log("In PickOldNew…after retrieving dataVobj…and no dataV.savedTable…or newTableSpecificVariables .savedTablesArray[0] = " + savedTablesArray[0] + " newTableSpecificVariables[0] = " + newTableSpecificVariables[0]);
	// In PickOldNew…after retrieving dataVobj…and no dataV.savedTable….savedTablesArray[0] = ,,,
	 alert("⚠️ This file is an out-dated file format! DougieBase will convert old file type to new! When the data screen appears tap CONVERT (TABLE) to complete the conversion.");
	 
	 convertingOldFile = true;//flag to fudge a correction in tableScreenOptions to prevent a refresh request. tableTitle.length came out as 4 when there were only 2 records in the testingPreferences db file. This may be related to the fact that testingPreferences file had 2 deleted records? And cursor iterated up to 4 when there are only 2??????
	 saveVariables();
	 console.log("Returned from saveVariables after converting old file type.");
	 tableScreenBtn.setAttribute('class','borderBlink');
	 tableScreenBtn.textContent = "CONVERT";
	 
//bkupAlertsFlag = false;//so backup option and dave alert does not appear which if ok'd will mess up file! Date May 22 2023
dataNotBackedUp = false;//flag for SAVE warning so backup option and dave alert does not appear which if ok'd will mess up file! Date May 22 2023
	displayTableBtn.setAttribute('class','attentionBtn');//so not flashing at same time as homeScreenBtn when Converting file format DATE:JUNE4
	
}//end if(dataVobj.hasOwnProperty('tableSpecific'))

 if(dataVobj.hasOwnProperty('savedTables')) {
	//alert("yes savedTables exists!");
	 savedTablesArray = dataVobj.savedTables;
	 newTableVariablesArray = dataVobj.newTableVariables;
	 tableIndex= newTableVariablesArray[0];
tableListExists = newTableVariablesArray[2];
newTableNames = newTableVariablesArray[1];

/*
newTableSpecificVariables = dataVobj.tableSpecific;
tableIndex = newTableSpecificVariables[loadTableIndex][0];
newTableFieldsArray = newTableSpecificVariables[loadTableIndex][1];
numberOfNewTableAddedFields = newTableSpecificVariables[loadTableIndex][2];
*/

 } else {
	 console.log("savedTables or newTableSpecificVariables not here going to redefineSavedTablesArray");
	// alert("savedTables not here!");
	 redefineSavedTablesArray();
	// tableIndex = -1;;
		//	newTableNames.length = 0;
		//	tableListExists = false;
	 console.log("back from redefineSavedTablesArray…did I make it?");
	 console.log("In PickOldNew…after retrieving dataVobj…and no dataV.savedTable…or newTableSpecificVariables .savedTablesArray[0] = " + savedTablesArray[0] + " newTableSpecificVariables[0] = " + newTableSpecificVariables[0]);
	// In PickOldNew…after retrieving dataVobj…and no dataV.savedTable….savedTablesArray[0] = ,,,
	 alert("Converting old file type to new! When the data screen appears tap CONVERT (TABLE) to complete the conversion.");
	 convertingOldFile = true;//flag to fudge a correction in tableScreenOptions to prevent a refresh request. tableTitle.length came out as 4 when there were only 2 records in the testingPreferences db file. This may be related to the fact that testingPreferences file had 2 deleted records? And cursor iterated up to 4 when there are only 2??????
	 saveVariables();
	 console.log("Returned from saveVariables after converting old file type.");
	 tableScreenBtn.setAttribute('class','borderBlink');
	 tableScreenBtn.textContent = "CONVERT";
	
	//bkupAlertsFlag = false;//so backup option and dave alert does not appear which if ok'd will mess up file! Date May 22 
	dataNotBackedUp = false;//flag for SAVE warning so backup option and dave alert does not appear which if ok'd will mess up file! Date May 22 
 }//end if else dataVobj has ownproperty savedTables
 
 
 // savedTablesArray = dataVobj.savedTables;
 
 //AT TIME OF TESTING AND CREATING savedTablesArray, there is no dataVobj.savedTables! So this must be where we go astray!
 //end load in prefVariables

 console.log('data.variable1 = ' +data.variable1);
dbTableName.value = data.variable1;
document.getElementById("dbTableName").innerHTML = dbTableName.value;
//displayData();
while (list.firstChild) {
  list.removeChild(list.firstChild);
}
//remove above if it messes up!
console.log("In PickOldNew…after retrieving dataVobj…….savedTablesArray = " + savedTablesArray);
//In PickOldNew…after retrieving dataVobj…….savedTablesArray = name,DATE,tel,email,name2,DATE,tel2,email2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
console.log("In PickOldNew…after retrieving dataVobj…….savedTablesArray[0] = " + savedTablesArray[0]);
//In PickOldNew…after retrieving dataVobj…….savedTablesArray[0] = name,DATE,tel,email
console.log("In PickOldNew…after retrieving dataVobj…….newTableVariablesArray = " + newTableVariablesArray);
console.log("In PickOldNew…after retrieving dataVobj…….newTableSpecificVariables = " + newTableSpecificVariables);
//In PickOldNew…after retrieving dataVobj…….newTableSpecificVariables = -1,,0
//In PickOldNew…after retrieving dataVobj…….newTableVariablesArray = 0,Contacts0,false

console.log("In PickOldNew…after retrieving dataVobj…….tableIndex = " + tableIndex + " tableListExists = " + tableListExists + " newTableNames = " + newTableNames);
//In PickOldNew…after retrieving dataVobj…….tableIndex = -1 tableListExists = false newTableNames = 
//alertbkup("end pickoldnew going to displayData .. dataBaseName = " + dataBaseName);

displayData();


}//end if setup=1 wrapper to set all variables of a pre-existing database
	
	
if (setup === 0) {
	console.log('In setup = 0 of pickOldNew()')
	// tableArray = "CN7035", "Oct 20 2020 22:21","Y2Trk2","TSU-1100","5","128","255","CN3205", "Oct 20 2020 22:21","Y3Trk2","Econami-PNP","15","128","255","CN6700","Oct 20 2020 22:21","Y3Trk8","TSU-1100","77","130","190";
	//should this line be here???!!!!?,?,?,
	redefineTableArray();
	//tableArray = [["CN7035", "Oct 20 2020 22:21","Y2Trk2","TSU-1100","5","128","255"],["CN3205", "Oct 20 2020 22:21","Y3Trk2","Econami PNP","15","128","255"],["CN6700","Oct 20 2020 22:21","Y3Trk8","TSU-1100","77","130","190"]];	
	//dataVobj = { difference with faalBack
		//dataVobj should be data.dataV .. if in getDataBaseName from onupgtadeneeded, data.dataV is empty and thus will produce undefined errors unless declared thus
// data.dataV = {
//   tableArray: tableArray,
//   fieldNamesArray: fieldNamesArray,
//   otherVariables: otherVariablesArray,
//   variable3: variable3
// };//end declaration of dataV object
//TypeError: undefined is not an object (evaluating 'data')
 console.log('In if setup=0;before dataVobj = data.dataV {}  dataVobj.tableArray = ' +dataVobj.tableArray);
 dbTableName.value = 'Creating new Database';

//at this point the program stops because of undefined is not an object in evaluating data.variable1 and I tap SAVE ..then go to saveVariables

document.getElementById("dbTableName").innerHTML = dbTableName.value;

	//data.variable1 = 'Creating new Database';
	//put automatic SAVE here if newDB.
	saveVariables();
console.log('After SaveVariables in the setup=0 section of thepickOldNew function. Should have returned to the displayData screen after the call to saveVariables')
	}//end if setup ===0
	
}//end pickOldNew
//}//end functionOldNew

//MAKE TABLE CODE HERE

// const flipMenu = document.querySelector('#flip');//reference for table menu bar to allow it to turn yellow May17

function tableScreenOptions () {
	//prevent error if user taps TABLE BTN and no db is selected which can happen if user CANCELS fileNamesList Dec21
	if(dbName === undefined && !newDBflag) {
		alert('No database has been selected! Select or create a database to make TABLE available.');
	//prefWindow.setAttribute('class','hidden');
		//getFileNames();
		return;//DOES THIS STOP THE PRGM???
	} //end if dbName===undefined
	
//to keep tableList from repeating
//ReferenceError: Cannot access uninitialized variable.
if(tableListExists) {
		while (newTableList.firstChild) {
	newTableList.removeChild(newTableList.firstChild);
};//end while
}//end if(tableListExists)

//to prevent tableList from repeating
	//check screen mode
	checkScreenMode();//have to so that table responds after a table refesh without having to go through preferences to update the screenDark variable! Dec20
//alert("At tableScreenOptions - usingDarkMode = " + usingDarkMode + " screenDark = "+ screenDark);
if(screenDark) {
	showTable.style.backgroundColor = "black";
	showTable.style.color = "white";
	promptBox.style.backgroundColor = "black";
	promptBox.style.color = "white";
	$("#flip").css({"background-color": "lightgrey", "color":"black", "border-color": "red"});//these don't work
	tdEditTriggerP.style.color = "orange";
	totalInfoP.style.color = "orange";
	sumAcrossInfoP.style.color = "orange";
	//set font color for dark mode Dec20
		
	//bodyImage.setAttribute('class','showDark');
	//bodyImage.style.color = "white";
	
} else {
	showTable.style.backgroundColor = "#eee";
	showTable.style.color = "black";
	promptBox.style.backgroundColor = "#eee";
	promptBox.style.color = "black";
	$("#flip").css({"background-color": "lightgrey", "color":"black", "border-color": "black"});//these don't work
	tdEditTriggerP.style.color = "blue";
	totalInfoP.style.color = "blue";
	sumAcrossInfoP.style.color = "blue";
	}//end check screen mode
	
	
editCurrentTable = 0;//why here after displayTablebtn what is it?
	console.log('At tableScreenOptions...tableExists = ' + tableExists + '. edit =  ' + edit);
	
//clearTableWindow precedes  createTableWindow!! Create table window has the new and edit btns at top
	const clearTableWindow = document.querySelector('#clearTableWindow'); 
	//const clearTableWindowEditBtn = document.querySelector('#clearTableWindowEditBtn');MADE GLOBAL AT TOP PRGM
// const emailBtn = document.querySelector('#email');//made global because referenced by tableScreenOptions Mar7
	
//  const displayTableBtn = document.querySelector('#displayTable');
//  const renameNewTableBtn = document.createElement('button');//made global..see emailBtn	
// //flag to correct messed up fieldHeaders from a newTable edit
//  const returnToNotesBtn = document.querySelector('#returnToNotes');
 const nameNewTableBtn = document.querySelector('#nameNewTable');
 const refreshTableP = document.createElement('p');//infoP to give option of refresh table
const newTableNameCancelBtn = document.querySelector('#newTableNameCancelBtn'); refreshTableP.setAttribute('class','simulator');
 const refreshTableBtn = document.createElement('button');
 refreshTableBtn.textContent = "Update Table";
 //refreshTableBtn.setAttribute('class','attentionBtn');
 refreshTableBtn.setAttribute('class','borderBlinkGrn');
 //from newBtn.onclick..originalNumberRecords = undefined tableTitle.length = 3
 
 const homeScreenBtn = document.querySelector('#homeScreenBtn');
 const moreTablesBtn = document.querySelector('#moreTablesBtn');
 const homeScreenBtn2 = document.querySelector('#homeScreenBtn');
 
 //NC Jan9
 //CODE FOR DISPLAYING NEW TABLES
 const tableNamesList = document.querySelector('#tableNamesList');//div html
 // const newTableList = document.querySelector('#newTableList');//<ol> to contain li in html
 //newTableNames is an array containing the names of the new tables created when a new table is created..emailBtn.onclick or in searchTable?
 tableChosenP.textContent = ' Tap the table name to select for loading OR deleting or to rename the table. Currently ' + newTableNames.length + ' tables out of 10';
//alert("> tableIndex = " + tableIndex + ". newDBflag " +newDBflag + ". newDBGuidance = " + newDBGuidance + ". newTableNames[0] = " + newTableNames[0]);
 //if(newDBflag || newDBGuidance || tableIndex === -1) {newTableNames.length = 0;}//end if(newDBflag || newDBGuidance) to prevent error TypeError: undefined is not an object (evaluating 'newTableNames.length')in creating new db from virgin run of create new db
 
 if(newTableNames[0] === "C") {
   newTableNames.length = 0;
 	}//end if(newDBflag 
 	
/*if(tableIndex === -1) {
 newTableNames.length = 0;
 	}//end if(newDBflag f
 */
 
 for (let i = 0; i< newTableNames.length; i++) {
	  
	  let tableNumber = i + 1;//just for display
	  console.log('newTableNames = ' + newTableNames);//array of tableNames ;newTableNames = Contacts0,Contacts1
	  console.log('newTableNames.length = '+ newTableNames.length);
	  console.log('newTableNames # ['+ tableNumber +'] is ' + newTableNames[i]);
	  //newTableNames # [1] is Contacts0
tableNameLi[i] = document.createElement('li');//to contain a newTableNames
tableNameLi[i].textContent = newTableNames[i]+ "." + tableNumber;//maybe should just be newTableNames[i]?
// tableChosenP.textContent = ' Tap the table name to select for load OR double tap HERE to delete.';
//now have to add the li element to 

tableNameLi[i].addEventListener('click', function () {

//CODE TO CHECK FOR FLASHING HOMEBTN BEFORE LOADING IN A NEW TABLE TO AVOID FILE DOES NOT EXIST GLITCH Mar 24 Mar24

const attribute = homeScreenBtn.getAttribute('class');
console.log(attribute);
if(attribute === 'borderBlink') {
alert("INITIALIZE THE NEW TABLE FIRST BY TAPPING THE FLASHING DISPLAY TABLE BUTTON, AND THE CLEAR TABLE BUTTON IF FLASHING!");	
return;
}


		//put name of database in global variable dataBaseName
		//let tableName = "";//made global variable
		//alert("click event..to load");
		tableNamed = newTableNames[i] + "." + tableNumber;
		loadTableIndex = i;//used in setupNewTable function
		tableID = loadTableIndex;
		//TypeError: Attempted to assign to readonly property.tableName changed to tableNamed..not even declared a global variable and that worked. SO tableName must be used elsewhere????
		deleteTableIndex = i;
	//code to clear head row so table is not messed up when switching between db	 
	
	
		// tableChosenP.textContent = ' Table Selected: '+ newTableNames[i] + '. DOUBLE-TAPPING here will delete.';
		 tableChosenP.textContent = ' Table Selected: '+ tableNamed;
		 console.log('tableName = ' + newTableNames[i]);
	 //confirm choice window
	 
//code for promptBox
promptBox.setAttribute('class','showing');
tableNameLi[i].removeEventListener;	tableScreen.setAttribute('class','hidden');
tableNameTxt.textContent = "SELECTED: " + tableNamed;
actionLoadBtn.textContent = "LOAD : " + tableNamed;
actionRenameBtn.textContent = "RENAME : " + tableNamed;
actionDeleteBtn.textContent = "DELETE : " + tableNamed;
actionRenameBtn.style.display = "unset";
actionDeleteBtn.style.display = "unset";//in case any of these were none from addContacts or Field Labels
actionLoadBtn.onclick = function () {
// tableNameLi[i].removeEventListener;	tableScreen.setAttribute('class','hidden');
promptBox.setAttribute('class','hidden');	
	loadFromTableOptions = true;//flag indicates source of tableArray data
	fromNewTable = true;//flag used in displayTable to keep fields being messed up if edit notes after viewing a new table
	if(!savedOriginal) {
		saveOriginal();
	}//works end of if(!savedOriginal)
	console.log("Back from saveOriginal function");	
	homeScreenBtn.textContent = "Clear New Table Data";
	homeScreenBtn2.textContent = "Clear New Table Data";
	emailBtn.style.display = "none";
	newTableFieldsBtn.style.display = "none";
	
		setupNewTable(tableNamed);	
		
	dbName = dataBaseName;
			console.log('Table to load is ' + tableNamed); 
	
}//END FUNCTION actionLoadBtn.onclick

actionRenameBtn.onclick = function () { 
promptBox.setAttribute('class','hidden');	

displayTableBtn.setAttribute('class','attentionBtn');//because if main db table not initiated this btn will be flashing.table will get initialized in process of rename	

renameNewTable();

}//END FUNCTION actionRenameBtn.onclick

actionDeleteBtn.onclick = function () {
deleteNewTable();
promptBox.setAttribute('class','hidden');	
}//END FUNCTION actionDeleteBtn.onclick

actionCancelBtn.onclick = function () {
promptBox.setAttribute('class','hidden');	
tableScreenOptions();
}//END FUNCTION actionCancelBtn.onclick


});//end addEventListener
			
newTableList.appendChild(tableNameLi[i]);


}//end for loop for (let i = 0; i< newTableNames.length; i++) {
	
			
//delete new table
// tableChosenP.addEventListener('dblclick', deleteNewTable);//if you put brackets after function name it messes up!
// //delete new table
// //rename newTable
// renameNewTableBtn.onclick = renameNewTable;				
			//fix this	

	// newTableList.appendChild(tableNameLi[i]);
	//  console.log('Table to load is ' + tableName);
 
	
	tableListExists = true;//flag to prevent list repeating. A one time switch
	//fix this
//}//end for loop for (let i = 0; i< newTableNames.length; i++) {
 
  //CODE FOR DISPLAYING NEW TABLES
 
 
 //to refresh table name
// const refreshTableName = document.querySelector('#dbTableName');
 const refreshTableName = document.querySelector('#showTableName');
 	//update h2 dbTableName dbTableName.value; in HTML if db has been switched
refreshTableName.textContent = dbTableName.value;	
//document.getElementById("#dbTableName").innerHTML = dbTableName.value;
	//update h2 dbTableName in HTML if db has been switched Apr10
	
	
 //ADDED THIS LINE DEC 29 so originalNumberRecords gets a value from load or getDataBaseName?
 originalNumberRecords = otherVariablesArray[1];
 if(!tableExists) {
	 originalNumberRecords = tableTitle.length;
 }//end if tableExists
 //note that if in newTable mode tableTitle.length will reflect number of records in the newTable which will differ from number of records in main db mode!!IF THIS CAUSES ISSUE MAYBE ADD CONDITIONAL || loadFromTableOptions… if(!tableExists || loadFromTableOptions) {
 
 console.log('originalNumberRecords = '+ originalNumberRecords + ' otherVariablesArray[1] = ' + otherVariablesArray[1] + ' tableTitle.length = ' + tableTitle.length);
 console.log('editNote = ' + editNote + '  tableExists = ' + tableExists)
 console.log('at tableScreenOptions.  tableTitle = '+ tableTitle);
 //WHY IS tableTitle.length = 4 after comming from delete recordItem?when originalNumberFields = 3 ????!!Dec 7
 //at tableScreenOptions. If here after a delete record why does tableTitle.length be greater than originalNumberRecords? tableTitle = CN3205,CN4800,CN5502,CN5502..this after saving variables after a delete record!!INVESTIGATE,!!!Dec7How did the extra CN5502 get there?
 //added editNote = true to force table update if notes edited Jan11
 //force displayTable if first time coming to this screen remove if messed up Feb 26
 
 if(DTBtnTappedOnce ===0){
 copyOfTableArray = tableArray.slice(0,tableTitle.length);
 copyOfTableTitle = tableTitle.slice();	//displayTableBtn.setAttribute('class','attentionBtn');
//changed to borderBlink to remind user to initiate main db table! Added !newDBGuidance may25
if(!convertingOldFile && !newDBGuidance) {
 displayTableBtn.setAttribute('class','borderBlinkGrn');
 }//end if(!convertingOldFile)
 
 nameNewTableBtn.disabled = true;//so name-createnew table is not initiated as this will mess up table display
} else {

  if(!renameNewTableFlag) {displayTableBtn.setAttribute('class','normalBtn');}//end if !renameNewTableFlag
 }//end else if DTBtnTappedOnce = 0
 
  if(makeContactsTable) {
displayTableBtn.setAttribute('class','borderBlinkGrn');	
}//end if(makeContactsTable) to avoid another listing of contacts table file which does not even exist! Not sure why this works??Mar21 2023
 
 
if(convertingOldFile) {
	tableChosenP.textContent = 'THE OLD FILE FORMAT OF THIS DATABASE HAS BEEN CONVERTED. NOW RETURN TO FILENAMES SCREEN AND RELOAD IT. Tap CONVERT (Return to HOME SCREEN)';
	
displayTableBtn.disabled = true;
returnToNotesBtn.setAttribute('class','borderBlink');
	returnToNotesBtn.textContent = "CONVERT";
	
}//end if convertingOldFile

//alert("At need refresh? originalNumberRecords = " + originalNumberRecords + ". tableTitle.length = " + tableTitle.length + ". editNote = " + editNote + ". loadFromTableOptions = " + loadFromTableOptions + ". editCurrentTable = " + editCurrentTable + ". edit = " + edit);
//editCurrentTable = 0 on entering tableScreenOptions so don't use it in this condition
if(loadFromTableOptions) {//&& editCurrentTable === 1
	originalNumberRecords = savedTablesArray[loadTableIndex].length;
//TypeError: undefined is not an object (evaluating 'savedTablesArray[loadTableIndex].length') if you don't SAVE a new table
}//end if

//alert("At need refresh? AFTER ORIGINALNUMBERRECORDS ADJUSTED!  originalNumberRecords = " + originalNumberRecords + ". tableTitle.length = " + tableTitle.length + ". editNote = " + editNote + ". loadFromTableOptions = " + loadFromTableOptions + ". editCurrentTable = " + editCurrentTable);


 if (!convertingOldFile & tableExists & tableTitle.length>originalNumberRecords || editNote) {
	 tableScreen.appendChild(refreshTableP);
	 displayTableBtn.disabled = true;//Nov 22 so a tap of displayTableBtn doesn't cause a false display and also preverts a repeat display of the refresh notification. Also have to disable the create table option bar Feb 12 .. but doesn't do it!!
	 clearTableWindow.disabled = true;
	 clearTableWindow.textContent = "You must Update Table FIRST!";
	 tableScreen.appendChild(refreshTableBtn);
	 displayTableBtn.textContent = "disabled";
	 
	//added Nov25 2022 remove if messed up .. added becausethis btn was flashing green while being disabled if going to another db without having refreshed a new table?
	 displayTableBtn.setAttribute('class','normalBtn');
	 
	 tableNeedsUpdate = true;//flag so that if removing after returnHomeBtn tapped does not produce an error Dec 29
	 }//end if tableTitle.length>originalNumberRecords
	
	 refreshTableP.textContent = "You have added a new Record since last creation of Table, OR you have edited a note, OR you have changed the edit table Trigger action. To update tap UPDATE TABLE button.";
	 refreshTableBtn.onclick = function () {
	 
	 //CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED
if(telephoneActive || eMailActive || STfirstDataNameTdListener || STsecondDataNameTdListener) {
resetActiveFieldHeaders();
resetFixedFieldActivity();
}//end if(telephoneActive || eMailActive) {

//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED
		 
		// originalNumberRecords = tableTitle.length;//reset originalNumberRecords to reflect updated table
		//tableScreen referenced at top of code
		
		//	fromViewSort = false;//turn off sort flag so build record rows will run in refreshTable Mar 10
		tableScreen.removeChild(refreshTableP);
		 tableScreen.removeChild(refreshTableBtn);
		 displayTableBtn.textContent = "DISPLAY TABLE";
		 displayTableBtn.disabled = false;
		 clearTableWindow.disabled = false;//Feb 12
		 clearTableWindow.textContent = "TAP HERE TO CREATE MAIN TABLE or to EDIT an existing one."
		 refreshTable();
	 }//end refreshTableBtn.onclick

tableScreen.setAttribute('class','showing');//referenced at top of code reference the create a table window has options for create new or edit, instructions for table creation, display table btn and refresh table if needed

if(!tableExists) {
	displayTableBtn.disabled = true;
	//alert("8346>do i disable homecscreen btn here to?");
	returnToNotesBtn.disabled = true;
	// } else {
	// 	displayTableBtn.disabled = false;
	
	}//end if !tableExists
	
	//disable clearWindow if table needs updating first REMOVE IF MESSED UP DATE: Feb 26
	
//	if(tableExists & tableNeedsUpdate) {
//		clearTableWindow.disabled = true;
//	}//end of if tableExits and tableNeedsUpdate
	
//added & !tableNeedsUpdate here to make disable work for a needed table update Feb 12
if(tableExists & !tableNeedsUpdate) {
	displayTableBtn.disabled = false;//Nov26 new dB from seRatch displayTableBtn was disabled even though table was created
}//end if tableExists
	
	clearTableWindow.onclick = function () {
		if (tableExists & DTBtnTappedOnce === 0) {
		alert('You need to initialize the table first by tapping DISPLAY TABLE at least once!');	tableScreen.setAttribute('class','hidden');
			createTableWindow.setAttribute('class', 'hidden');	
		} else {//end if DTBtnTappedOnce === 0 March 20
		//Tap here to create table or edit an existing one .. see HTML
	/*prefWindow.removeChild(notifyP);*/
	console.log('At clearTableWindow.onclick. Bringing up createTableWindow...tableExists = ' + tableExists + '. edit =  ' + edit + 'displayedTable = ' + displayedTable);
	tableScreen.setAttribute('class','hidden');
	clearTableWindowEditBtn.setAttribute('class','tdEdit');
	createTableWindow.setAttribute('class', 'showing');	
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	createTableWindow.style.backgroundColor = "black";
	createTableWindow.style.color = "white";
} else {
	createTableWindow.style.backgroundColor = "#eee";
	createTableWindow.style.color = "black";
}//end if else screenDark
	
	//update h2 dbTableName dbTableName.value; in HTML if db has been switched
	document.getElementById("dbTableName").innerHTML = dbTableName.value;
	//update h2 dbTableName in HTML if db has been switched
		
	
	//remove code below if messes needs to be here so neworedit element can process it before seReen is shown
	if(!tableExists) {
	newBtn.disabled = false;
	newBtn.setAttribute('class', 'borderBlinkGrn');
	
	// if(dbTableName.value.includes("creatingDB")) {
goHomeBtn.style.display = "none";
// } else {
// goHomeBtn.style.display = "unset";
// 	//newOrEdit.removeChild(goHomeBtn);	
// 	}//end if else (dataBaseName.includes("creatingDB"))

	
	} else {
		newBtn.disabled = true;
		newBtn.setAttribute('class', 'normalBtn');
		goHomeBtn.style.display = "unset";
	}//end if !tableExists
//LEFT OFF HERE NOV 11 !!!!!!! Fix this!	
editBtn.textContent = 'EDIT';
deleteFieldBtn.textContent = 'DELETE FIELD';
if(!tableExists) {
	editBtn.disabled = true;
	editBtn.setAttribute('class', 'normalBtn');
	deleteFieldBtn.disabled = true;
	deleteFieldBtn.setAttribute('class','normalBtn');
	} else {
		//IF THE TABLE HAS NOT YET BEEN INITIATED BY HAVING VISITED DISPLAY TABLE AT LEAST ONCE DISABLE THE EDIT AND DELETE FIELD BTNS..OTHERWISE DISPLAY ETC GETS MESSED UP!
//trying to erase record rows for editing new table Feb12
//still testing..think it works OK FEB 12
while (rows.firstChild) {
   rows.removeChild(rows.firstChild);
}//end while
//REMOVE ABOVE IF MESSED UP FEB 12
		if(DTBtnTappedOnce ===1){deleteFieldBtn.disabled = false;
			editBtn.disabled = false;
			//remove if messed up Feb 26
			//displayTableBth.setAttribute('class','normalBtn');
		}else if (DTBtnTappedOnce === 0) {
			deleteFieldBtn.disabled = true;
			editBtn.disabled = true;
			//REMOVE IF SCREW UP FEB11
			alert('You need to initialize the table first by tapping DISPLAY TABLE at least once!');
	//return to notes screen to start again so display does not get messed up if user attempts new or edit table prior to table being initialized by tapping green Display Table btn
	
	
		}
//editBtn.setAttribute('class', 'attentionBtn');
editBtn.setAttribute('class', 'borderBlinkGrn');
deleteFieldBtn.setAttribute('class','borderBlinkGrn');
showTable.setAttribute('class','hidden');
	}//end if !tableExists..else moved line showTable hidden above close bracket of !tableExists for the 'edit screen to work look better Jan30'
//REMOVE IF IT BLOWS IT JAN 18
//works for edit..check ok for new
//Jan27. Seems to work now but not if using an older dB. WorKs if I load in Jan25 dB! DOES showTable need to be referenced as global variable? It doesn’t get referenced until line 3125?
	//showTable.setAttribute('class', 'hidden');
	
}//end if else !DTBTappedOnce march 20
	}; //end clearTableWindow.onclick
	
  displayTableBtn.onclick = function () {
  //alertx("at displayTableBtn : STfirstDataNameTd.textContent = " + STfirstDataNameTd.textContent + "  STsecondDataNameTdListener = " + STsecondDataNameTdListener + " STfirstDataNameTdListener = " + STfirstDataNameTdListener);
  
  if(STsecondDataNameTdListener) {
	STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
	eMailActive = false;
	STsecondDataNameTd.setAttribute('class','stHeadRow');
	
	//STsecondDataNameTdListener = false;
}//end if(STsecondDataNameTdListener)
//alertx("displayTableBtn tapped: telephoneActive = " + telephoneActive);

if(STfirstDataNameTdListener) {
STfirstDataNameTd.removeEventListener('dblclick',STfirstDataNameTd.fn, false);
	//STfirstDataNameTd.removeEventListener;
	STfirstDataNameTdListener = false;
	telephoneActive = false;
STfirstDataNameTd.removeEventListener;	STfirstDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STfirstDataNameTdListener)

//code to force rerun of displayTable function if telephone or email active in dynamic fields so TELEPHONE headind is registered again enabling addEventListener
// if(telephoneActive || eMailActive) {
// telephoneActive = false;
// eMailActive = false;
// //tableConstructed = 0;
// alert("Going to displayTable()");
// // refreshed = false;
// // displayedTable = false;
// // fromDeleteField = false;
// //editCurrentTable = 1;
resetFields = true;//DATE:Mar 2 2023 uncommented because a field display glitch occurred after a create new db and a auto delete sequence ? neccessary to format headings correctly BUT so now have to repeat code to register TELEPHONE in header in the resetFields code MAYBE THIS IS ALL I NEED ..DON'T NEED ? Make sure fields are setAttribute stHeadRow in the resetFields code?
// displayTable();
// //showTable.setAttribute('class', 'showing');
	
// }//end if(telephoneActive || eMailActive) {
  
  if(!savedOriginal) {saveOriginal();}//May12 2022
  
  
 //trying to prevent error where displayTableBtn still shows new table May5 2022
// loadFromTableOptions = false; NOPE DOES NOT WORK! Messes up at refreshTable Update table!!! This bug not important..just tap displayTablebtn again and you get main db table..and before displayTablebtn returns you to the new table screen where you were before

if(loadFromTableOptions & DTBtnTappedOnce === 0) {
displayTableBtn.setAttribute('class','tdEdit');
displayTableBtn.textContent = "DISPLAY TABLE";
}//end if (loadFromTableOptions & DTBtnTappedOnce === 0) this resets displayTableBtn which in this case was set to flashing when user attempts an EDIT of a new table prior to initializing the main db table May6 2022
 
  if(fromAddingMoreContacts) {
	resetFields = true;
	 fromAddingMoreContacts = false; 	  
  }//end if fromAddingMoreContacts = true;//forcing a resetFields when displayTableBtn is tapped
  
  //reset field headers if after a delete new table tecord
if(deleteRecordNewTable) {
resetFields = true;
deleteRecordNewTable = false;
	
}//end if deleteRecordNewTable
  
   if(renameNewTableFlag) {
displayTableBtn.setAttribute('class','tdEdit');

saveTableBtn.setAttribute('class','borderBlinkGrn');
saveTableBtn2.setAttribute('class','borderBlinkGrn');
//renameNewTableFlag = false;

}//end if(renameNewTableFlag)
//alert below produced error if loadTableIndex from another viewing of a database was applied to a db with no new tables …undefined is not an object error
/*  alert("displayTableBtn.onclick … loadFromTableOptions = " + loadFromTableOptions +  ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1]);
 */ 
 
  emailBtn.style.display = "unset";
  newTableFieldsBtn.style.display = "unset";
  
	  mainDBedit = false;//where do I make this false?
	//  removeHeadRow();//STHeadrow was messed up after an edit of new table so added this 
	//  addFieldHeaders();
	  nameNewTableBtn.disabled = false;
	//added Dec 7 ,remove if messes up if tableTitle.length>originalNumberFields	tableScreen.removeChild(refreshTableP);
	//if new record not added then refreshTableBtn will not be seen here.
//NotFoundError: The object can not be found here.
//tableScreen.removeChild(refreshTableBtn);
	//	 displayTableBtn.disabled = false;
		DTBtnTappedOnce = 1;
	//make displayedTable variable =1 here so that the prexisting table(..the displatTableBtn IS enabled) so the tanble will show without alterations or added fields
//displayedTable = 1;//see above NOT TESTED NOV 6 2020
console.log('At start displayTableBtn.onclick. This means a table exists..rerun or not.: displayedTable = ' + displayedTable + '. tableConstructed = ' + tableConstructed + '. renewed (added record) = ' + renewed + '. refreshed (data cell edit) = ' + refreshed + '. edit = ' + edit + '. DTBtnTappedOnce = ' + DTBtnTappedOnce + '.');
//if changeDB NOTE THAT IF RETURNING FROM A SAVE EDIT OF NEWTABLE AFTER RESETFROMCONTACTS LOADFROMTABLEOPTIONS WILL BE FALSE SO THAT THE removeHeadRow function won't run this time around which will mess up the displayTable btn response to opening up the main db. THEREFORE LETS JUST RUN CHANGEDB EVERYTIME?
//removeHeadRow();//VERY IMPORTANT LINE..MAKES IT WORK!!!Date: Feb12 2022..new function
//check screen mode
if(loadFromTableOptions) {
	//alertx("why is loadFromTableOptions true when I press displayTable? Which implies main db? Should loadFromTableOptions be made false at first of tableScreenOptions? It is made false in resetFromContacts! This happens if EDIT of a new table is cancelled by a return to home screen or displayTableBtn is pressed after EDIT BTN IN TABLE MENU IS PRESSED.or after a rename table?")
	setUpFieldHeaders();//changeDB is false coming back from setUpNewDB
	resetFields = true;//added May6 2022 because fields got messed up after a rename of table??
	//deleteFirstRow();
	changeDB = true;
}//end if loadFromTableOptions
//trimHeadRow();
//alert("In tableScreenOptions displayTableBtn.onclick : changeDB is set to true here if loadFromTableOptions is true! But loadFromTableOptions should not be true here in the first place! changeDB is false returning from setUpNewTable if loading a new table,  changeDB = " + changeDB + " loadFromTableOptions = " + loadFromTableOptions + "  editCurrentTable = " + editCurrentTable);

if(changeDB) {
	//clearTableRows;
	//addFieldHeaders();
	//trimHeadRow();
	tableConstructed = 0;
	displayedTable = 0;
	refreshed = 0;
	renewed = 0;
	changeDB = false;
	//clearHeadRow();//to reset STHeadRow for change to other db
		//trimHeadRow();
	removeHeadRow();//VERY IMPORTANT LINE..MAKES IT WORK!!!Date: Feb12 2022..new function
	//clearHeadRow();//to reset STHeadRow for change to other db
	//removeFieldHeaders();
	
console.log('in changeDB. Removed dynamic fields! ' + STheadRow);
STheadRow.appendChild(STheadName);
STheadRow.appendChild(secondFieldName);
STheadRow.appendChild(STfirstDataNameTd);
STheadRow.appendChild(STsecondDataNameTd);
//field labels of static fields now restored!
	//clearHeadRow();
	//STrows.appendChild(STheadRow);
	//removeFieldHeaders();
	//trimHeadRow();
	//displayTable();
}//end if changeDB 
//Dec 29 probably need to clear refreshTableP here to prevent its appearance twice if returning to createTable after viewing notes and not having updated the table
if (tableNeedsUpdate) {
		tableScreen.removeChild(refreshTableP);
		 tableScreen.removeChild(refreshTableBtn);
		 displayTableBtn.disabled = false;
	 }//end if (tableNeedsUpdate) ..ADDED DEC29

tableScreen.setAttribute('class','hidden');
	console.log('displayTableBtn has been tapped. displayedTable variable = ' + displayedTable + '. (If displayedTable = 1, this means a virgin run of the table has been completed by a previous displayTable function.) If 1, the extra added fields will have been tacked on to the end of STHeadRow,  then showTable screen is showing but buildRecordRows has not needed to run. displayedTable could also be set to 0 by a previous instance of displayTableBtn.onclick and tableConstructed = 1.	If displayedTable is 0 and tableConstructed is 0, the else part of if tableConstructed === 1 runs and then showTable screen is cleared after the displayTableBtn.onclick, and table header and field header row are ADDED to STRows, then in displayTable() because displayedTable and refreshed are 0, the extra fields are tacked on to STHeader. STHeader has been added to STRows in the else part of the displayTableBtn.onclick code?? ');
	console.log('At displayTableBtn.onclick: The refreshed variable is controlled by the REFRESH Btn in the edit phase of the showTable data cell, and is also set to 1 in refreshTable function. refreshed is set to 0 in showBtn.onclick (DISPLAY TABLE) Btn, and also from a rerun..initialized to 0. The renewed variable is controlled by the refreshTable function. refreshed = ' + refreshed + ' renewed = ' + renewed);
	console.log('tableConstructed variable = ' + tableConstructed + ' displayedTable variable = ' + displayedTable + ' tableConstructed variable and displayedTable will be 0 if comming from a rerun.');
	
	//not sure yet if this code below is needed..maybe for a rerun? Rerun not tested as of Nov7 2020. Currently doesn't run because DTBtnTappedOnce = 1 at line 2466
	if (!DTBtnTappedOnce) {
		console.log('At if (!DTBtnTappedOnce in displayTableBtn.onclick and about to add STHeader): displayedTable = ' + displayedTable + '. tableConstructed = ' + tableConstructed + '. renewed (added record) = ' + renewed + '. refreshed (data cell edit) = ' + refreshed + '. edit = ' + edit + '. DTBtnTappedOnce = ' + DTBtnTappedOnce + '.');
		STtableHeader.setAttribute('class','attentionBtn');
STrows.appendChild(STtableHeader);
STrows.appendChild(STheadRow);
	}//end if !DTBtnTappedOnve
	
		if (tableConstructed === 1) {
			console.log('At tableConstructed = 1. fromDeleteField = ' + fromDeleteField);
			//to correct for missing fieldHeadres when coming from deleteField
			if (fromDeleteField) {
	console.log('in displayTableBtn.onclick fromDeleteField: fromeDeleteField = ' + fromDeleteField);
	clearTableRows ();
	trimHeadRow ();//would displayedTable = 1 accomplish the same thing?
	displayTable();
	//fromDeleteField = false;
	//addFieldHeaders();
	}//end if fromDeleteField
			showTable.setAttribute('class', 'showing');
		displayedTable = 0;//why set this to 0? It will be 1 if comming from a previous virgin run of displayTable and it will be 0 along with tableConstructed,  if this is a rerun. If displayedTable =1 the added extra fields will not be added to the STHeadRow in next run of displayTable. If you add a record you want to make sure displayedTable = 0 so added fields are added. If displayedTable = 1 added fields don't repeat after display of upgraded tableable
		console.log('DTBtn has been clicked. In if tableConstructed ===1): If HERE AFTER A recent RERUN and tableConstructed must now = 1, meaning that DTB.ONCLIK the first time previous to this ran code through virgin run! If tableConstructed =1, then displayedTable will have been made = 0) 	and table has already been constructed so showTable is revealed without buildingTableRows... tableConstructed variable = ' + tableConstructed + ' displayedTable variable = ' + displayedTable + '. edit = ' + edit +'.');
		}//end if tableConstructed  === 1
		//else happens if tableConstructed = 0, in other words if comming from a rerun! In which case displayedTable should also be 0.
		else {
	showTable.setAttribute('class', 'showing');
	console.log('At displayTableBtn.onclick..else (tableConstructed is 0, not 1, and table screen is about to be cleared!: displayedTable = ' + displayedTable + '. tableConstructed = ' + tableConstructed + '. renewed (added record) = ' + renewed + '. refreshed (data cell edit) = ' + refreshed + '. edit = ' + edit + '. DTBtnTappedOnce = ' + DTBtnTappedOnce + '.');
	
	//next code clears the table display and then rebuilds it, including the field headers
	while (STrows.firstChild) {
   STrows.removeChild(STrows.firstChild);
}//end while
//to show field headings .. if there is a rerun you have to recobpnstruct the headings and rows on the first displayTableBtn press
//if rerun, after first time through displayed Table is set to 1 so second tap of displayTableBtn.onclick won't create the header row??
if (!displayedTable) {
	console.log('At if(!displayedTable) in the else part of displayTableBtn.onclick function, and tableConstructed is currently set to 0. displayedTable set to 0 means ..(A) if tableConstructed is 1, then displayedTable gets set to 0 after displayBtn.onclick, and code runs through tableConstructed = 1. (B) there has been no virgin run of creating a table, (i .e. code is first run, or code is running after rerun, so displayedTable and tableConstructed variables have been set to 0 at initialization.) AND this means STHeadRow has not yet had the extra fields titles added to it!! ? (C) First click of displayTableBtn.onclick after rerun? If AFTER RERUN!! after tapping Display Table Btn!  displayedTable will currently be set to 0 if comming from a rerun, OR if a virgin run of constructing records for the STShow screen has not yet been done..i.e. after newBtn.onclick to construct table for first time. Will now ADD table header and field header row to STRows, after table was cleared by code above.. displayedTable variable is now 0 so in displayTable() the added fields should be added to STHeadRow. Now going to displayTable() which constructs the record rows, and will tack on the extra fields if displayedTable and refreshed are 0.');
STrows.appendChild(STtableHeader);
//if (!changeDB) {
STrows.appendChild(STheadRow);
//}//end if !changeDB
//MAY NEED IF DTBtnTappedOnce = 1 then displayedTable = 1???
//displayedTable = 1;
}//end if !displayedTable

//refreshed = 1;
//above code clears the table display and then rebuilds it, including the field headers

	displayTable();
  }//end else .. if displayedTable = 1
 }; //end displayTableBtn.onclick
	
	
	tableInstructions = document.querySelector('#tableInstructions');
	tableInstructions.textContent = "INSTRUCTIONS FOR CREATING THE TABLE: \n Tap on the directions bar above to start creating a new table (NEW button will be active), or tap the EDIT button if it is activated, to make changes to a pre-existing table. The next screen is where you can add fields, delete fields, or change the text of the field labels. From this screen you can DISPLAY the current table, or return to the HOME screen. Note: If displaying the table you just created for the first time, the DISPLAY TABLE button will be highlighted in Green, indicating you must tap it prior to doing any editing, in order for the database to initialize the table. This only occurs once for the initial set up of the table.\n On the EDIT screen, the first 3 fields are FIXED fields which can not be deleted. There are 4 fixed fields (including the DATE field) that are automatically created from the Notes section when you make your first table. Their labels' headings text can be edited (the body text of the fixed fields can be edited in the Notes section), but these fields can not be deleted, nor can additional fixed fields be created. The other fields are DYNAMIC fields which you create when making your table on the Create/Edit window. At the initial table creation (after tapping the NEW button), the Green number input field is where you enter the number of dynamic fields you want to start off with. After the initial table creation, the NEW button is disabled, and returning to this window for subsequent table edits shows only the EDIT button and the DELETE FIELDS button to be active. When subsequently editing a table, the first step is to go to the number input window that appears at the bottom of the edit screen asking you to enter the number of additional fields you want to add. Enter 0 here if you do not want any more additional dynamic fields. The Green enter button indicates this is the required next button to tap. Then the Submit button above will change to Green, allowing the database to accept any text edits you made to the FIXED field labels above, and will also reveal text inputs to edit or label any additional DYNAMIC fields you added.\n USING NEW TABLES: \n DougieBase can create new tables using data from SEARCHED records OR from CONTACTS. If there are new tables for any particular database they are listed below. Tapping on the table name allows 'LOADING' or 'DELETING' the table. Tap the CONTACTS button in the table window to access your contacts on your device. (This requires the browser to have support for the javascript ContactsPickerAPI. In Safari iOS > 14.5 enable this in Safari settings/Experimental.) To customize a label for a new table use the CREATE TABLE button. This option is enabled AFTER the main database table has been initialized, by tapping the 'GREEN' DISPLAY TABLE button. ";

	returnToNotesBtn.onclick = function () {
		if(convertingOldFile) {
			returnToNotesBtn.setAttribute('class','tdEdit');
			returnToNotesBtn.textContent = "Return to HOME SCREEN";
			tableChosenP.textContent = "";
			displayTableBtn.disabled = false;
			newDBBtn.setAttribute('class','borderBlink');
			newDBBtn.textContent = "CONVERT";
			//convertingOldFile = false;
			
		}//end if convertingOldFile
		//added these lines Dec 6 !!!!
	//ADDED DEC 29...if there is no refreshTableP you can't remove what was never there!		
	if (tableNeedsUpdate) {
		tableScreen.removeChild(refreshTableP);
		 tableScreen.removeChild(refreshTableBtn);
		 displayTableBtn.disabled = false;
		}//end if (tableNeedsUpdate) ..ADDED DEC29
//	ReferenceError: Can't find variable: clearTableWindowEditBtn
//TypeError: null is not an object (evaluating 'clearTableWindowEditBtn.setAttribute')	

//set Table btn to flash indicating in process of renaming table
if(renameNewTableFlag) {
tableScreenBtn.setAttribute('class','borderBlinkGrn');
displayTableBtn.setAttribute('class','borderBlinkGrn');
returnToNotesBtn.setAttribute('class','tdEdit');

}//end if(renameNewTableFlag)
	//loadFromTableOptions = false;//to prevent new table loading instead of main table on tap of displayTableBtn May14 2022 NOPE! DOES NOT WORK CAUSES A REFRESH TABLE SCENARIO!!!!!!
	clearTableWindowEditBtn.setAttribute('class','tdEdit');
	clearTableWindow.setAttribute('class','attentionBtn');
		tableScreen.setAttribute('class','hidden');
	}//end returnToNotesBtn.onclick
	
//name new table below
//NOTE THE await FUNCTION HAS TO BE CALLED WITHIN AN async Function!!?,?,!Date: Jan26 2022
nameNewTableBtn.onclick = async function () {

checkTableLimit();
if (tableLimit) {
tableLimit = false;
showTable.setAttribute('class','hidden');
return;	
}

		if (tableExists & DTBtnTappedOnce === 0) {
		alert('You need to initialize the table first by tapping DISPLAY TABLE at least once!');	//tableScreen.setAttribute('class','hidden');
			createTableWindow.setAttribute('class', 'hidden');	
			//displayTable();
			//newTableNameWin.setAttribute('class', 'showing');
		} else {//end if DTBtnTappedOnce === 0 March 20
		//Tap here to create table or edit an existing one .. see HTML
	/*prefWindow.removeChild(notifyP);*/
manualContactsEntered = false;//otherwise ADDRESS field is added in setUpNewTable which conflicts with number of added fields and messes up! 
	tableScreen.setAttribute('class','hidden');
	newTableNameWin.setAttribute('class', 'showing');	
	//alert("tapped NAME/CREATE TABLE BTN:  dataBaseName should display? " + dbName);
	//newTableTitle.style.color = "white";
	newTableTitle.textContent = dbName;
	//newTableTitle.textContent = dataBaseName;
	//dbName at this point has been set to newTableTitle in setupNewTable function
}//end if DTBtnTappedOnce === 0 
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	newTableNameWin.style.backgroundColor = "black";
	newTableNameWin.style.color = "white";
	showNewTableNameP.style.color = "white";
} else {
	newTableNameWin.style.backgroundColor = "#eee";
	newTableNameWin.style.color = "black";
	showNewTableNameP.style.color = "black";
}//end if else screenDark
	getNewTableName();
//}//end if DTBtnTappedOnce === 0 

//ADDED THIS CODE FOR SMOOTHER OPERATION .???.REMOVE?????Date: Jan24
makeContactsTable= true;

await allContactInfo(selectedContact);
//SyntaxError: Unexpected identifier 'allContactInfo' when await preceded function call

for(i=0;i<selectedContact.length;i++) {
contactsArray[i] = cutName(selectedContact[i]);
console.log(Array.isArray(contactsArray[i]));
//alert(arr);
}//end for i

today = new Date();
 todayS = today.toString();
 todayString = todayS.slice(3, 21);
 //alert('todayString = ' + todayString);

for(i=0;i<selectedContact.length;i++) {
contactsArray[i].splice(1, 0,todayString);
}//end for i
homeScreenBtn.textContent = "Clear CONTACTS Table";
homeScreenBtn2.textContent = "Clear CONTACTS Table";
//clearFoundRecordListFunc(); //use line below instead?
flipMenu.textContent = " ✅ New Table Name: " + newTableNames[tableIndex] + ". " + newTableName;
saveTableBtn.setAttribute('class','borderBlink');
saveTableBtn2.setAttribute('class','borderBlink');
homeScreenBtn.disabled = true;//to help force Save..now reset after flashing SAVE Date Mar 24
			 homeScreenBtn2.disabled = true;
moreTablesBtn.disabled = true;
setupNewTable();
//ADDED THIS CODE ABOVE FOR SMOOTHER OPERATION .???.REMOVE?????Date: Jan24

};//end newTableNameWinBtn.onclick

//name new table above
if(dbTableName.value.includes("creatingDB")) {
	clearTableWindowEditBtn.click();//in creating new db skip right to edit NEWtable window added Feb12
	}//end if(dbTableName.value.includes("creatingDB"))//removed because new db got messed up in rename phase
}//end tableScreenOptions function




// javascript for createTable below
  //CREATE TABLE
	  
	  //when adding to IndexedDDNotes make all of this a function called createTable
	  //function createTable () {}//end function createTable
	  const createTableWindow = document.querySelector('#createTableWin');
	 // SyntaxError: Cannot declare a const variable twice: 'tableName'.
		const tableName = document.querySelector('#databaseTableName');//h2 HTML
		const showTableName = document.querySelector('#showTableName');//h2 HTML of showTable section
		const saveTableBtn = document.querySelector('#saveTableBtn');//saveTableBtn declared as global variable because it is accessed in several places
		const saveTableBtn2 = document.querySelector('#saveTableBtn2');//saveTableBtn declared as global variable 
		//alert('at start of table code...dbTableName.value = ' + dbTableName.value);
		const additionalFields = document.querySelector('#additionalFields');//number of new fields required input HTML
		const headNameFirstColumn = document.querySelector('#headNameFirstColumn');//input tag  HTML
		const headName = document.querySelector('#headName');//<td>first column HTML list name text I.e. Locomotive 
		//ST stands for ShowTable Window
		const STheadName = document.querySelector('#STheadName');//<td>first column HTML list name text in showTable window (First td cell in field header row)
		//Date: Feb 2 2021 reference for STcreationDate was commented out up until Feb 2. Not sure why but it is needed to put the DATE field label back in the STheadRow after cLearing the field labels after a call to deleteField so the field labels can be reconstructed
		const secondFieldName = document.querySelector('#STcreationDate');//<td> HTML reference. second field title is DATE .. in capitals because fieldArray[2] is assigned ' DATE' (see makeTable function). In HTML it is 'Date'. 
		const thirdFieldNameInput = document.querySelector('#nameDataField1');//i.e. location
		const fourthFieldNameInput = document.querySelector('#nameDataField2');//i.e. Decoder
		const firstDataNameTd = document.querySelector('#firstData');
		const secondDataNameTd = document.querySelector('#secondData');
		const headRow = document.querySelector('#headRow');//first row header section <tr>
		const STfirstDataNameTd = document.querySelector('#STfirstData');
		const STsecondDataNameTd = document.querySelector('#STsecondData');
		const STheadRow = document.querySelector('#STheadRow');//first row header section <tr>
		const nextFieldHeading = document.createElement('td');
		const STnextFieldHeading = document.createElement('td');
		
		const submitButton = document.createElement('button');//submit data in record cells of extra added fields
		const nextFieldHeadingInput = document.createElement('input');//get name of next additional required field
	 const submitBtn = document. querySelector('#submitBtn');//enter column heading titles..1 bin to submit headings
		const thirdFieldP = document.querySelector('#info');
		const fourthFieldP = document.querySelector('#info2');
		const createTable = document.querySelector('#createTable');//div HTML
		const STcreateTable = document.querySelector('#STcreateTable');//div HTML in showTable window
		const STthirdFieldP = document.querySelector('#STinfo');
		const STfourthFieldP = document.querySelector('#STinfo2');
		
		// const showTable = document.querySelector('#tableWin');//div HTML section id="tableWin" should this be referenced earlier because clearTableWin useS it at line 3003 put at top 
		const rows = document.querySelector('#forRows')//<Table>HTML
		const STrows = document.querySelector('#STforRows')//<Table>HTML
		const buildRecordsP = document.createElement('p');
		const saveTableP = document.createElement('p');
		const addFieldsDirectionP = document.createElement('h4');//make global so the text can be changed 
		
		const tdInput = document.createElement('input');//buildRecordRows function
		const submitTdInputBtn = document .createElement('button');//buildRecordRows function
		const recordTd=document.createElement('td');//add td cell to row.buildRecordRows function needs to be here so it is a global variable??code to make an edit function did not work!maybe need to comment out these const .. left in and still works
		
		//reference elements for edit dynamic fields and make available to required functions
		const addToDynamicFields = document.createElement('p');
		const moreFieldsInput = document.createElement('input');
	//REMOVE IF MISTAKE! Mar16
	moreFieldsInput.setAttribute('type','number');
		const fieldsBtn = document.createElement('button');
		
		//reference elements in showTable window
		
		const str =new Date();
	const d = str.toString();
	date = d.slice(3, 21);//was const date.gave error cannot declare a constant variable twice
	//headRow.setAttribute('class','border: 2px solid red;')
	//required variables
	// let h3.textConttent;//record item title
	// let dateP.textContent;//date created
	// let para.textContent;//text of record frst p ddata data
	// let displayXtraField.textContent;//data of extra field
/*	let newFieldName;//title of 2nd field
	let nextFieldName;//title of subsequent fields as determined by input in a for loop
	let numberOfFields;//the counter to use in the for loop
	let numberOfDynamicFields;//number of new required fields
	let fieldContent;//the text of the td cell in the table row as determined in the for loop. */

//!!!!HERE I HAVE DECLARED dbTableName twice..first time in notes set up. might this be the problem??'dbTableName = undefined'
	//let dbTableName = "Locomotive Roster";//dbTableName variable from Notes program
	//let listName;
	const tableHeader = document.querySelector('#thheader');//thead HTML
	const STtableHeader = document.querySelector('#STthheader');//thead HTML
	//alert('in table code..dbTableName.value = ' + dbTableName.value);
		//update h2 HTML Apr11
	tableName.textContent =  "Table for Database named : " + dbTableName.value;
	//tableName.textContent =
	tableHeader.textContent = dbTableName.value;//was dbTableName which returned objectHTMLHeadingElement
	tableHeader.setAttribute('class','attentionBtn');
	STtableHeader.textContent = dbTableName.value;
	
	//global 2 dimensional array has to be built in displayData() tableArray has now been created. will save this in notesdb. not sure displayArray is needed!
	//let displayArray = ["primary", "primary"];
	//let tableArray = [[],[]];
	//let tableArray = [[],[]];
	
	
	//creating variables for tables that will be replaced with the variables in IndexedDBNotes
	//may not need let counter = 3?erroe can not declare a let variable twice
	//counter = 3;//the number of records-rows in the database..remember first record contains admin data and variables ..does not count!!
	//let tableTitle = ['CN6035', 'CN3205', 'CN6700'];//tableTitle array needs to be created in dbNotes?BECAUSE IT WAS DECLARED TWICE PRODUCED TABLETITLE.LENGTH UNDEFINED ERROR,!!!
	let dateP = date;
	let tappedOnce = 0; //for table creation p buildRecordsP.onclick = function
	let entered = 0;//for edit mechanism at buildRecordRows function probably can remove because edit function using entered did not work??
	let edit = 0;//use for creating edit version of createTable
	let refreshed;//in make changes to prevent field names being generated twice.. also used in update refreshTable section did not set to 0 so field headings are not repeated in displayTable
	//let dateP = new Date();//get from IndexedDBNotes
// 	let paraBody = ['Y2Trk2','Y3Trk2','Y3Trk8'];
// 	let displayXtraFieldData = ['TSU-1100','Econami-PNP','TSU-1100'];
// 	//all above will be variables from IndexedDBNotes
// 	//create the 2D array tableArray

//!!!!!!!!IF tableArray is not declared here, the table is not built. So somehow tableArray is being lost in spite of declaring it at top??
//the problem was counter made = 0 at top so declaration of tableArray did not occur because i <counter. solution was to create a new variable recordCounter = 3, use this to declare tableArray at top. this worked
//!!!!!!!!!!!!!!!
// 	var tableArray = new Array(counter);

// for (var i = 0; i < counter; i++) {

// tableArray[i] = new Array(numberOfFields);

// }//number of fields means all fields

// //create fieldNamesArray
// let fieldNamesArray = [];

// //option to create new or edit existing table
// //this code will have to be put on the Table menu of indexedDBNotes when incorporating code into DBNotes
const newOrEdit = document.querySelector('#newOrEdit');
newOrEdit.setAttribute('class', 'simulator');
//newBtn goes to makeTable function with edit=0
const newBtn = document.createElement('button');
newBtn.setAttribute('class', 'borderBlinkGrn');//was attentionBtn.changed Dec3 2021
const editBtn = document.createElement('button');//are there 2 references for the edit Btn??Jan26 Date: Nov26 2021 Yes therebwere two editBtns..seemed to work but future references to editBtn may be confused? Should the declaration be back up at table screen options because editBtn along with new btn? Are referenced back there? ? Still seems to work though date:Feb15 2022..is this 'hoisting'?
newBtn.textContent = 'NEW';

	
const goHomeBtn = document.createElement('button');//Home Screen bin in the NeworEditP on the CreateTable window
goHomeBtn.textContent = 'RETURN to HOME SCREEN';

//references for DELETE FIELD deleteField window etc
const deleteFieldBtn = document.createElement('button');
//console.log('DTBtnTappedOnce = ' + DTBtnTappedOnce);
if (DTBtnTappedOnce === 0) {
	deleteFieldBtn.disabled=true;
	//do you have to do the same for the edit Btn?
	} else {
		deleteFieldBtn.disabled = false;
}//end if DTBtnTappedOnce = 1

// if(dbTableName.value.includes("creatingDB")) {
// goHomeBtn.style.display = "none";
// } else {
// goHomeBtn.style.display = "unset";
// 	//newOrEdit.removeChild(goHomeBtn);	
// 	}//end if else (dataBaseName.includes("creatingDB"))

const deleteFieldWindow = document.querySelector('#deleteFieldWin');
const deleteFieldTableName = document.querySelector('#deleteFieldTableName');
//fieldHeaders is a div in HTML that allows referencing to in orider to properly place the field headers
const fieldHeaders = document.querySelector('#fieldHeaders');
const backToEditBtn = document.querySelector('#backToEdit');
const cancelToNotesBtn = document.querySelector('#cancelToNotes');
const selectedFieldInput = document.querySelector('#myFields');
const dataList = document.querySelector('#fieldList');
const chosenFieldInfo = document.querySelector('#chosenField');
const submitFieldSelectionBtn =  document.querySelector('#submitFieldSelection');
//let copyOfTableArray = tableArray;
//const copyOfFieldNamesArray = fieldNamesArray;
//above code should be:Feb 11
// let copyOfTableArray = tableArray.slice();
// //let copyOfTableTitle = tableTitle.slice();
const copyOfFieldNamesArray = fieldNamesArray.slice();
//const causes error 'attemp to assign to read only element? if reassigning...but let is ok?'
//const fieldOption = document.createElement('option');
//const fieldOption = document.querySelector('#');


//end references for deleteFieldWindow
//DELETE FIELD HTML AND JS REFERENCES ABOVE See function deleteTableField() below

//newOrEdit.appendChild(nl);
newOrEdit.appendChild(newBtn);
newOrEdit.appendChild(editBtn);
newOrEdit.appendChild(deleteFieldBtn);
newOrEdit.appendChild(goHomeBtn);
	//  addFieldWin.appendChild(doneRelabelBtn);
	//code added above Sept13 to add a cancel button 
	// if(dbTableName.value.includes("creatingDB")) {
	// newOrEdit.removeChild(goHomeBtn);	
	// }//end if(dataBaseName.includes("creatingDB"))
		
//newOrEdit.appendChild(goHomeBtn);
//alert("At newOrEdit dbTableName.value = " + dbTableName.value);

if(dbTableName.value.includes("creatingDB")) {
goHomeBtn.style.display = "none";
} else {
goHomeBtn.style.display = "unset";
	//newOrEdit.removeChild(goHomeBtn);	
	}//end if else (dataBaseName.includes("creatingDB"))


newBtn.onclick = function() {
returnToNotesBtn.disabled = false;;
	//code for guiding create newDB
		//will set newDBGuidance = false in new table code section
		if (newDBGuidance) {
		newDBGuidance = false;
		creationDONE = true;//flag for below
		creationDONEName = dataBaseName;
		//SHOULD I put flag to indicate createNew db is now finished so next getFileNames will initiate removing .createNewDB DATE: Jan28 2023
		//alert("Remember to create the table for the new database BEFORE ADDING ANY NEW RECORDS!");
		
		//disable ADD NOTE and activate TABLE
	addNoteBtn.setAttribute('class','attentionBtn');
  addNoteBtn.disabled = false;
  settingsBtn.setAttribute('class', 'tdEdit');//preferences	
  tableScreenBtn.setAttribute('class','tdEdit');
  NotesEditBtn.setAttribute('class','tdEdit');
  
  }//end if newDBGuidance
	//end code for guiding create newDB
	
	
	fromNew = true;
	console.log('At newBtn.onclick...tableExists = ' + tableExists + '. edit =  ' + edit);
	newBtn.setAttribute('class', 'normalBtn');
	editBtn.setAttribute('class','attentionBtn');
		editBtn.disabled = false;
		deleteFieldBtn.setAttribute('class','attentionBtn');
		deleteFieldBtn.disabled = false;
		newBtn.disabled = true;
		//activate # dynamic fields entry input
		additionalFields.disabled = false;
	//alert('at newBtn.onclick...dbTableName.value = ' + dbTableName.value);
	tableHeader.textContent = dbTableName.value;//to refresh thheader in HTMLi.e. Locomotive Roster 
	tableExists = 1;
	edit = 0;
	// buildingTableArrays = 1;//this variable enables displayData to construct the tableTitle and paraBody arrays
	// displayData(); //createbarrays might not need this because arrays are created anyway??
	
	// // buildingTableArrays = 0;//turn off the switch so displayData doesn't create the arrays repeatedly may not need this switch????
	
	
	originalNumberRecords = tableTitle.length;//use to give refresh table option
	console.log('tableTitle[] = ' + tableTitle);
	console.log('paraBody[] = ' + paraBody);
	console.log('displayXtraFieldData[] = ' + displayXtraFieldData);
	
	makeTable();
}//end function newBtn.onclick

editBtn.onclick = function () {
createTableWindow.scrollTop = createTableWindow.scrollHeight;//to scroll to bottom remove if messed up date Mar19 2023
dataAltered = true;//flag to provide warning if data changed but not saved 
	deleteFieldBtn.setAttribute('class','attentionBtn');
	if(!loadFromTableOptions) {
		mainDBedit = true
		doThis = true;//will be set to false in displayTable
		}//end !loadFromTableOptions	
	//-
	changeDB = true;//flag to tell load newtable to go into start from scratch mode !!!????
	//-
	if(loadFromTableOptions) {
		newTableEdit = true;//flag to tell displayTable to create new 'edited field names in a new table' ?not used anymore?
		blockEdit = true;//flag to prevent savedTablesArray getting messed up prevent dblClick edit of td cell if just finished editing layout of table via editBtn.onclick..because otherwise tableArray will no longer be in newTable mode and savedTablesArray will get messed up
	}//end if loadFromTableOptions
//code to clean up create new table screen to prepare for edit table
	if(fromNew) {
		fromNew = false;
	//empirically added line below
	createTable.removeChild(saveTableP);
	createTable.removeChild(addFieldsDirectionP);
	createTable.removeChild(buildRecordsP);
}//end if from new
//code to clean up create new table screen to prepare for edit table	

	fromNew = false;
	console.log('At editBtn.onclick...tableExists = ' + tableExists + '. edit =  ' + edit);
	
		//update h2 HTML Apr11
	tableName.textContent =  "Table for Database named : " + dbTableName.value;
	//tableName.textContent =
	
	tableHeader.textContent = dbTableName.value;//to refresh thheader in HTML
	editBtn.setAttribute('class', 'normalBtn');
clearTableWindow.setAttribute('class','simulator');
	//edit = 0;//get to make changes and edit = 1
	additionalFields.disabled = true;//disable dynamic field input here.
	//!?
	edit = 1;
	//!?
	editCurrentTable = 1;//so displayTable workS correctly when editing a table that pre-exists
	//? Delete has set variable fromDeleteField = true;
	//clearTableWindow no difference if here or not?!
	// while (rows.firstChild) {
	// rows.removeChild(rows.firstChild);
	//  }//end while
	//Nov13 to restore STHeadRow to original prior to tacking on fields
	originalNumberOfFields = fieldNamesArray.length;
	
	//alertx("In editBtn.onclick —- fieldNamesArray = " + fieldNamesArray + ".  Before edit, numberOfDynamicFields =  " + numberOfDynamicFields);
	
	console.log("In editBtn.onclick —- fieldNamesArray = " + fieldNamesArray + ".  Before edit, numberOfDynamicFields =  " + numberOfDynamicFields);
	
	console.log('At editBtn.onclick. numberOfDynamicFields = ' + numberOfDynamicFields);
	
	editMoreFields();//input for number of additional fields requested
	
	//clear STShow screen
	// while (STrows.firstChild) {
	// 	STrows.removeChild(STrows.firstChild);
	// }//end while
	//AT EDIT BTN TOOK OUT APPEND STHEADROW NOV 14!,!,!,! NO DIFFERENCE IF HERE OR NOT!!!!!!
//STrows.appendChild(STtableHeader);
//STrows.appendChild(STheadRow);	
		//renewed = 1;//trying to make STShow display correctly after edit
// 	while (createTable.firstChild) {
//    createTable.removeChild(createTable.firstChild);
//
	makeTable();
}//end editBtn.onclick

deleteFieldBtn.onclick = function() {
dataAltered = true;//flag to provide warning if data changed but not saved 
	console.log('deleteFieldBtn has been clicked');
deleteFieldBtn.setAttribute('class','attentionBtn');
clearTableWindow.setAttribute('class','simulator');	deleteFieldWindow.setAttribute('class', 'showing');
	
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	deleteFieldWindow.style.backgroundColor = "black";
	deleteFieldWindow.style.color = "white";
	dbNameInfo.style.color = "black";
} else {
	deleteFieldWindow.style.backgroundColor = "#eee";
	deleteFieldWindow.style.color = "black";
	//dbNameInfo.style.color = "black";
}//end if else screenDark

	deleteFieldTableName.textContent = "DELETE a field\/column from the table in: " + dbTableName.value;
	
		dbNameInfo.textContent = dbTableName.value;
		deleteFieldTableName.appendChild(dbNameInfo);
	
	deleteTableField ();
}//end deleteFieldBtn.onclick

goHomeBtn.onclick = function () {
		console.log('goHomeBtn clicked');	createTableWindow.setAttribute('class', 'hidden');
	clearTableWindow.setAttribute('class','simulator');
		//REMOVE IF SCREWED UP Jan 18
		if(edit ===1) {
		//remove how many more fields to you wish to edit...Dynamic fields input.....Do I have to remove the input and enter Btn as well? Or will they go with addToDynamicFields
	//LEFT OFF HERE JAN 18	createTableWindow.removeChild(addToDynamicFields)
	
	//clear moreFieldsInput.value in prep for next edit Sept16
	moreFieldsInput.value = "";
	
	removeEditMoreFieldsElements();
		}//end if edit = 1
		
//added this line May5 2022 to avoid displayTableBtn showing new table screen and not cancelling loadFromTableOptions
//resetFromContacts(); NOPE DOES NOT WORK,!! Messes up displayTable from main db table



		}//end gohomeScreenBtn.onclick

//start function makeTable called by editBtn.onclick
function makeTable () {
	console.log('At start makeTable()...tableExists = ' + tableExists + '. edit =  ' + edit);
	fromMakeTable = 1;//to keep warning to create a table first if displayTable btn tapped after a table has been created
	if(edit === 1) {
		additionalFields.value = numberOfDynamicFields;
		headNameFirstColumn.value = fieldNamesArray[0] ;
		thirdFieldNameInput.value = fieldNamesArray[2] ;
		fourthFieldNameInput.value = fieldNamesArray[3] ;
		//editBtn.setAttribute('class', 'normalBtn');
		
	}//end if edit

	//show create table window
	createTableWindow.setAttribute('class', 'showing');	
	
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	createTableWindow.style.backgroundColor = "black";
	createTableWindow.style.color = "white";
} else {
	createTableWindow.style.backgroundColor = "#eee";
	createTableWindow.style.color = "black";
}//end if else screenDark
	//window.onload = function() {
		//error 'the object can not be found here if comimg from edit make changes'
	// 	if (edit === 0) {
	// 		//leave new or edit option bar so it can be used for future edits
	// createTableWindow.removeChild(newOrEdit);
    // }//end if edit === 0
	submitBtn.setAttribute('class','attentionBtn');
	submitBtn.disabled = false;
	if(edit === 1) {
		submitBtn.setAttribute('class','normalBtn');
			submitBtn.disabled = true;
	}//end if edit = 1
	submitBtn.onclick = function () {
	
	//scroll to bottom of window
	createTableWindow.scrollTop = createTableWindow.scrollHeight;
	//scroll to bottom of window
		console.log('At submitBtn.onclick. ..edit = '+ edit);
		if(edit === 1) {
		editBtn.setAttribute('class', 'attentionBtn');	
		}//end if edit = 1
		//e.stopPropagation();//remove if trouble 
	//alert('dbTableName.value = ' + dbTableName.value);
		tableName.textContent =  "Table for Database named : " + dbTableName.value;
	numberOfFields = Number(additionalFields.value) + 4;
	//alert('numberOfFields = ' + numberOfFields);
	// if(edit) {
	// 	additionalFields.value = numberOfDynamicFields;
	// }//end if edit
	//numberOfFields is the total number of fields which includes the initial static 4 plus all other fields added to the initial 4...fieldNamesArray.length
	//originalNumberOfFields = fieldNamesArray.length before any edit!
	//numberOfDynamicFields = THE NUMBER OF FIELDS BEYOND THE INITIAL STATIC 4. This number can keep increasing as you add more fields, so is a dynamic number. This currently is the number entered into the green input line 'number of additional fields. '
	numberOfDynamicFields = additionalFields.value;
	//alert('numberOfDynamicFields = ' + numberOfDynamicFields);
	// if(edit) {
	// 	headNameFirstColumn.value = fieldNamesArray[0] ;
	// }//end if edit
	headName.textContent = headNameFirstColumn.value;//listName header first column..I.e. Locomotive
	//add headName to fieldNamesArray
	fieldNamesArray[0] = headName.textContent;
	tableHeader.setAttribute('style', 'colspan: numberOfFields', 'simulator','width: 100%');
	//alert('thirdFieldNameInput.value = ' + thirdFieldNameInput.value);
	//	firstDataNameTd.value =

	//thirdFieldNameInput.value;//3rd field name title info taken from cursor.body.value in cursor iteration of current database
	fieldNamesArray[1] = ' DATE ';
	// if(edit) {
	// 	thirdFieldNameInput.value = fieldNamesArray[2] ;
	// }//end if edit
	firstDataNameTd.textContent = thirdFieldNameInput.value;
	fieldNamesArray[2] = firstDataNameTd.textContent;//I.e. Location
	submitBtn.setAttribute('class','normalBtn ');
	submitBtn.disabled = true;
	//headRow.appendChild(firstDataNameTd);not needed because already appended in HTML????
	// if(edit) {
	// 	fourthFieldNameInput.value = fieldNamesArray[3] ;
	// }//end if edit
	secondDataNameTd.textContent = fourthFieldNameInput.value;
	fieldNamesArray[3] = secondDataNameTd.textContent;//I.e.Decoder 
	//headRow.appendChild(secondDataNameTd);this line not needed because secondDataNameTd is already in the HTML
	
	
//	thirdFieldP.textContent = thirdFieldNameInput.value;
	//	alert('firstDataNameTd.value = ' +firstDataNameTd.value);
//}//end submitBtn.onclick
// 	thirdFieldNameInput.onclick = function () {
		
// 	};
	
// 	thirdFieldNameInput.addEventListener('input', function () {
// 	secondDataNameTd.value = fourthFieldNameInput.value;//4th field name title info taken from cursor.body.value in cursor iteration of current database
// });
	//directions info P..h3 declared as global variable
//	const addFieldsDirectionP = document.createElement('h4');
if(edit === 1) {
	addFieldsDirectionP.textContent = 'Make changes to the Dynamic Field titles below:  ⬇️';
} else if (edit === 0) {
	addFieldsDirectionP.textContent = 'Enter the added field/column titles below: ';
}//end if else if edit construct
	createTable.appendChild(addFieldsDirectionP);
	//create the inputs for  added fields required
	for (let j = 1; j <= numberOfDynamicFields; j++) {
	//alert('i = ' + i);
	let k = 3+j;//for fieldNamesArray
const nextFieldHeadingInput = document.createElement('input');//the headings for the added fielDs..I.e. the fieldNames Array
const submitButton = document.createElement('button');//small green filled red dot
createTable.appendChild(nextFieldHeadingInput);
createTable.appendChild(submitButton);
submitButton.setAttribute('class','borderBlinkGrn');//was attentionBtn
if(edit === 1) {
		
		nextFieldHeadingInput.value = fieldNamesArray[k] ;
	}//end if edit
		submitButton.onclick = function () {
		//scroll to bottom of window
	createTableWindow.scrollTop = createTableWindow.scrollHeight;
	
	//scroll to bottom of window
			//alert('edit variable = '+ edit);
			//if the if statement is here the append to headRow does not happen. why??
		//	if (edit === 0) {
			//	alert('creating element nextFieldHeading td');
			const nextFieldHeading = document.createElement('td');
		//	}//end if !edit
			
			nextFieldHeading.textContent = nextFieldHeadingInput.value;
			fieldNamesArray[k] = nextFieldHeading.textContent;
			
			submitButton.setAttribute('class','normalBtn ');
		if (edit === 0) {
		//alert('About to append nextFieldHeading to headRow');
		headRow.appendChild(nextFieldHeading);
		
		}//end if edit = 0
		createTable.removeChild(nextFieldHeadingInput);
			createTable.removeChild(submitButton);
			
		}//end submitButton.onclick
	}//end of for loop
	
	//const buildRecordsP = document.createElement('p');//at top
	
createTable.appendChild(buildRecordsP);
buildRecordsP.setAttribute('class', 'simulator');
//buildRecordsP.disabled = false;
buildRecordsP.textContent = ' Enter titles of '+ numberOfDynamicFields + ' dynamic fields (By tapping the green buttons). When satisfied with entries tap here to continue!';
	blockEdit = true;//ADDED Oct10 2022 to nitialize table before doing a double tap on the edited field title  REMOVE IF MESSES UPflag to prevent savedTablesArray getting messed up
	
	homeScreenBtn.setAttribute('class','borderBlink');
	homeScreenBtn2.setAttribute('class','borderBlink');
	
	}//end submitBtn.onclick needs to be here instead of higher up

//create tableArray variable 2D array
// now create the vertical rows for records
//the number of row iterations will be = counter
//var additionalFieldsArray = Create2DArray(counter,numberOfDynamicFields);

buildRecordsP.onclick = function () {
//WOULD BE NICE IF i could scroll to bottom!
const scrollToBottom = (id) => {
	 const element = document.getElementById(id);
   element.scrollTop = element.scrollHeight;
}	
scrollToBottom('createTable');//this is a function expression..element id is passed as a parameter to the scrollToBottom function expression.
//WOULD BE NICE IF i could scroll to bottom!
//code line below does not seem to work?
//createTable.scrollTop = createTable.scrollHeight;
//line below did not work either
//createTableWindow.scrollTop = createTableWindow.scrollHeight;

createTableWindow
	console.log('At buildRecordsP.onclick');
	if (edit === 1) {
		addFieldsDirectionP.textContent = 'Make changes to labels of added fields below.';
		//removeChild(buildRecordsP if edit === 1??)
		buildRecordsP.textContent = 'Make changes to added field titles/labels! When finished tap here to SAVE TABLE';
		//might have to remove this line
		createTable.removeChild(buildRecordsP);
	} else {
	addFieldsDirectionP.textContent = 'Now enter data into the added fields.';
	buildRecordsP.textContent = 'Now enter data into the fields! When finished tap here to SAVE TABLE';
}//end if edit === 1
	//remove fieldName entry inputs
	//while (createTable.nextFieldHeadingInput) {
	//buildRecordsP.disabled = true;	//this does not disable the buildRecordsP why??
	//}//end while submitBtn
	if (tappedOnce) {saveTable();}//end if tappedOnce
	if (!tappedOnce) {
	buildRecordRows();
	}//end if !tappedOnce
	tappedOnce = 1;
	//Nov12
	if(edit === 1) {
		saveTable();
	}//end if edit = 1
	//Nov 12
}//end buildRecordsP.onclick
	


//}//end function createTable

function saveTable () {
	//save table variable values in some kind of array
	console.log('At start saveTable');
	saveTableP.setAttribute('class','simulator');
	saveTableP.textContent = 'Table is SAVED! Tap here to see results.';
	//may need to put line below in if (edit===0) statement
	createTable.appendChild(saveTableP);
	saveTableP.onclick = function () {
		if (edit === 1) {
			console.log('In makeTable()..edit is currently 1 and about to be set to 0. saveTableP(Table is saved Tap here to see results)  is about to be removed. If edit is made 0 here how does that effect displayTable later? tappedOnce = '+ tappedOnce);
			//might remove edit = 0 NOPE!!program stops running if you remove edit =0!line 2892  so displayTable works?
			edit = 0;//Nov12 necessary to have field label inputs to appear
			//may need to removeline below??
		createTable.removeChild(saveTableP);	
		}//end of if edit
		//change color of to make changes direction to green from pink
		saveTableP.setAttribute('class','edBan');
		saveTableP.textContent ='To make changes or add columns go back to Edit from the displayed table.';// Make Changes button!'; 
		//tableArray[1][4] = ' + tableArray[1][4];
		// alert('255 .. tableArray[0][6] = ' + tableArray[0][6]);
		// alert('In SAVE table function : 190? tableArray[2][6] = ' + tableArray[2][6]);
		
	// for(let i = 0;i<counter;i++) {
	// 		for(let j=0;j<numberOfFields;j++) {
	// 			console.log('tableArray[' +i + '][' + j +'] = ' + tableArray[i][j]);
				
				
				
	// 			//statement above gave an undefined is not an object error when evaluating tableArray[i] [j] and resolved when I commented it out?? array worked after that??
	// 			//console.log('tableArray[' +i + '][' + j +'] = ' + tableArray[i][j]);
				
	// 		}//end for j =
			
			
	// 	}//end for i =
		
		//give option to make changes		

	const showOrEdit = document.createElement('p');
	const anl = document.createElement('br');
showOrEdit.setAttribute('class', 'simulator');
showOrEdit.textContent = 'Tap DISPLAY TABLE to show the finished Table. ';//or use EDIT to Make CHANGES.'
const showBtn = document.createElement('button');
const changesBtn = document.createElement('button');
//show tn goes to displayTable function
//changes button goes to makeTableFunction with edit=1
showBtn.textContent = 'DISPLAY TABLE';
changesBtn.textContent = 'Make CHANGES';
createTable.appendChild(showOrEdit);
showOrEdit.appendChild(anl);
showOrEdit.appendChild(showBtn);
//disabled makeChanges Btn as can't get display to work,!
// if (!fromNew) {
// showOrEdit.appendChild(changesBtn);
// }//end if !fromNew
//showOrEdit.appendChild(changesBtn);
//showBtn from createTable goes to displayTable function
showBtn.onclick = function () {

//alertx("ShowBtn.onclick..tableID = "+ tableID + ".  loadFromTableOptions = " + loadFromTableOptions + ".  makeContactsTable = " + makeContactsTable + ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[tableID][1] = " + newTableSpecificVariables[tableID][1] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + ".  savedTablesArray[tableID] = " +  savedTablesArray[tableID]);

console.log("ShowBtn.onclick..tableID = "+ tableID + ".  loadFromTableOptions = " + loadFromTableOptions + ".  makeContactsTable = " + makeContactsTable + ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[tableID][1] = " + newTableSpecificVariables[tableID][1] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + ".  savedTablesArray[tableID] = " +  savedTablesArray[tableID]);


	//code to disable goToHomeScreen btn so table is not messed up if user taps returnToHome screen after having entered a number into the add dynamic fields input..forces finish of this process
	goHomeBtn.disabled = false;
	console.log('At showBtn.onclick..DISPLAY TABLE');
	createTable.removeChild(showOrEdit);
	//should I clear all rows be here if coming from edit? To prevent repeat of all records
	//!!!!!REMOVE CODE BELOW IF SCREW UP!
	//Nov 12
	if (editCurrentTable === 1){
		//removeFieldHeaders();//removed this line because'object not found here' error...this was after I added the add more dynamic fields code Nov 26. Now works. Not sure what the issue is?
		//delete field has used a removeFieldHeaders();function at this point then remove STRows
	while (STrows.firstChild) {
    STrows.removeChild(STrows.firstChild);
	}//end while	
	
		//to force displayTable to recreate STHeadRow set displayedTable varial even to 0;if removing edit =0 at line 2902
		displayedTable = 0;//Nov12
		//not sure refreshed = 0 is necessary here Nov 15?
		refreshed = 0;//Nov 13 to make sure displayTable tacks on the extra fields in case an edit data cell was performed prior to being here.
		//why tableConstructed = 0 here? INitial intention to force a STHeadRow display? But tableConstructed set to 1 immediately in displayTable so not sure the line below does anything? REMOVED NOV 16 
		//tableConstructed = 0;
		edit = 0;
		STtableHeader.textContent = dbTableName.value;
		//STrows.removeChild(STheadRow);//NotFoundError: The object can not be found here.
// STtableHeader.setAttribute('class','attentionBtn');
// STrows.appendChild(STtableHeader);
// STrows.appendChild(STheadRow);
	}//end if editCurrentTable =1
	//!!!!!!!!REMOVE CODE ABOVE IF SCREW UP!
	//Nov 13
	//displayTable();
//DON'T SAVE TABLEARRAY IF IN NEWTABLE MODE!
if(!loadFromTableOptions) {
	dataVobj.tableArray = tableArray;
		console.log('At saving current table values! and going to saveVariables. dataVobj.tableArray = ' + dataVobj.tableArray);
		saveVariables();
	//deleteField has this line here:
	//changeDBtable();//to keep field names from getting messed up Date: Feb13
	changeDB = true;//this puts field headers in place after an edit of main db then going to new table
		displayTable();
	}//end if(!loadFromTableOptions) 
		
if (loadFromTableOptions) {
	
		
		
		newTableFieldsArray = fieldNamesArray.slice();
		newTableSpecificVariables[loadTableIndex][1] = newTableFieldsArray.slice();
		
		numberOfNewTableAddedFields = numberOfDynamicFields;
		//numberOfNewTableAddedFields = newTableVariablesArray[4];
		savedTablesArray[loadTableIndex]=tableArray.slice();
		
		//alertx("Display Table btn has been tapped! (showBtn.onclick)..Edited newtable: tableArray = " + tableArray + ".  savedTablesArray[loadTableIndex] = " +savedTablesArray[loadTableIndex] + ".  newTableFieldsArray = " + newTableFieldsArray + ".  numberOfNewTableAddedFields = " + numberOfNewTableAddedFields + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1]);
		
		console.log("Display Table btn has been tapped! (showBtn.onclick)..Edited newtable: tableArray = " + tableArray + ".  savedTablesArray[loadTableIndex] = " +savedTablesArray[loadTableIndex] + ".  newTableFieldsArray = " + newTableFieldsArray + ".  numberOfNewTableAddedFields = " + numberOfNewTableAddedFields + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1]);
		
		//deleteField does not have this line here but puts it above in if(!loadFromTableOptions
		
		//- ?
		changeDBtable();//to keep field names from getting messed up Date: Feb13
		changeDB = true;//this puts field headers in place after an edit of main db then going to new table
/*		Table is cleared above
		REMOVE HEAD ROW THEN RECONSTRUCT HEAD ROW..BUT NOT ADDED TO STROWS…CHANGEdb set to false
		
	*/	
		
		/***********************/
		//edit = 1;
		//ADD A FLAG AND ADD THE FIXED FIELDS JUST BEFORE ADDING THE DYNAMIC FIELDS
	//***************************//
		//flag to correct messed up fieldHeaders from a newTable edit
		
	adjustFields = true;	
		
	//*****************************
		//setUpFieldHeaders();
		//changeDB = true;//added Feb14 trying to msake field headers behave
		
		//***************************//
		displayTable();
		
		//alertx("In showTable edit routine: After call to displayTable: loadFromTableOptions = " + loadFromTableOptions + ". loadTableIndex = " + loadTableIndex + ".   newTableSpecificVariables[loadTableIndex][1] =  " +newTableSpecificVariables[loadTableIndex][1]);
		
		//alertx("loadFromTableOptions = " + loadFromTableOptions +  ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1]);
		
		console.log("In showTable edit routine: After call to displayTable: loadFromTableOptions = " + loadFromTableOptions + ". loadTableIndex = " + loadTableIndex + ".   newTableSpecificVariables[loadTableIndex][1] =  " +newTableSpecificVariables[loadTableIndex][1]);
		
		console.log("loadFromTableOptions = " + loadFromTableOptions +  ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1]);
		
		
//return false;		
		//clearTableRows();
/*	WHICH VERSION?	
if(loadFromTableOptions) {
	savedTablesArray[loadTableIndex]=tableArray.slice();
	newTableFieldsArray = fieldNamesArray.slice();
	numberOfNewTableAddedFields = numberOfDynamicFields;
	
	alert("deleteFields completed: tableArray = " + tableArray + ". loadTableIndex = " + loadTableIndex + ". savedTablesArray: savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + "newTableFieldsArray = " + newTableFieldsArray);
	changeDBtable();//to keep field names from getting messed up Date: Feb13
}//end if loadTableFromOptions

*/		
//at this point tableArray = Tablevariables edited! dataVobj.tableArray now = Doug Dyer,2022-02-02,(250) 658-5645,addyer@telus.net  trainee45.dd@gmail.com ,Janet Dyer,2022-02-02,(250) 658-5645,jandyer@telus.net,Sandra Ramezani,2022-02-02, (604) 505-6650,slramezani@gmail.comdataVobj.newTableVariables = 4,Fantastic,Working well,Engine Hostlers,From ContactsBtn,From NameCreateNew Table,true,CONTACT NAME, DATE ,TELEPHONE,EMAIL,ADDRESS,

//NOTE newTableVariablesArray[4] = numberOfNewTableAddedFields; NUMBER OF NEWTABLEADDED FIELDS IS NOT LISTED
	resetFromContacts();
		
	//REMOVE ATRIMHEADROW???	
		//trimHeadRow();
	//tableArray will now be back in main db mode!!	
		
	//alertx("Preparing to save after edit: Need to know that tableArray has been set back to main db data before save! tableArray = " + tableArray + "SO DON'T EDIT A TD CELL BY DBLCLICK IF YOU HAVE JUST EDITED THE TABLE LAYOUT BECAUSE AT THIS POINT tableArray is in main db mode and if you are still in newTable mode you will mess things up");	
	
	console.log("Preparing to save after edit: Need to know that tableArray has been set back to main db data before save! tableArray = " + tableArray + "SO DON'T EDIT A TD CELL BY DBLCLICK IF YOU HAVE JUST EDITED THE TABLE LAYOUT BECAUSE AT THIS POINT tableArray is in main db mode and if you are still in newTable mode you will mess things up");	
	
	
	//removeDynamicFields();
	//removeFieldHeaders();
	
	//return false;
		saveVariables();
		
		//removeHeadRow();//VERY IMPORTANT LINE..MAKES IT WORK!!!Date: Feb12 2022..new function
		
/*		
	need to adjust savedTablesArray numberOfFields (numberOfFields = savedTablesArray[indexTable].length) 	
	don't saveVariables until all table edits are made so goto displayTable first then return here to saveVariables and return to mainDB table as you do when creating a contactsTable. In displatTable numberOfFields will have to be set to savedTablesArray[indexTable].length if in loadFromTableOptions mode. Then after display and returning to saveVariables will need to return to originakNumberOfFields and tableTitle.length etc.
	*/
homeScreenBtn.setAttribute('class','borderBlink');
homeScreenBtn2.setAttribute('class','borderBlink');
}//end if loadFromTableOptions
	
/*
if(!loadFromTableOptions) {
	saveVariables();
	displayTable();
	//createTableWindow.setAttribute('class', 'hidden');
	}//end if(!loadFromTableOptions)
	*/
}//end showBtn.onclick?displayTable?

changesBtn.onclick = function () {
	createTable.removeChild(showOrEdit);
	createTable.removeChild(buildRecordsP);
	saveTableP.textContent = 'You can edit the Table Column Labels here, but not the data. To edit data go to DISPLAY TABLE and double tap the desired cell.';
	addFieldsDirectionP.textContent = 'Make changes to the added field Labels: ';
	
	edit = 1;
	makeTable();
}//end changesBtn.onclick	
		
	}//end saveTableP.onclick
}//end function saveTable

}//end function makeTable starts at line 232
//makeTable function basically just creates the fieldNames Array

//buildRecordRows function taken out of makeTable function so it can be found by refreshTable()

function buildRecordRows () {
	redefineTableArray();
	console.log('In buildRecordRows(). edit variable = ' + edit);
	//TAKE OUT CODE BETWEEN HERE !!!!!!!!!?,
	//set up tableArray to prevent undefined error
	//changed recordCounter to tableTitle.length
	// for (let i = 0; i < tableTitle.length; i++) {
		
	// 	for (let j = 0; j< numberOfFields; j++) {
	// 		//TypeError: undefined is not an object (evaluating 'tableArray[i][j] = " "')
	// 		tableArray[i][j] = " ";
	// 	}//end for j <= numberOfFields..
	// }//end for i = 0; i <= recordRows..
	//AND HERE !!!!!!!!!!!!!!
	
	if(testing) {
		console.log('In buildRecordRows from refreshTable!');
	testing = 0;//Dec 6	
	}//end if testing = 1
	//tableTitle.length can also be counter
	for(let i = 0; i< tableTitle.length; i++) {
	// 	if (i >counter) {
	// 		//ReferenceError: Can't find variable: e
	//   e.preventDefault();
  // }//end if counter e.prevent default
		//alert('at for i loop: i = ' +i + ' c = ');
	//if(edit === 0) {recordItem not found error if if statement is used
		const recordItem = document.createElement('tr');
		rows.appendChild(recordItem);//maybe not [i]
	//}//end if !edit
		//add field data for each td in the row
			for(let c=0;c<numberOfFields;c++){
				//alert('at for c loop: i = ' +i + ' c = '+c);
	
		const recordTd=document.createElement('td');//add td cell to row..left off here date:Aug 16 2020
		//!!!line below will be a problem if editing a prexisting table in IndexedDBNotes!
		if(edit === 0) {
		recordItem.appendChild(recordTd);
	}//end if !edit
		if (c === 0) {
			//recordTd.textContent = tableTitle[i].slice(indexOf('>'));//USE IF YOU DON'T WANT cursor.value.id from displayData to show
			//so tableArray that has now been converted to contacts data if loadFromTableOptions=true, is not contaminated by tableTitle (which was not converted to newTable data), we set recordTd.textContent = tableArray[i][0]
			if(loadFromTableOptions) {
				recordTd.textContent = tableArray[i][0];
			} else {
				recordTd.textContent = tableTitle[i];
			}//end if(loadFromTableOptions) else  {
			//tableTitle (global) array has to be constructed in displayData of indexedDBNotes
			// alert('tableArray 0,0 = '+ tableArray[[0],[0]] + 'tableTitle 0 (CN6035) =' +tableTitle[0] + 'tableTitle[' +i+'] ='+ tableTitle[i]);
		//this is where tableArray 0,0 gets over ridden..after i changes from 0 to 1 ..looks like array is overwritten!	
		//TypeError: undefined is not an object (evaluating 'tableArray[i][c] = tableTitle[i]')
		//TypeError: undefined is not an object (evaluating 'tableArray[i][c]')..so put console.log statement AFTER assignment
		//TypeError: undefined is not an object (evaluating 'tableArray[3][0]')..because I doesn't get to 3 yet if only 3 records (3rd record is i=2)
		// console.log('The 4th record title tableArray[3][0] = ' + tableArray[3][0]);
		console.log('originalNumberRecords = ' + originalNumberRecords + '. i = ' + i);
		console.log('tableTitle[3] = ' + tableTitle[3]);
		//remember i starts at 0 and numberOfRecords starts at 1
		if(i >= originalNumberRecords ) {
			console.log('i is > originalNumberRecords...tableTitle[' +i + '] = '+ tableTitle[i] + ' tableArray[' +i + ']['+ c + '] = ' + tableArray[i][c]);
			//to avoid error: TypeError: undefined is not an object (evaluating 'tableArray[i][c] = tableTitle[i]')
			//tableArray[i][c] = " ";
		}//end if i > originalNumberRecords 
		//TypeError: undefined is not an object (evaluating 'tableArray[i][c] = tableTitle[i]')
		//if(loadFromTableOptions) {
			if(!loadFromTableOptions) {
			tableArray[i][c] = tableTitle[i];
		}//end if(!loadFromTableOptions) {
			//is tableArray[3][0] undefined because tableArray not declared to use more than 3 rows?suggest declaring tableArray to have 100 rows right at the start!
			//LEFT OFF HERE Oct30
			
			console.log('In buildRecordRows..tableTitle[i] = ' + tableTitle[i]+ '  tableArray[i][c] = ' + tableArray[i][c]);
			
//In buildRecordRows..tableTitle[i] = 4> Additional Note  tableArray[i][c] = 4> Additional Note

		//TypeError: undefined is not an object (evaluating 'tableArray[i][c] = tableTitle[i]')	
			// if (tableArray[[0],[0]]!='CN6035') {alert('stop screw up here!');}
			// alert('tableArray[' +i + '],[' +c +'] ' + tableArray[[i],[c]] + 'and tableArray0,0 also = ' + tableArray[[0],[0]]);
		} else if (c === 1) {//recordTd.textContent = dateP;
			if(!loadFromTableOptions) {
			recordTd.textContent = dateTable[i];
			tableArray[i][c] = dateTable[i];
			} else if (loadFromTableOptions) {//recordTd.textContent = todayString;
			recordTd.textContent = tableArray[i][1];
			//tableArray[i][c] = todayString;
			
			tableArray[tableTitle.length-1][c] = todayString;
			}//end else if loadFromTableOptions
			// alert('tableArray[' +i + '],[' +c +'] ' + tableArray[[i],[c]]);

//Offending code causes all dates to be current in an edited new table!!! Date:Oct30 2022


		}//end if c=1 first td (title) dateP has to come from a date array variable in notes
		
		else if (c === 2)
		{
			if(loadFromTableOptions) {
				recordTd.textContent = tableArray[i][c];
			} else {
				recordTd.textContent = paraBody[i];
				tableArray[i][c] = paraBody[i];
			}//end if(loadFromTableOptions) 
				
	
			// tableArray[[i],[c]] = paraBody[i];
			// alert('tableArray[' +i + '],[' +c +'] ' + tableArray[[i],[c]]);
		} else if (c === 3) 
		{
			if(loadFromTableOptions) {
				recordTd.textContent = tableArray[i][c];
			} else {
				recordTd.textContent = displayXtraFieldData[i];
				tableArray[i][c] = displayXtraFieldData[i];
			}//end if(loadFromTableOptions) 
			
			
			// tableArray[[i],[c]] = displayXtraFieldData[i];
			// alert('tableArray[' +i + '],[' +c +'] ' + tableArray[[i],[c]]);}
		//for all the additional fields
		} else 
		{//alert('at else in for loop: i = ' +i + ' c = '+c);
		//for case where I is >= originalNumberRecords avoid adding inputs
		//add this if condition
//	if(!i >= originalNumberRecords)	{
			const tdInput = document.createElement('input');
		const submitTdInputBtn = document .createElement('button');
		recordTd.appendChild(tdInput);
		recordTd.appendChild(submitTdInputBtn);
//	}//end if !i>=originalNumberRecords 
		//let j = c-4;
		if(edit === 1) {
		tdInput.value = tableArray[i][c];
	}//end if edit
	
	// BEGINNING OF code to try and assign values to tableArray if added record
	if (i >= originalNumberRecords) {
		
		tdInput.value = " ";
		tableArray[i][c] = " ";
	}//end of if i > originalRecordNumber
	
	// END OF code to try and assign values to tableArray if added record
	
	
		submitTdInputBtn.onclick = function () {
			
			recordTd.textContent = tdInput.value;
			tableArray[i][c] = recordTd.textContent;//was tdInput.value
				//	alert(' At submitTdInput: tableArray[' +i + '][' + c  +'] = ' + tableArray[i][c]);
			}//end submitTdInputBtn.onclick
			//entered = 1;
			
		
		
		
		
		} //end of else construct
	// alert('At end of build record rows function : tableArray[' +i + '][' + c  +'] = ' + tableArray[i][c]);	
		
	}//end for c=numberof fields
	
/*	if (entered) {
		//create edit option
		recordTd.addEventListener('click', function () {
			recordTd.textContent = ' ';
			recordTd.appendChild(tdInput);
		recordTd.appendChild(submitTdInputBtn);
		
		submitTdInputBtn.onclick = function () {recordTd.textContent = tdInput.value;}
		entered = 0;
	});//end recordTd.addEventListener
}//end if entered
*///above code to make an edit option did not work		
	}//end for i counter all record rows
	tableConstructed = 1;
console.log('At end of buildRecordRows()...tableConstructed set to 1 in buildRecordRows. (tableExists variable is set to 1 way back in newBtn.onclick when first creating the table.');

//!!!!?!!!?,L!!ONLY SAVE TO SAVEDTABLESARRAY IF YOU ARE EDITING A NEWTABLE IN LOADFROMTABLEOPTIONS!!!?,!?,?
//changed tableIndex to loadTableIndex Feb6
if(loadFromTableOptions) {
		savedTablesArray[loadTableIndex] = tableArray.slice();//tableArray in newTable configuration
	}//end loadFromTableOptions
	
		//newTableFieldsArray is saved in newTableSpecificVariables[loadTableIndex][1] = newTableFieldsArray; newTableSpecificVariables[loadTableIndex][2] = numberOfNewTableAddedFields; newTableNamesArray see saveTableBtn.onclick
		
//alertx("At end of build record rows from a table edit. tableArray = " +tableArray + ".  savedTablesArray = " + savedTablesArray);
console.log("At end of build record rows from a table edit. tableArray = " +tableArray + ".  savedTablesArray = " + savedTablesArray);



}//end buildRecordRows.function
//buildRecordRows creates and assigns values to the tableArray..for added fields only after the submit Button (submitTDinput Btn.onclick) is tapped. This means for added records after the first table creation, the tableArray for the added 'i' will not be defined unless manually assigned or you go through the buildRecordRows process again?

//above code is buildRecordRows function
//show the table previously created using the tableArray variable
function displayTable () {
today = new Date();
todayS = today.toString();
 currentDate = todayS.slice(3, 8);
// alert("currentDate = " + currentDate + "today.getMonth() = " + today.getMonth())
 currentDate = currentDate + today.getDate();

//alert("currentDate " + currentDate);

//alert("currentDate = " + currentDate);
//end function displayTable ..!!!! showTable IS AT LINE 10853
//flag to only allow transit through mainDBedit code once	
//if(budgetSheet) {
//	changeMonthBtn.style.display = "unset";
if(budgetSheet && loadSampleBudget) {
	changeMonthBtn1.style.display = "unset";
	changeMonthBtn2.style.display = "unset";
} else {
	changeMonthBtn1.style.display = "none";
	changeMonthBtn2.style.display = "none";
}//end if else(budgetSheet) 

if (tableArray[0][2].includes("Cost to date = $") || tableArray[0][2].includes("Total to date = ")) {
 	sumAcrossInfoP.style.display = "unset";
}//end id c === 2

if(makeContactsTable) {
		flipMenu.textContent = " ✅ New Table Name: " + newTableNames[tableIndex] + ". " + newTableName;
	}//end if makeContactsTable

	//alert("Start function displayTable (I removed parameter..…savedTablesArray = " + savedTablesArray);
	//REMOVING PARAMETER KEEPS savedTablesArray INTACT!
	
	//code to allow for table window to fit in Landscape mode
	
	let tableWindowHeight = showTable.clientHeight;
	console.log('tableWindowHeight = ' + tableWindowHeight);
	
	if(tableWindowHeight == 720) {
		tableLandscapeP.textContent = "SCROLL UP ⬆️ TO SEE BOTTOM OF TABLE WINDOW ";
	} else {
		tableLandscapeP.textContent = "";
		
	}//end if tableWindowHeight ==620
	
	//REMOVE below IF MESSES UP
	
	//dark mode selected Dec18
// //checkScreenMode();
// alert("usingDarkMode = " + usingDarkMode);
// if(usingDarkMode) {
// 	showTable.style.backgroundColor = "black";
// 	showTable.style.color = "white";
// 	$("#flip").css({"background-color": "lightgrey", "color":"black", "border-color": "red"});//these don't work
	
// 	//bodyImage.setAttribute('class','showDark');
// 	//bodyImage.style.color = "white";
	
// } else {
// 	showTable.style.backgroundColor = "#eee";
// 	showTable.style.color = "black";
// 	$("#flip").css({"background-color": "lightgrey", "color":"black", "border-color": "black"});//these don't work
	
	
	//bodyImage.setAttribute('class','showLite');
	//bodyImage.style.backgroundColor = "white";
	//bodyImage.style.color = "black";
//}//end if usingDarkMode THIS WAS THE CULPRIT IN LAST ERROR FORGOT TO REMOVE THE LAST CURLY BRACKET ,!!!?,Dec19
	
	// let TableBackgroundColor ;
		const tableBackgroundBtn = document.querySelector('#tableBackground');
	
	 	tableBackgroundBtn.onclick = function () {
			
			//return menu bar in table back to original if post search
			flipMenu.textContent = "Click - Tap to show / hide TABLE MENU";
			
		console.log('tableBackgroundBtn clicked');
		
		if(darkMode) {
			tableBackgroundBtn.textContent = "DARK Mode - DBLtap/click=DEFAULT";
			darkMode = false;
		} else {
			tableBackgroundBtn.textContent = "LIGHT Mode - DBLtap/click=DEFAULT";
			darkMode = true;
			
			}//end if else darkMode;
			
			//resetTable
			refreshed = 1;//so added field name headings are not generated twice when displayTable runs again from lineb 7952
			editCurrentTable = 0; //Nov 22 so added field name headings are not generated twice
			while (STrows.firstChild) {
    STrows.removeChild(STrows.firstChild);
}//end while
//to maintain header after refresh
STtableHeader.textContent = dbTableName.value;
STtableHeader.setAttribute('class','attentionBtn');
STrows.appendChild(STtableHeader);
STrows.appendChild(STheadRow);
		displayTable();
		refreshed = 0;//reset variable to where it started
	}//end tableBackgroundBtnBtn.onclick
	
	//doubleClick
	tableBackgroundBtn.ondblclick = function () {
		
		//return menu bar in table back to original if post search
		flipMenu.textContent = "Click - Tap to show / hide TABLE MENU";
		
		console.log('tableBackgroundBtn dblclicked');
		darkMode = null;
			//resetTable
			refreshed = 1;//so added field name headings are not generated twice
			editCurrentTable = 0; //Nov 22 so added field name headings are not generated twice
			while (STrows.firstChild) {
    STrows.removeChild(STrows.firstChild);
}//end while
//to maintain header after refresh
STtableHeader.textContent = dbTableName.value;
STtableHeader.setAttribute('class','attentionBtn');
STrows.appendChild(STtableHeader);
STrows.appendChild(STheadRow);
		displayTable();
		refreshed = 0;
		
	}//end tableBackgroundBtn.ondblclick = function () {
		
	//doubleClick
	
	// 		// console.log('TableBackgroundColor = ' + TableBackgroundColor);
	// 	STforRows.setAttribute('style','backgroundColor: black');
	// 		STforRows.style.backgroundColor = 'black';
	// 			TableBackgroundColor = 1;
	// 			//displayTable();
		//}//end if darkMode;
	// 	if(TableBackgroundColor === 1) {
	// 		console.log('TableBackgroundColor = ' + TableBackgroundColor);	STforRows.setAttribute('style','background-color: yellow; color:black');
	// 			TableBackgroundColor = 0;
	// 			//displayTable();
	// 		}//end if tableBackgroundCoror=1	
			
	//}//end tableBackgroundBtnBtn.onclick
	//REMOVE ABOVE IF MESSES UP
	
	
//added May6 to clean up tables head row if viewing table right afterva restore db
if(fromRestore) {
	console.log('At display table from restore. Need to create code here to not allow field headers to get scrambled!')
// clearTableRows();
// trimHeadRow();
// removeFieldHeaders();
	fromRestore = false;
 }//end if fromRestore
	console.log('At function displayTable');
		//hide create table windowg
		//SHOULD THIS LINE BE REMOVED AND ADDED AT 
		//error here in that I had written tableConstructed === 1 instead of = 1!!!!!!!!!!!!!
		tableConstructed = 1//so table is viewed after a displayTableBtn.onclick repeat button tap?
		createTableWindow.setAttribute('class', 'hidden');
	showTable.setAttribute('class', 'showing');
	showTableName.textContent =  "Table for Database named : " + dbTableName.value;
	//STtableHeader.textContent = dbTableName;
	//showTable.appendChild(STtableHeader);
	//!fromDeleteField to stop this section running if from deleteField Jan 30 !!!! 
	console.log('Just entered displayTable! tableExists = ' + tableExists + ' fromMakeTable = ' + fromMakeTable + ' tappedOnce = ' + tappedOnce + ' fromDeleteField = ' + fromDeleteField);
	//should add !tableExists to conditions below Jan30 2021
	if (!tableExists & fromMakeTable & !tappedOnce & !fromDeleteField) {
	const backToCreateTableP = document.createElement('h4');
	backToCreateTableP.textContent = 'You must create a table first. Tap here to create a table. Tap twice to CANCEL!';
	showTable.appendChild(backToCreateTableP);
	backToCreateTableP.onclick = function (){alert('go to createTable function!');
		makeTable();
		}//end backToCreateTableP.onclick
	backToCreateTableP.ondblclick = function (){alert('Return to database home screen!');
		//makeTable(); appropriate function here
	}//end backToCreateTableP.ondblclick
	fromMakeTable = 0;	
	}//end if fromMakeTable & !tappedOnce
	
	console.log('In start displayTable function. edit = ' + edit);//demonstrate that fieldNamesArray is intacty
	for(let j=0;j<numberOfFields;j++) {
				console.log('fieldNamesArray[' +j+ '] = ' + fieldNamesArray[j]);
	//for dynamicTELEPHONE && j<5..so I don't have to rewrite code for STsecondDataNameTdListener
	//ADDEVENTLISTENER IF FIELDNAME = "EMAIL"
	if (fieldNamesArray[j].includes("EMAIL") && j<5) {
	STsecondDataNameTdListener = true//flag set here so variable is correct if tapping homeBtn in table without having used dbltap on the EMAIL field. Not sure I understand why!!!see telephone..needed to add this code for telephone..it allows a removal of listener at displayBtn etc !!!important line !!!
	console.log("fieldNamesArray[j] = EMAIL");
	//alertx("STsecondDataNameTdListener = " + STsecondDataNameTdListener + ". fieldNamesArray[3] = " + fieldNamesArray[3]);
	eMailFieldNameIndex = j;
	console.log("eMailFieldNameIndex = " + j);
		//fieldNamesArray[j].addEventListener(dblclick, function() {eMailActive =true; alert("eMail address now active! Double click on email address to SEND EMAIL!")});//end addEventListener
	}//end if (fieldNamesArray.textContent === 'EMAIL')
	//ADDEVENTLISTENER IF FIELDNAME = "EMAIL"
	
	
//ADDEVENTLISTENER IF FIELDNAME = "TELEPHONE"
	//if (fieldNamesArray[j] === "TELEPHONE" && j<5) {
	
	if (fieldNamesArray[j].includes("TELEPHONE") && j<5) {
	STfirstDataNameTdListener = true//flag set here so variable is correct if tapping homeBtn in table without having used dbltap on the EMAIL field. Not sure I understand why!!!? Because because TdListener = true allows removal of listener code at displayBtn etc. yes!?
	console.log("fieldNamesArray[j] = TELEPHONE");
	//alertx("STsecondDataNameTdListener = " + STsecondDataNameTdListener + ". fieldNamesArray[3] = " + fieldNamesArray[3]);
	telephoneFieldNameIndex = j;
	console.log("telephoneFieldNameIndex = " + j);
		//fieldNamesArray[j].addEventListener(dblclick, function() {eMailActive =true; alert("eMail address now active! Double click on email address to SEND EMAIL!")});//end addEventListener
	}//end if (fieldNamesArray.textContent === 'TELEPHONE')
	//ADDEVENTLISTENER IF FIELDNAME = "TELEPHONE"
	
//ADDEVENTLISTENER IF FIELDNAME = "TOTAL"
	//if (fieldNamesArray[j] === "TOTAL" && !totalActive) {
	if (fieldNamesArray[j].includes("TOTAL") || fieldNamesArray[j].includes("AVERAGE") || fieldNamesArray[j].includes("EMAIL") || fieldNamesArray[j].includes("TELEPHONE")) {
	//DOES ABOVE NEED fieldNamesArray[j].includes("EMAIL") INCLUDED?
	//alertx("ok at TOTAL||AVERAGE||EMAIL " + fieldNamesArray[j]);
	
	totalFieldNameListener = true;//flag set here so variable is correct if tapping homeBtn in table without having used dbltap on the EMAIL field. Not sure I understand why!!!
	console.log("fieldNamesArray[j] INCLUDES TOTAL");
	
	//totalFieldNameIndex = j;
	console.log("totalFieldNameIndex = " + j);
	totalInfoP.style.display = "unset";
 //sumField = document.querySelector("fieldNamesArray[totalFieldNameIndex]");
 //TypeError: null is not an object (evaluating 'sumField.addEventListener')
 // sumField.addEventListener('dblclick', sumField.fn = function fn() {
	// 	totalActive =true; 
	// 	alert("Summing contents of TOTAL column!");
	// 	});//end addEventListener	
//STsecondDataNameTd.addEventListener('dblclick', STsecondDataNameTd.fn=function fn() {
//TypeError: undefined is not a function (near '...fieldNamesArray[totalFieldNameIndex].addEventListener...')

// fieldNamesArray[totalFieldNameIndex].addEventListener('dblclick', fieldNamesArray[totalFieldNameIndex].fn=function fn() {
// 		totalActive =true; 
// // 		alert("Summing contents of TOTAL column!");
// 	});//end addEventListener
		
		
	}//end if (fieldNamesArray.textContent === 'TOTAL')
	//ADDEVENTLISTENER IF FIELDNAME = "TOTAL"			

				
			}//end for j =
	//alert("eMailFieldNameIndex = " + eMailFieldNameIndex + " eMailActive = " + eMailActive);	
		
	console.log('In start displayTable function, and tableConstructed has just been set to 1 at line 4486, immediately after entering displayTable(). This line might get removed?!'); 
console.log('At displayTable: refreshed variable is set to 0 in showBtn.onclick (Display Table Btn) and set to 1 at end of displayTable if there is a cell edit. ..refreshed (edit data cell) = ' + refreshed + ' renewed (added record) = ' + renewed +'. displayedTable variable = ' + displayedTable + '. tableConstructed = ' + tableConstructed + '. edit = ' + edit + '. editCurrentTable = ' + editCurrentTable + '.');	
if(renewed ===1) {
	console.log('renewed = 1 which means I am in displayTable from refreshTable. tableArray = ' + tableArray);
}//end if renewed = 1
	
	// if(changeDB) {
	// 	editCurrentTable =1;
	// 	changeDB = false;
		
	// }

//if (editCurrentTable === 1) {
		//clearTableRows();
		//trimHeadRow();
		
		 //IndexSizeError: The index is not in the allowed range.
		//TypeError: null is not an object (evaluating 'document.getElementById("STHeadRow").deleteRow')
		//let deleteRow = document.getElementById("STforRows").firstElementChild.remove(); 
		  //document.getElementById('#STforRows').detach(); 
		//STrows.removeChild(STtableHeader);
	// 	let showTableRows = document.getElementById('STforRows');
	// let dataCell = document.getElementsByTagName('td');
	// let showTableHeadRow = document.getElementById("STHeadRow");
	// 	showTableRows.removeChild(showTableRows.showTableHeadRow);
	//rankingsBody.firstElementChild.remove();
// 	removeHeadRow();	
// 	function removeHeadRow (){ document.getElementById('STheadRow').remove();
// }//end function remove STHeadRow


// 	while (showTableHeadRow.thirdChild) {
//     showTableHeadRow.removeChild(dataCell);
// }//end while
		//showTableRows.removeChild(showTableHeadRow);
	//NotFoundError: The object can not be found here.
	//added Feb16 2022
	trimHeadRow ();//to keep headvrow from being messed up
	// }//end if editCurrentTable = 1
//reproduce the table using the+ fieldNamesArray and tableArray
	//ST = showTable need to make this different than createTable window HTML
	//first 4 ST fields all HTML
	STtableHeader.textContent = dbTableName.value;
	STtableHeader.setAttribute('class','attentionBtn');
	//STrows.appendChild(STtableHeader);
	STheadName.textContent = fieldNamesArray[0];//listName header first column
	STfirstDataNameTd.textContent = fieldNamesArray[2];
	STsecondDataNameTd.textContent = fieldNamesArray[3];
	
	//alertx("at start displayTable .. STsecondDataNameTd.textContent = " + STsecondDataNameTd.textContent);
	
	// 	//ADDEVENTLISTENER IF FIELDNAME = "EMAIL"
	
	
	//if(STsecondDataNameTd.textContent.includes("EMAIL") {
	
	//if (STsecondDataNameTd.textContent.trim() === "EMAIL") {
	if (STsecondDataNameTd.textContent.includes("EMAIL")) {
	// emailAlertFlag = true;
	// console.log("fieldNamesArray[j] = EMAIL");
	
	// eMailFieldNameIndex = 3;
	// console.log("eMailFieldNameIndex = " + 3);
	
	
// STsecondDataNameTd.addEventListener('dblclick', function() {
// STsecondDataNameTdListener = true;
// 	eMailActive =true; 
// if(!eMailAlertFlag) {
// 	alert("eMail address now active! Double click on email address to SEND EMAIL!");
// eMailAlertFlag = true;
// 	}//end if(!eMailAlertFlag) 
// STsecondDataNameTd.removeEventListener;
// 	});//end addEventListener
	
STsecondDataNameTd.addEventListener('dblclick', STsecondDataNameTd.fn=function fn() {
STsecondDataNameTdListener = true;
	eMailActive =true; 
//NOV7
telephoneActive = false;
STfirstDataNameTd.setAttribute('class','stHeadRow');
	STsecondDataNameTd.setAttribute('class','borderBlink');
	
if(trigger === 'copy') {
	alert("The trigger to edit a data cell MUST BE IN DBL-CLICK mode in order to use the active email function. Return to Preferences and reset the edit mode to DBL-CLICK");
	
	showTable.setAttribute('class','hidden');
	prefWindow.setAttribute('class','showing');
	editTDTriggerBtn.setAttribute('class','borderBlink');
	return;
}//end if(trigger === 'copy')	
	//j<4 so this applies only to fixed fields
	//j<4 so this applies only to fixed fields BUT J NOT FOUND ERROR SO REMOVED! Date:Nov6
//if(!eMailAlertFlag && j<4) {

if(!eMailAlertFlag) {
	alert("eMail address now active! Double click on email address to SEND EMAIL!");
eMailAlertFlag = true;
	}//end if(!eMailAlertFlag) 
	
//STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);

	}, false);//end addEventListener
	
	
	
	
	}//end if (STsecondDataNameTd.textContent === 'EMAIL')
	// //ADDEVENTLISTENER IF FIELDNAME = "EMAIL"
	


if (STfirstDataNameTd.textContent.includes("TELEPHONE")) {
//if (STfirstDataNameTd.textContent === "TELEPHONE") {

//if (STfirstDataNameTd.textContent === "TELEPHONE") {

//alertx("about to addEventListener: STfirstDataNameTd.textContent = " + STfirstDataNameTd.textContent);
	
STfirstDataNameTd.addEventListener('dblclick', STfirstDataNameTd.fn=function fn() {
STfirstDataNameTdListener = true;
	telephoneActive =true; 
//Nov7
eMailActive = false;
STsecondDataNameTd.setAttribute('class','stHeadRow');
	STfirstDataNameTd.setAttribute('class','borderBlink');
	
if(trigger === 'copy') {
	alert("The trigger to edit a data cell MUST BE IN DBL-CLICK mode in order to use the active telephone number function. Return to Preferences and reset the edit mode to DBL-CLICK");
	
	showTable.setAttribute('class','hidden');
	prefWindow.setAttribute('class','showing');
	editTDTriggerBtn.setAttribute('class','borderBlink');
	return;
}//end if(trigger === 'copy')	
//j<4 so this applies only to fixed fields BUT J NOT FOUND ERROR SO REMOVED! Date:Nov6
//if(!telephoneAlertFlag && j<4) {

if(!telephoneAlertFlag) {
	alert("Telephone number now active! Double click on telephone number to CALL!");
telephoneAlertFlag = true;
	}//end if(telephoneAlertFlag) 
	

	}, false);//end addEventListener
	
	
	
	
	}//end if (STfirstDataNameTd.textContent === 'TELEPHONE')
	// //ADDEVENTLISTENER IF FIELDNAME = "TELEPHONE"	
	
	
	//create the added fields required
	//AND displayedTable = 0 because otherwise buildRecordRows has reconstructed the header row
	
	//!editCurrentTable keeps edit code from entering this section so all the added field headers are not tagged on to STHeadRow
	console.log('At displayTable—editCurrentTable = ' + editCurrentTable);
	if (editCurrentTable === 1) {
		
		// while (STrows.firstChild) {
		// STrows.removeChild(STrows.firstChild);
		// }
		//clearHeadRow();
			//STrows.appendChild(STtableHeader);
			//STrows.appendChild(STheadRow);
		//alert("At displayTable - editCurrentTable is set to 1 in setUpNewTable when loading a new table .. AND also set to 1 in editBtn.onclick ..  editCurrentTable = 1 so clearing rows adding fields and removing dynamic fields..STHeadRow has its text content set but is not yet containing dynamic fields or has it been added to STRows");	
		
			clearTableRows();
			addFieldHeaders();
			removeDynamicFields();
			// trimHeadRow();
			//removeDynamicFields();
			
			displayedTable = 0;
			refreshed = 0;
			
			
			//removeFieldHeaders();//error object can not be found here..at function
			//removeFieldHeaders();
			// alert('removeFieldHeaders');
			
			// clearTableRows();
			// alert('cleared table rows');
			// //trimHeadRow();
			// removeDynamicFields();
			// alert('trimHeadRow');
			showTable.setAttribute('class', 'showing');
			
		}//end if editCurrentTable =1
		
	// if (fieldDeleted) {
	// 	while (STrows.firstChild) {
    // STrows.removeChild(STrows.firstChild);
	// }//end while	
	//addFieldHeaders();
	//removeFieldHeaders();
	//removeDynamicFields();
	//}//end if fieldDeleted
		console.log('At displayTable..about to recreate field headers if editCurrentTable = 1 or !refreshed and !displayedTable: REFRESHED =  ' + refreshed + ' DISPLAYEDTABLE = ' + displayedTable);
		//remove !fromDeleteField if messes up Jan30
	//	Left off here Jan30
	//editCurrentTable is set to 1 in setUpNewTable but is set to 0 in tableScreenOptions..i.e. so the main db load does not recreate dynamic fields
	if (!refreshed & !displayedTable & !fromDeleteField || editCurrentTable === 1 || fieldDeleted) {
		console.log('In displayTable.. and RECREATING FIELD HEADERS! virgin run! OR editCurrentTable = 1: refreshed currently set to 0 and displayedTable is 0, so displaying table from scratch, rebuilding field headers, via a k loop, appending the extra fields to the pre-existing field header row! ');
		console.log('tableConstructed variable is set to 1 immediately on entering displayTable(). tableConstructed = ' + tableConstructed + ' displayedTable variable = ' + displayedTable + '. editCurrentTable = ' + editCurrentTable + ' reconstructing STHeadRow..I.e. adding the extra fields, but not yet adding the row to the table! .?? Is Table Header and Head Row already here from the HTML...If comming from displayTableBtn.onclick after a rerun, STRows was cleared by that code and STHeader again ADDED to STRows in the displayTableBtn.onclick code, so now only additional dynamic fields are being tagged on. If in displayTable from renewed, the header row has to be reconstructed because all was erased in refreshTable prior to comming here! This will happen if renewed (updated added records) . Otherwise displayTable is only going to rebuild the record rows to display, and tag on the extra fields to the header row if a virgin run...or a rerun, ..displayedTable = 0 and refreshed = 0. DisplayedTable will be set to 1 in the if!refreshed & !displayedTable function, indicating code has run through displayTable() starting from scratch. Note if comming from a rerun..i.e. a table exists and displayTableBtn.onclick display table button was pressed, tableConstructed variable will = 0, code advances to else part, so that the tap of the displayTableBtn.onclick button will clear the STShow table screen, cause a run of code through displayTable which now recreates the STHeader, which was previously ADDED to STRows by the aforementioned code.? If the screen is not cleared is not the STHeader there already from HTML? so it does not need the append STHeader? However if coming from displayTableBtn.onclick after a rerun the STHeader has already been added to STRows or if refreshed is set to 1, the code does ADD the STHeader to STRows in the refreshedBtn.onclick section, because STRows was all cleared prior to comming to displayTable() from refreshTable(). A rerun so far works well after first tap of displayTableBtn.onclick.');
		
		//adding the extra dynamic  field names to the header row
		//if editing current table clear the old dynamic rowns so they can be replaced with the new ones
		if(fieldDeleted) {
			console.log('Am I here! At trying to trim fieldHeaders?')
			//removeFieldHeaders();
			//fromDeleteField = false;
			// fieldDeleted = false;//reset flag
			//removeDynamicFields();
		// 	while (STrows.firstChild) {
   	 // STrows.removeChild(STrows.firstChild);
		// }//end while	
	//STrows.removeChild(STheadRow);	
	//	STHeadRow.removeChild(STHeader);
			//trimHeadRow();
	//removeFieldHeaders

//remove dynamic fields from previous STheadRow 
console.log('Removing all fields ' + STheadRow);
// while (STheadRow.fithChild) {
//    STheadRow.removeChild(STheadRow.fithChild);
// }//end while
//clearHeadRow();//did not do anything ? Date:Feb12 2022
console.log('Removed dynamic fields! ' + STheadRow);
STheadRow.appendChild(STheadName);
STheadRow.appendChild(secondFieldName);
STheadRow.appendChild(STfirstDataNameTd);
STheadRow.appendChild(STsecondDataNameTd);
//field labels of static fields now restored!

fromDeleteField = false;// turn off this flag so that addFields is not called again beloww
		// for (let k = 4; k < originalNumberOfFields; k++) {
		// 	STheadRow.removeChild(STnextFieldHeading);
//trimHeadRow();
		// }//end for loop
		}//end if fieldDeleted
	if(!fieldDeleted) {
		trimHeadRow();
	}//end if !fieldDeleted
		//removeFieldHeaders();

//NEED TO MAKE THIS CODE RUN IF NEWTABLE WAS EDITED so in editBtn.onclick if loadFromTableOptions then make newTableEdit true!	 
//trimHeadRow();
//newTableEdit = true;//SHOULD I PUT THIS VARIABLE IN STORAGE??

//alert("About to create field headers!If newTableEdit is true, headers are messed up! Made false it works for a non-edited newTable. newTableEdit = " + newTableEdit);

//if(newTableEdit) {trimHeadRow()}//start from scratch
//if(!makeContactsTable && !loadFromTableOptions || newTableEdit) {	
	//removeFieldHeaders();
	//|| newTableEdit.   alert("in for k loop and should not be! If makeContactsTable = true .." + makeContactsTable + "  or if loadFromTableOptions = true …" + loadFromTableOptions);
	
	for (let k = 4; k < numberOfFields; k++) {
	const STnextFieldHeading = document.createElement('td');
	STnextFieldHeading.textContent = fieldNamesArray[k];	
	STheadRow.appendChild(STnextFieldHeading);
	//if field heading is TOTAL addzevent listener
	//alertx("fieldNamesArray[k] = " + fieldNamesArray[k] + "fieldNamesArray[k].includes(TOTAL)" + fieldNamesArray[k].includes("TOTAL"));
//code to set field heading light blue if = today's date
//alert("budgetSheet = "  +budgetSheet + ". fieldNamesArray[k] = " + fieldNamesArray[k] + ". currentDate = " + currentDate);
//NOTE THAT CURRENT DATE IS MONTH 01 02 etc whereas field label is 1,2,3,… 11 so at 10, 11 date lightblue will work but not for days under 10!!
if (budgetSheet && fieldNamesArray[k].trim() === currentDate.trim()) {
STnextFieldHeading.style.backgroundColor = "lightblue";
//STnextFieldHeading.textContent = "CURRENT DATE  " + currentDate.trim();
}//end if (budgetSheet && fieldNamesArray[k].includes())

//code to set field heading light blue if = today's date
	
//SHOULD I RESET BLINK OF ACTIVE field header here as well? It does get reset if resetFields has been made True when homeBtn moreNotesBtn tapped. 
//to reset field header if blinking
	// STnextFieldHeading.setAttribute('class','stHeadRow');//resets cancels blinking if previously applied by an addEventListener
	
	
	
	if(fieldNamesArray[k].includes("TOTAL") || fieldNamesArray[k].includes("AVERAGE")){
	//alertx("adding event listener");
	//totalFieldNameIndex = k;
	//if (STnextFieldHeading.textContent === "TOTAL") {
		STnextFieldHeading.addEventListener('dblclick', function (e) {
		e.target.style.color = "darkblue";
		e.target.style.backgroundColor = "lightblue";//added Nov27 2022
		
		//check table is initialized
		if(blockEdit) {
		alert("Before tapping this Field Title, Tap Return to Home Screen first to initialize the table layout you just edited or created!");
		homeScreenBtn.setAttribute('class','borderBlink');
	homeScreenBtn2.setAttribute('class','borderBlink');
		//blockEdit = false;
		resetFields = true;//one glitched after a totalling tap after an edit and fields were messed up. Will this fix it?Date:Dec11 2023
		return false;
	}
	
//IF EMAIL OR TELEPHONE ACTIVE SWITCH THESE OFF SO TAPPING IN TOTAL OR A ERAGING TD CELLS DOES NOT CAUSE PHONE OR EMAIL API TO START UP.vvvvvDATE NOV5 2022

//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED
if(telephoneActive || eMailActive) {
resetActiveFieldHeaders();
}//end if(telephoneActive || eMailActive) {

//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED

//IF EMAIL OR TELEPHONE ACTIVE SWITCH THESE OFF SO TAPPING IN TOTAL OR A ERAGING TD CELLS DOES NOT CAUSE PHONE OR EMAIL API TO START UP.^^^^^^^^^


			totalActive = true;
			totalFieldNameIndex = k;
			
if(fieldNamesArray[k].includes("TOTAL" || "AVERAGE") && calculationAlerts) {
	if (window.confirm("Do you want to turn off Calculation Alerts ? : \n" + "  CANCEL will Return to Table")) {
		calculationAlerts = false;
		alert("Calculation Alerts are turned OFF. Change in Preferences!");
	} else {
		alert("Calculation Alerts remain ON. This setting can be changed in Preferences. ")
	}//end if (window.confirm
	
}//end if(fieldNamesArray[k].includes("TOTAL" || AVERAGE && calculationAlerts)) {
			
	if(fieldNamesArray[k].includes("TOTAL")) {		summing(k);
		} else if (fieldNamesArray[k].includes("AVERAGE")) {
			averaging(k);
		}//end if else if if(fieldNamesArray[k].includes("TOTAL")) {
			//fieldNamesArray[totalFieldNameIndex].textContent = " TOTAL = " + $(fieldSUM);
			
			//STnextFieldHeading.textContent = " TOTAL = " + fieldSUM;
			
//DATE: NOV20 REMOVED rowSummed from $ conditionals so $ only appears if COST keyword ?or $ appears in the field title.
			
	//if (fieldNamesArray[k].includes("COST") || rowSummed) {
	
	if (fieldNamesArray[k].includes("COST") || fieldNamesArray[k].includes("$") ) {
		STnextFieldHeading.textContent = fieldNamesArray[k]+ " $" + fieldSUM;
		// } else if (fieldNamesArray[k].includes("AGE")) {
		// alert("fieldNamesArray[k] = " + fieldNamesArray[k] + " so why am I adding yrs? STnextFieldHeading.textContent = " + STnextFieldHeading.textContent );
		
		// 	STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " yrs";
		
		} else {	
			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + "   ";
			}//end if else (fieldNamesArray[j].includes("COST")) {
			
if (fieldNamesArray[k].includes("UNITS")) {
		//alertx("fieldNamesArray[k] = " + fieldNamesArray[k] + " so why am I adding yrs? STnextFieldHeading.textContent = " + STnextFieldHeading.textContent );
		
			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " units";
			}//end if (fieldNamesArray[k].includes("AGE")) {
			
if (fieldNamesArray[k] === "AGE" + " (TOTAL)" || fieldNamesArray[k] === "AGE" + " (AVERAGE)") {
		//alertx("fieldNamesArray[k] = " + fieldNamesArray[k] + " so why am I adding yrs? STnextFieldHeading.textContent = " + STnextFieldHeading.textContent );
		
			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " yrs";
			}//end if (fieldNamesArray[k].includes("AGE")) {
			
			
		//	totalFieldNameIndex = 0;//not sure this is used anymore? Date Nov13 2022
			fieldSUM = 0;
			STnextFieldHeading.removeEventListener;
			
			});//end addEventListener
		
		}//end if (STnextFieldHeading.textContent === "TOTAL || "AVERAGING) {
		
//ADDING CODE FOR TELEPHONE AND EMAIL IN DYNAMIC HEADERS	vvv
if(fieldNamesArray[k].includes("TELEPHONE") || fieldNamesArray[k].includes("EMAIL")){

//alertx("at fieldNamesArray contains TELEPHONE..adding eventListener");
//STfirstDataNameTd.addEventListener('dblclick', STfirstDataNameTd.fn=function fn() {
	STnextFieldHeading.addEventListener('dblclick', STnextFieldHeading.fn=function fn() {
		//check table is initialized
		if(blockEdit) {
		alert("Before tapping this Field Title, Tap Return to Home Screen first to initialize the table layout you just edited or created!");
		homeScreenBtn.setAttribute('class','borderBlink');
	homeScreenBtn2.setAttribute('class','borderBlink');
		//blockEdit = false;
		resetFields = true;
		return false;
	}
			
STnextFieldHeading.setAttribute('class','borderBlink');
//alertx("trigger = " + trigger + " prefVariablesArray[9] = " + prefVariablesArray[9]);
//check edit mode trigger
if(trigger === 'copy') {
	alert("The trigger to edit a data cell MUST BE IN DBL-CLICK mode in order to use the active telephone number function. Return to Preferences and reset the edit mode to DBL-CLICK");
	
	showTable.setAttribute('class','hidden');
	prefWindow.setAttribute('class','showing');
	editTDTriggerBtn.setAttribute('class','borderBlink');
	return;
}//end if(trigger === 'copy')	
	
	
	if(fieldNamesArray[k].includes("TELEPHONE")) {
			telephoneActive = true;
			telephoneAlertFlag2 = false;
			eMailAlertFlag2 = true;
		} else if (fieldNamesArray[k].includes("EMAIL")) {
			eMailActive = true;
			eMailAlertFlag2 = false;
			telephoneAlertFlag2 = true;
		}//end if else if	
		
//STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
//k is 4 or > so this applies only to dynamic fields
if(!eMailAlertFlag2) {
	alert("eMail address now active! Double click on email address to SEND EMAIL!");
eMailAlertFlag2 = true;
	}//end if(!eMailAlertFlag) 
	
if(!telephoneAlertFlag2) {
	alert("Telephone number is now active! Double click on telephone number to PHONE!");
telephoneAlertFlag2 = true;
	}//end if(!eMailAlertFlag) 

STnextFieldHeading.removeEventListener('dblclick', STnextFieldHeading.fn, false);

//STnextFieldHeading.setAttribute('class','stHeadRow');
//STnextFieldHeading.setAttribute('class','borderBlink')

});//end STnextFieldHeading.addEventListener

}//end if(fieldNamesArray[k].includes("TELEPHONE") ||


//ADDING CODE FOR TELEPHONE AND EMAIL IN DYNAMIC HEADERS	^^^
		
		

		}//end for loop
	//}//end if !makeContactsTable && !loadFromTableOptions) || newTableEdit	
		
		displayedTable = 1; ////MAY NEED IF DTBtnTappedOnce = 1 then displayedTable = 1??? at line 2493?
		
		//if (edit !== 1) {
		tableConstructed = 1;//so that subsequent tap of displayTableBtn.onclick (after the first tap immediately after a rerun) will allow going to the STTable screen without going through another virgin run. Remember from a displayTableBtn.onclick recap after a rerun, displayedTable will = 1 so that if another virgin rerun occurs the head row will not get reconstructed and will not get added to the STTable screen. Only the re-card rows get rebuilt so you won't see the Head Row
		//}//end if edit !== 1 to force a rebuild of STShow window after an edit and a reap of display table Btn
		//suspect line below does this add all the headers again?
		if(fieldDeleted) {
			STrows.appendChild(STtableHeader);
			STrows.appendChild(STheadRow);
		}//end ifFieldDeleted
		
		//for other cases other than deleted field
		//if comming from makeContactsTable we don't want extra fields added so put this condition into if !fieldDeleted Dec31 2021 did not wok
		//adding || loadFromTableOptions did add the field headers to the edited new table if new table was the first edit .. and ..after an edit from db main
	
		
		//alert("> AFTER DYNAMIC FIELDS CREATED! displayedTable will = 1 being set to 1 here. displayedTable = " +displayedTable + " refreshed = " + refreshed + " loadFromTableOptions = " + loadFromTableOptions + " makeContactsTable = " + makeContactsTable + " fieldDeleted = " + fieldDeleted + " edit = " + edit + " changeDB =  " + changeDB + " editCurrentTable = " + editCurrentTable);
		
		if(!fieldDeleted && !makeContactsTable || loadFromTableOptions) {
			
		//	alert("adding field headers!");
		addFieldHeaders();//this will add fields again if loadFromTableOptions because makeContactsTable will then be false..how about adding !newTableEdit
		}//end if !fieldDeleted
		//reset field deleted flag to restore code flow to a normal flow without having had a call to fielDelete
		fieldDeleted=false;
	}//end if(!refreshed) & !displayedTable
	
	//if comming from refreShTable
	//all the records had to be cleared in refreshTable because we are adding a new record, so all the old ones must be cleared, necessitating rebuilding the Header Row prior to reconstructing the records
	//removed || editCurrentTable. Nov 14
	
	//tag on added field if there is an edit request
	if (editCurrentTable === 1) {
		
		//REMOVE OR NOT DATE: FEB16 2022
		STrows.appendChild(STheadRow);
		
		//alert("adding field headers! Because editCurrentTable = 1 ");
		//tagOnAddedField from edit request
		// let tagOnAddedFields = fieldNamesArray.length - originalNumberOfFields;
		// for (let k=originalNumberOfFields;k< fieldNamesArray.length ; k++) {
		// 	STnextFieldHeading.textContent = fieldNamesArray[k];	
		// 	STheadRow.appendChild(STnextFieldHeading);
		// }//end for k=tagOnAddedFields
		//because STRows erased back at edit table(showBtn.onclick if editCurrentTable = 1)
		// removeDynamicFields();
		//addFieldHeaders();
	}//end if editCurrentTable = 1
	
	//in aid of restoring head row to newTable post load after an edit to main db..missing head row
	//NOPE DID NOT WORK!!
/*	if(loadFromTableOptions && mainDBedit && doThis) {
		doThis = false;
		alert("At mainDBedit!");
		clearTableRows();
		addFieldHeaders();
		trimHeadRow();
		//STrows.appendChild(STheadRow);
		changeDB = false;//so homeBtn click will not remove STHeadRow see homeBtn.onclick if changeDB removeHeadRow
		//mainDBedit = false;to still allow homeBtn to not erase headrow if mainDBedit
		displayTable();//THIS LINE REPEATED ALL THE RECORDS TWICE,!!
	}
	*/
	
	
	if (renewed){
		console.log('At displayTable (if renewed || editCurrentVariable = 1) The STHeader will be added because refresh() or showBtn.onclick via editBtn? cleared the STShow table before comming to displayTable(): refreshed = ' + refreshed + ' renewed = ' + renewed +'. displayedTable variable = ' + displayedTable + ' If renewed is 1 then refreshed will also be 1 because it is set to 1 in refreshTable() in aid of preventing a repeat tag on of extra field headings if there is a rerun.. renewed =1 so I came here from refreshTable, and going to rebuild table header and field rows..' );	
		addFieldHeaders();
// 	STtableHeader.textContent = dbTableName.value;
// STtableHeader.setAttribute('class','attentionBtn');
// STrows.appendChild(STtableHeader);
// STrows.appendChild(STheadRow);
}//end if updated NEEDS TO BE MOVED TO LINE3111..maybe NOT!
console.log('In displayTable! fromDeleteField = ' + fromDeleteField);
if (fromDeleteField) {
	//if coming from deleteField but deleteField was cancelled
	console.log('in displayTable fromDeleteField: fromeDeleteField = ' + fromDeleteField);
	
	
	fromDeleteField = false;
	addFieldHeaders();
}//end if fromDeleteField
//code below WORKS,! Dec31

//MAYBE SHOULD JUST REMOVE THIS PART?
//if include below load new table after a main db edit retains its field labels. Now examine trim headRow
//alert("resetFields = " + resetFields);
if(makeContactsTable || loadFromTableOptions || resetFields || deletingTableField) { 
//alert("at from newTable!");//&& !newTableEdit
//	alert("At end of displayTable in new table mode..adjusting field labels");HAD ONE INSTANCE OF NEEDING THIS CODE TO RUN AND IT DIDN'T BECAUSE resetFromContacts had made makeContactsTable and loadFromTableOptions both false..trying to replicate….

	resetFields = false;//flag used in displayTable to keep fields being messed up if edit notes after viewing a new table
	
	clearHeadRow();
console.log('Removed dynamic fields! ' + STheadRow);

//TRY THIS,! Date: Feb17 2022
//addFieldHeaders();
//TRY THIS,! Date: Feb17 2022


//
STheadRow.appendChild(STheadName);
STheadRow.appendChild(secondFieldName);
STheadRow.appendChild(STfirstDataNameTd);
STheadRow.appendChild(STsecondDataNameTd);
//field labels of static fields now restored!

for (let k = 4; k < numberOfFields; k++) {
	const STnextFieldHeading = document.createElement('td');
	STnextFieldHeading.textContent = fieldNamesArray[k];	
	//to reset field header if blinking
	


	STnextFieldHeading.setAttribute('class','stHeadRow');//resets cancels blinking if previously applied by an addEventListener
	
	STheadRow.appendChild(STnextFieldHeading);
	//if field heading is TOTAL addzevent listener
//code to set field heading light blue if = today's date
if (budgetSheet && fieldNamesArray[k].trim() === currentDate.trim()) {
STnextFieldHeading.style.backgroundColor = "lightblue";
}//end if (budgetSheet && fieldNamesArray[k].includes())

//code to set field heading light blue if = today's date
	
	
//	if (STnextFieldHeading.textContent === "TOTAL") {

//reapply eventListeners
if(fieldNamesArray[k].includes("TOTAL")|| fieldNamesArray[k].includes("AVERAGE")) {
	//alertx("adding event listener"); 
	
	// //CHECK IF ROWS SUMMED
	// if(tableArray[i][k].includes(sumRowTxt)	) {
	// 				rowSummed = true;
	// 			} else {
	// 				rowSummed = false;
	// 				}//end if else
	// //CHECK IF ROWS SUMMED
		STnextFieldHeading.addEventListener('dblclick', function (e) {
		e.target.style.color = "darkblue";
		e.target.style.backgroundColor = "lightblue";//added Nov27 2022
		
		//check if table initialized
		if(blockEdit) {
		alert("Before tapping this Field Title, Tap Return to Home Screen first to initialize the table layout you just edited or created!");
		homeScreenBtn.setAttribute('class','borderBlink');
	homeScreenBtn2.setAttribute('class','borderBlink');
		//blockEdit = false;
		return false;
	}
	
			totalActive = true;
			totalFieldNameIndex = k;
			
if(fieldNamesArray[k].includes("TOTAL" || "AVERAGE") && calculationAlerts) {
	if (window.confirm("Do you want to turn off Calculation Alerts ? : \n" + "  CANCEL will Return to Table")) {
		calculationAlerts = false;
		alert("Calculation Alerts are turned OFF. Change in Preferences!");
	} else {
		alert("Calculation Alerts remain ON. This setting can be changed in Preferences. ")
	}//end if (window.confirm
}//end if(fieldNamesArray[k].includes("TOTAL" || AVERAGE && calculationAlerts)) {

			//summing();
			if(fieldNamesArray[k].includes("TOTAL")) {
			summing();
		} else if (fieldNamesArray[k].includes("AVERAGE")) {
			averaging();
		}//end if else if if(fieldNamesArray[k].includes("TOTAL")) {
			//STnextFieldHeading.textContent = " TOTAL = " + fieldSUM;
			
	//if (fieldNamesArray[k].includes("COST") ) {
	//	STnextFieldHeading.textContent = fieldNamesArray[k]+ " $" + fieldSUM;
		
		
			
	if (fieldNamesArray[k].includes("COST") || fieldNamesArray[k].includes("$")) {
		STnextFieldHeading.textContent = fieldNamesArray[k]+ " $" + fieldSUM;
		// } else if (fieldNamesArray[k].includes("AGE")) {
		// 	STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " yrs";
		} else {	
			
			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM;
			}//end if (fieldNamesArray[k].includes("COST")) {
			
if (fieldNamesArray[k].includes("UNITS")) {
		//alertx("fieldNamesArray[k] = " + fieldNamesArray[k] + " so why am I adding yrs? STnextFieldHeading.textContent = " + STnextFieldHeading.textContent );
		
			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " units";
			}//end if (fieldNamesArray[k].includes("AGE")) {
			
if (fieldNamesArray[k] === "AGE" + " (TOTAL)" || fieldNamesArray[k] === "AGE" + " (AVERAGE)") {
		//alertx("fieldNamesArray[k] = " + fieldNamesArray[k] + " so why am I adding yrs? STnextFieldHeading.textContent = " + STnextFieldHeading.textContent );
		
			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " yrs";
			}//end if (fieldNamesArray[k].includes("AGE")) {
				
			fieldSUM = 0;
			totalFieldNameIndex = 0;	STnextFieldHeading.removeEventListener;
			
			//fieldNamesArray[totalFieldNameIndex].textContent = " TOTAL = " + fieldSUM;
			});//end addEventListener
		
		}//end if (STnextFieldHeading.textContent === "TOTAL")
		
//ADDING CODE FOR TELEPHONE AND EMAIL IN //ADDING CODE FOR TELEPHONE AND EMAIL IN DYNAMIC HEADERS	vvv must includ in resetFields section!
if(fieldNamesArray[k].includes("TELEPHONE") || fieldNamesArray[k].includes("EMAIL")){

//alertx("at fieldNamesArray contains TELEPHONE..adding eventListener");
//STfirstDataNameTd.addEventListener('dblclick', STfirstDataNameTd.fn=function fn() {
	STnextFieldHeading.addEventListener('dblclick', STnextFieldHeading.fn=function fn() {
		//check table is initialized
		if(blockEdit) {
		alert("Before tapping this Field Title, Tap Return to Home Screen first to initialize the table layout you just edited or created!");
		homeScreenBtn.setAttribute('class','borderBlink');
	homeScreenBtn2.setAttribute('class','borderBlink');
		//blockEdit = false;
		resetFields = true;
		return false;
	}
			
STnextFieldHeading.setAttribute('class','borderBlink');
//check trigger
//alert("trigger = " + trigger + " prefVariablesArray[9] = " + prefVariablesArray[9]);

if(trigger === 'copy') {
	alert("The trigger to edit a data cell MUST BE IN DBL-CLICK mode in order to use the active telephone number function. Return to Preferences and reset the edit mode to DBL-CLICK");
	
	showTable.setAttribute('class','hidden');
	prefWindow.setAttribute('class','showing');
	editTDTriggerBtn.setAttribute('class','borderBlink');
	return;
}//end if(trigger === 'copy')	
	if(fieldNamesArray[k].includes("TELEPHONE")) {
			telephoneActive = true;
			telephoneAlertFlag2 = false;
			eMailAlertFlag2 = true;
		} else if (fieldNamesArray[k].includes("EMAIL")) {
			eMailActive = true;
			eMailAlertFlag2 = false;
			telephoneAlertFlag2 = true;
		}//end if else if	
		
//STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
//k is 4 or > so this applies only to dynamic fields
if(!eMailAlertFlag2) {
	alert("eMail address now active! Double click on email address to SEND EMAIL!");
eMailAlertFlag2 = true;
	}//end if(!eMailAlertFlag) 
	
if(!telephoneAlertFlag2) {
	alert("Telephone number is now active! Double click on telephone number to PHONE!");
telephoneAlertFlag2 = true;
	}//end if(!eMailAlertFlag) 

STnextFieldHeading.removeEventListener('dblclick', STnextFieldHeading.fn, false);

//STnextFieldHeading.setAttribute('class','stHeadRow');
//STnextFieldHeading.setAttribute('class','borderBlink')

});//end STnextFieldHeading.addEventListener

}//end if(fieldNamesArray[k].includes("TELEPHONE") ||



//Date:Oct25 this works so now need more debugging!!
//ADDING CODE FOR TELEPHONE AND EMAIL IN DYNAMIC HEADERS	^^^

}//end for loop

//if(!loadFromTableOptions) {
//	trimHeadRow();//this won't run here anyway ..should be able to REMOVE 
//	}//end if !loadFromTableOptions
	//trimHeadRow();//trimHeadRow removed the dynamic fields in the new table after loading from a new table edit..so try if !loadFromTableOptions?
//	*/
	
}//end if makeContactsTable || loadFromTableOptions this did not work!
//


//END OF DEALING WITH FIELD TITLE.HEADER CREATION

//return false;
//newTableEdit = false;//done with this flag now that edited newTable will be saved ? Need to move this line to savevariables???? Date: Febe

//START OF CREATING THE RECORD ROWS

console.log('Now just creating records!');
//alert("At now just creating records. tableTitle.length = " + tableTitle.length);
//alert here says tableTitle.length = 1 when it should be 3 !! Start here tomorrow to troubleshoot. Jan19 NOTE I DID NOT SAVE THE FILE I WAS TRYING TO LOAD IN ??Does this matter??!!
	//iterate through all records
	//tableTitle.length can also be counter
	for(let i = 0; i< tableTitle.length; i++) {
	//end for i = to show all records IS AT LINE 9648!!!!!!!!!!!!!!
	// 	if (i >counter) {
		//ReferenceError: Can't find variable: e
	//   e.preventDefault();
  // }//end if counter e.prevent default
		//alert('at for i loop: i = ' +i + ' c = ');
		
		const STrecordItem = document.createElement('tr');
//STrecordItem.setAttribute('class','hovering');



		// const STlinkTdAfter=document.createElement('p');//to add the text after the link
		
//june6	//	const STlinkTdBefore=document.createElement('p');//to add the text before the link
		// if(darkMode)
		// {STrecordItem.setAttribute('class','darkMode')}//end if darkMode
		// else {STrecordItem.setAttribute('class','lightMode')}//end else if dark light mode
		//highlight record row if target of search Jan8 THIS CHANGED THE FONT SIZE,!! and underlined IF A REFRESHTABLE OCCURRED AS IN A CELL EDIT! So maybe create the show record button to Reid’s play the table?
//highlight hits
if (fromSearchRecord) {
	//if(hits.length>1) { changed May3
	if(hits.length>=1) {
		for (j=0;j<hits.length; ++j) {
			if(i===hits[j]) {
			
//THIS CODE CREATES SEARCHED HITS TABLE ARRAY !!!BUT ONLY IF hits.length>1 so should a single entry be made for a case of only 1 hit maybe change if hits.length>=
	searchedHitsTableArray[j] = tableArray[i];		
//SHOULD I REMOVE DUPLICATES HERE?..not until end of loop. See below line 		
			
	console.log("searchedHitsTableArray[" + j + "] = " + searchedHitsTableArray[j]);		
			
	//searchedHitsTableArray[0] = 
//Fireside Grill , May 03 2022 21:24,(250) 658-5645 ,Gourmet ,West Saanich Rd		
			
			
				
	//hits[j] will have been given a value of i from iterating through the record titles in the search function so that if i iterating through the display records function = the i value given to hits[], that means the recods matched so highlight it
	
//CODE TO CREATE NEWTABLE FROM SEARCH HITS WILL GO HERE!!!!
//searchedTableArray[hits[j]] = tableArray[i];
//after iteration complete savedTableArray[tableIndex] = searchedTableArray.splice();

//CODE TO CREATE NEWTABLE FROM SEARCH HITS WILL GO HERE!!!!

				STrecordItem.setAttribute('class','highlightgreen');
				
//document.querySelector('#tableWin').children[i].scrollIntoView({block: "end"});
	//const element = document.getElementById("tableWin");
 // element.scrollIntoView();			

	//	tableArray[i].scrollIntoView(true);	
		//STrecordItem.scrollIntoView(true);	
			
			//hitsArray[k] = tableArray[i]
			}//if i=hits[j]
//document.querySelector('#STforRows').children[i].scrollIntoView(true);			
		}//end for loop j -hits.length
document.querySelector('#STforRows').children[i].scrollIntoView(true);
	
	} else if(i=== matchedRecordIndex & fromSearchRecord) {
			fromSearchRecord = false;
	searchedHitsTableArray[0] = tableArray[i];//added May4 	
	STrecordItem.setAttribute('class','highlightgreen');
	//scroll to searched item added July 8. Test to make sure this doesn't slow down program!!!
	document.querySelector('#STforRows').children[matchedRecordIndex].scrollIntoView(true);	
	fromSearchRecord = false;

 }//end if hits.length >1	

}//end ifhfromSearchRecord
	
	
//alert("In displayTable, recreating record rows: fromSearch is true..searchedHitsTableArray = " + searchedHitsTableArray);
	
	
	
	
//comment out old code
// 		if(i=== matchedRecordIndex & fromSearchRecord) {
// 			fromSearchRecord = false;
// 		STrecordItem.setAttribute('class','highlightgreen');
// 	//scroll to searched item added July 8. Test to make sure this doesn't slow down program!!!
// document.querySelector('#STforRows').children[matchedRecordIndex].scrollIntoView(true);	


// 		// //May28
// 		// STrecordItem.setAttribute('style','text-decoration:over-line');
// 		}//end if i=matched record index
		
//comment out old code
		
		
		
		
		
		
		
		
		//add a row to the table
		STrows.appendChild(STrecordItem);//maybe not [i]
		//add field data for each td in the row
			for(let c=0;c<numberOfFields;c++){
				//alert('at for c loop: i = ' +i + ' c = '+c);
			//create a data cell to be included in the row
		const STrecordTd=document.createElement('td');//add td cell to row..left off here date:Aug 16 2020
		const STlinkTdAfter=document.createElement('p');//to add the text after the link NOTE! Had to move the declaration of STlinkTdAfter here in the for number of fields loop to create separate elements for each td cell in each row, otherwise if declared only in the i record loop there is only one STlinkTdAfter p element for each row and that is why the postLinkInfo disappeared after creating another one in the same row!
		
		STrecordItem.appendChild(STrecordTd);
		if(darkMode===null){
		STrecordTd.setAttribute('class','default')
		
	}else if(darkMode)
		{STrecordTd.setAttribute('class','darkMode')}//end if darkMode
		else  {STrecordTd.setAttribute('class','lightMode')}//end else if dark light mode

	//for HORIZONTAL SCROLL	
if (c===0 && scrollTable) {
	STrecordTd.setAttribute('style',' background-color:lightgreen;text-size:larger; color:black; z-index: 1001; position:sticky; left: 0; border-left: 0; border:3px solid red; margin: 0')//position:sticky here makes td c=0 scroll over first field title..not what we want!
STheadName.setAttribute('style', 'position:sticky; z-index: 1005')	
	//STrecordTh.textContent = tableArray[i][c];
}//end if c===0

if(!scrollTable) {
	STheadName.setAttribute('style', 'position:static; color: black; z-index: 1005')
	
if (c===0 && !scrollTable) {
	STrecordTd.setAttribute('style','color: black');
}//end if c=0 & !scrollTable
	//z-index was 1005
	//position static works but locomotive title goes up and next fecord title is visible too high
//position fixed makes first field title disappear (locomotive)	
//code below crashes computer
/*clearHeadRow();
console.log('Removed dynamic fields! ' + STheadRow);
STheadRow.appendChild(STheadName);
STheadRow.appendChild(secondFieldName);
STheadRow.appendChild(STfirstDataNameTd);
STheadRow.appendChild(STsecondDataNameTd);
refreshed = 1;
displayTable();
refreshed = 0; */
//code above crashes computer

//field labels of static fields now restored!

}//end if (!scrollTable)
// if(c>0) {
// 	STrecordTd.setAttribute('style',' position:relative')
// }
//for HORIZONTAL SCROLL		



		//put text of the tableArray[][] in the data cell	
	//	TypeError: undefined is not an object (evaluating 'tableArray[i][c]')Feb23 after create new db!
	

//alert("loadFromTableOptions = " +loadFromTableOptions + ". tableArray[i][c] = " + tableArray[i][c] + ". dataBaseName = " + dataBaseName + ". dbName = " +dbName );
//loadTheDataBase (dataBaseName)	
// if(clickedMoreTables) {
// dataBaseName = dbName;
// loadTheDataBase(dataBaseName);
// clickedMoreTables = false;
// displayTable();
// }
//TRY THIS CODE TO FIX TYPE ERROR DATE: Jan16 2023	
// if(tableArray[i][c]=== undefined || tableArray[i][c]===0 || tableArray[i][c]=== " " || tableArray[i][c]=== null || tableArray[i][c]=== "") {
// 	tableArray[i][c] = "EDIT";
// 		STrecordTd.textContent = tableArray[i][c];
// 	} else {//end if tableArray[i][c]===undefined
// 		//put text of the tableArray[][] in the data cell	
// 	//	TypeError: undefined is not an object (evaluating 'tableArray[i][c]')Feb23 after create new db!
// 	//TypeError: undefined is not an object (evaluating 'tableArray[i][c]')	date:Jan16 2023
// 	STrecordTd.textContent = tableArray[i][c];//tableTitle (global) array has to be constructed in displayData of indexedDBNotes	This is the info from displayData that was put into the tableArray n buildRecordRows when constructing the table
// 	}//end if(tableArray[i][c]=== undefined || tableArray[i][c]===0 || tableArray[i][c]=== " " || tableArray[i][c]=== null || tableArray[i][c]=== "") 
//TRY THIS CODE TO FIX TYPE ERROR DATE: Jan16 2023		
	

STrecordTd.textContent = tableArray[i][c];
	
		
	// STrecordTd.textContent = tableArray[i][c];//tableTitle (global) array has to be constructed in displayData of indexedDBNotes	This is the info from displayData that was put into the tableArray n buildRecordRows when constructing the table
	
	// //to allow table edit to avoid dblclick and to work in a blank td cell as will be the case if adding a dynamic field in edit table enter a text string to facilitate the copy paste iOS process to allow data entry. Oct 19 2021
	
	if(tableArray[i][c]=== undefined || tableArray[i][c]===0 || tableArray[i][c]=== " " || tableArray[i][c]=== null || tableArray[i][c]=== "") {
			if(budgetSheet) {
			STrecordTd.textContent = "    ";
		
			 } else {
			 STrecordTd.textContent = "EDIT"; 
			 }
	 }//end if tableArray[i][c]===undefined
	
	//to allow table edit to avoid dblclick
	
	
			//console.log('In displayTable.  tableArray['+i+']['+c+'] = ' + tableArray[i][c]);
			
	// //CHECK IF ROWS SUMMED date Nov13
	// if(tableArray[i][c].includes(sumRowTxt)	) {
	// 			rowSummed = true;
	// 			}//end if(tableArray[i][c].includes(sumRowTxt)	) {
	//alert("checking for rowSummed");
	//if(tableArray[i][c].includes(sumRowTxt)	) {
			//		rowSummed = true;
//TypeError: undefined is not an object (evaluating 'tableArray[i][c].includes')
//PROBABLY NEED TO STORE rowSummed variable in tableVariables array?
					
				//} else {
				//	rowSummed = false;
			//		}//end if else
	//CHECK IF ROWS SUMMED
	//check if link
//at this point tableArray[i][cx4] is automatically generated back in the buildRecord rows section and as of May30 will not contain any links. Actual links can be added in buildRecord rows for c>3 via input into the dynamic fields. What happens if edit table puts a link in a fixed field. As of May 30 it is not active?FIXED see notes in documentation
//console.log('STrecordTd.textContent = ' + STrecordTd.textContent)

	//CHECK IF ROWS SUMMED date Nov13
//alertx("checking if rowSummed!")
	//alert("checking for rowSummed");
	//if(tableArray[i][c].includes(sumRowTxt)	) {
				//	rowSummed = true;
				//	}//end if(tableArray[i][c].includes(sumRowTxt)	) {
// if(STrecordTd.textContent.includes('http:'||'https:'||'www')) {
//CHECK FOR PRESENCE OF A LINK!	if so set the linked flag to true
if(STrecordTd.textContent.includes('http:')||STrecordTd.textContent.includes('https:')||STrecordTd.textContent.includes('www')) {	
	
	console.log('https contained condition is met! STrecordTd.textContent has a link! = ' + STrecordTd.textContent);
	//linked = true; commented out June6 did this mess up setting table? Why did postLink not appear in last record decoder field?
	
//isolate link. If link is not at the start of data i.e. slice(0,4) !== "http", in which case there must be other text preceding, then send data string to isolate link to put pure link in the tableArray[][]. If the link is at the srptart such as is the case when entered in the table by pass isolateLink and just go straight to creating the <a> element. BTW only need to test for http below because https contains http
//keepPreLinkInfo = false;//June 3 isolate link flag initialized to false
preLinkInfo = "";//initialize variable allows Doubleztap here in a pure link

//ISOLATE THE LINK ANYWAY
// console.log('Checking to see if the link is at the beginning of the data info or not. If not isolate the link. STrecordTd.textContent.slice(0,4)= ' +STrecordTd.textContent.slice(0,4));
// let checkLink = STrecordTd.textContent.slice(0,4);
// let checkWWWLink = STrecordTd.textContent.slice(0,3);

// //LINE BELOW MESSES UP WHAT IS WRONG WITH MY ||statement???? June3
// //if(checkLink !== "http"|| checkLink !== "https") {
// //maybe should use if(checkLink !== "http"||checkWWWLink !== "www") {
// 	//probably doesn't matter because no harm in going to isolateLink anyway?? Jun 4 2021
// if(checkLink !== "http") {
// 	//if (STrecordTd.textContent.slice(0,4) !== "http" || STrecordTd.textContent.slice(0,3) !== "www") {
// 		// let textContainingLink = tableArray[i][c];
// 		//make tableArray[][]= the isolated link.the rest of the data will be lost to the table. So note in docs that putting a link in the notes data field automatically puts the link in the table minus the rest of the data from notes
// 		//THE LINK IS NOT AT THE FRONT SO CALL ISOLATELINK because there is preceding text
// 		keepPreLinkInfo = true;//flag to call isolateLink()
// 		console.log('keepPreLinkInfo = ' + keepPreLinkInfo);
// 	}//end if checkLink STrecordTd.textContent.slice(0,4) != "http"etc
		
		let textContainingLink = tableArray[i][c];
		
		// tableArray[i][c] = isolateLink(textContainingLink);
		//Retain value of tableArray[][] so use separate variable for the link
	// if(keepPreLinkInfo) {
	// 	theLink = isolateLink(textContainingLink);
	// } else {
	// 	theLink = tableArray[i][c];
	// }//end if else keepPreLinkInfo
	
	
		theLink = isolateLink(textContainingLink);
	
		
		
		
			// theLink = isolateLink(textContainingLink);
	//}//end if STrecordTd.textContent.slice(0,4) != "http"etc
	//IF DATA AFTER LINK MIGHT PUT CALL TO ISOLATE LINK HERE SO ALL DATA IS FILTERED ?????
	console.log('tableArray[][] is retained = ' + tableArray[i][c] +' …. but the pure link = ' + theLink);
	
	//console.log('keepPreLinkInfo = ' + keepPreLinkInfo);
	//to keep background-color of link cells  same as other table cells
	if(darkMode===null){
		STrecordTd.setAttribute('style','background-color:yellow;color:black')
		
	}else if(darkMode)
		{STrecordTd.setAttribute('style','background-color:darkblue;color:white')}//end if darkMode
		else  {STrecordTd.setAttribute('style','background-color:white;color:black')}//end else if dark light mode
//Above code to keep background color of link cells same as other cells June11
	//to better format table cells in the table June11
	STrecordTd.setAttribute('class','td_size')
	//to better format table cells in the table June11
	
	const STlinkTd=document.createElement('a');
	//const STlinkTdAfter=document.createElement('p');//to add the text after the link
	
	//only print preLinkInfo here if not planning to have to use as link text. Don't want it showing twice
	if(!linkLabel ) {
		// STrecordTd.setAttribute('class','td_size')
		
		STrecordTd.textContent= preLinkInfo;
		}//end if keepPreLinkInfo &&!linkLabel
		
		//keepPreLinkInfo = false;//REMOVE THIS LINE IF USING THE ADD TEXT AFTER LINK Jun4
		//should I clear preLinkInfo?
		//preLinkInfo = "";bJun 2
		//was keepTableNote[i] ;
		console.log('testing no preLinkInfo. preLinkInfo = ' + preLinkInfo);
		
		console.log('postLinkInfo = ' + postLinkInfo);
		
	// if(preLinkInfo === "" && postLinkInfo === "") {
		
	// preLinkInfo = "Double-Tap HERE to edit link\n";
	// STlinkTd.textContent = "Tap HERE to OPEN link"
	//linked = true;//reusing flag to make no pre or postLink
	//STrecordTd.textContent="Double-Tap HERE to edit link\n";
//}//end if preLinkInfo === " && postLinkInfo ==== ""	

if(preLinkInfo === "" && postLinkInfo !== "") {
		//try line below?June8
	preLinkInfo = "Double-Tap HERE to edit link\n";
	//STrecordTd.textContent="Double-Tap HERE to edit link\n";
} else if (preLinkInfo === "" && postLinkInfo === "") {
	preLinkInfo = "Tap HERE to OPEN link\n";
	
	}//end else if preLinkInfo === ""&& postLinkInfo === ""


			
	//LEFT OFF HERE MAY31	
	
	//below code erase
if (linkLabel && postLinkInfo !== "") {
	STrecordTd.textContent= preLinkInfo;
	// STrecordTd.setAttribute('style','width: STlinkTdAfter.length');
	}//end linkLabel && postLinkInfo !==""
	
//this code added June8	to fix preLinkInfo from appearing when it is also used as the link reference. If postLinkInfo empty preLinkInfo will be used as link reference (if linkLabel)
if (linkLabel && postLinkInfo === "") {
	STrecordTd.textContent= "";//was just "". Now 25 spaces to better format table if linkLabel
	// STrecordTd.setAttribute('style','width: STlinkTdAfter.length');
}//end linkLabel && postLinkInfo !==""

//above code saved	
			
			const STbreak = document.createElement('br');
			//add the <br> for all links!
		//	if(!linkLabel) {
			STrecordTd.appendChild(STbreak);
		//	}//end if (!linkLabel) //June 12
			
	//put actual link (which in this case is tableArray[i][c]) into href = of the <a> element. This is why in this case tableArray[][] has to be a true link, otherwise setAttribute'href' will just ignore it
	//STlinkTd.setAttribute('href',tableArray[i][c]);
	
	STlinkTd.setAttribute('href',theLink);
		STrecordTd.appendChild(STlinkTd);
		//STrecordTd now contains text and the link
		//now add the text(what is displayed in link format..blue underline, to the link. So the link in the tableArray[][] variable is displayed). This is where you could edit tableArray[][] to a representive name for the link and have it displayed.
		//STlinkTd.textContent = tableArray[i][c];
	//choice of using trailing text as link label	
	//SET VISIBLE LINK LABEL TO BE EITHER ALTERNATE LABEL..POST IF PRESENT, OTHREWISE PRE TEXT…IF NO SURROUNDING TEXT USE THE LINK ITSELF AS THE VISIBLE LABEL
	if(linkLabel && postLinkInfo !== "") {
		STlinkTd.textContent = postLinkInfo;
	}else if (linkLabel && preLinkInfo !== "") {STlinkTd.textContent = preLinkInfo;
	}else{
	STlinkTd.textContent = theLink;
		//STlinkTd.textContent = postLinkInfo;
	}//end if else linkLabel
	
	// if(linkLabel && linked){
	// 	STlinkTd.textContent = "Tap HERE to OPEN link";
	// 	linked = false;
	//}//end if linkLabel && linked
	
			if(darkMode) {
				STlinkTd.style.color = "red";
			}else {
				STlinkTd.style.color = "blue";
			}//end if else darkMode
			
// console.log('Making decision to add the post link text. keepPreLinkInfo flag = ' +keepPreLinkInfo);			
if(!linkLabel) {
	STlinkTdAfter.setAttribute('style', 'font-size: larger; color: red; margin: 0');
	STlinkTdAfter.textContent = postLinkInfo;
	console.log('adding post link text');
	STrecordTd.appendChild(STlinkTdAfter);
	//keepPreLinkInfo = false;June7
	console.log('After appending to STrecordTd STlinkTdAfter.textContent = ' + STlinkTdAfter.textContent);
	}//end if keepPreLinkInfo && !linkLabel
	//june7
	//postLinkInfo = "";//reset for next rcord
	preLinkInfo = "";
	PostLinkInfo = "";
	//linked = false;
	//keepPreLinkInfo = false;//is this why we lose the post link info?June7
	
}//end if textContent includes a link
	//ALL ABOVE CODE ONLY APPLIES IF THERE IS A LINK PRESENT IN THE ENTRY	
	
	
//ADD TEXT AFTER LINK If keepPreLinkInfo flag made false above this code won't run. Do this if you want to use the after text as the label for the link for example!
// if(keepPreLinkInfo && !linkLabel) {
// 	STlinkTdAfter.setAttribute('style', 'font-size: larger; color: red; margin: 0');
// 	STlinkTdAfter.textContent = postLinkInfo;
// 	STrecordTd.appendChild(STlinkTdAfter);
// 	keepPreLinkInfo = false;
// 	}//end if keepPreLinkInfo
	//end check if link	
			
			//addEventListener to allow edit of td values changed dblclick to copy trigger contains event type set in preferences
			//trigger = 'copy';
			//trigger = 'mouseover';
			//console.log("trigger = " + trigger);
	STrecordTd.addEventListener(trigger, function () {
	
//IF EMAIL OR TELEPHONE ACTIVE SWITCH THESE OFF SO TAPPING IN TOTAL OR AVERAGING TD CELLS DOES NOT CAUSE PHONE OR EMAIL API TO START UP.vvvvvDATE NOV5 2022

//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED
//fieldNamesArray[k].includes("TELEPHONE")

//if(telephoneActive && fieldNamesArray[c] !== "TELEPHONE" || eMailActive && fieldNamesArray[c] !== "EMAIL") {

// if(telephoneActive && !(fieldNamesArray[c].includes("TELEPHONE") || eMailActive && !(fieldNamesArray[c].includes("EMAIL"))) ) {

// resetActiveFieldHeaders();
// }//end if(telephoneActive || eMailActive) {

//DATE NOV7
console.log("telephoneActive = " + telephoneActive + " eMailActive = " + eMailActive);

if(telephoneActive && !(fieldNamesArray[c].includes("TELEPHONE"))) {
console.log("at if telephoneActive - resettingActiveFieldHeaders " + " c = " + c);

resetActiveFieldHeaders();//resetActiveFieldHeaders only applies to DYNAMIC FIELDS this loops through all fields and so of course some woll not contain keyword and will do a reset^instead try making keywords TELEPHONE AND EMAIL  = false when tapping a TOTAL FIELD
//telephoneActive = true;
}//end if(telephoneActive 

if(eMailActive && !(fieldNamesArray[c].includes("EMAIL"))) {
console.log("if eMailActive - resettingActiveFieldHeaders " + "c = " + c);
resetActiveFieldHeaders();
//eMailActive = true;
}//end if(emailActive 

//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED

//IF EMAIL OR TELEPHONE ACTIVE SWITCH THESE OFF SO TAPPING IN TOTAL OR AVERAGING TD CELLS DOES NOT CAUSE PHONE OR EMAIL API TO START UP.^^^^^^^^^	
	
//code to send email IF eMailActive = true	
if(c===3 && eMailActive) {
let eMailAddress = STrecordTd.textContent;

//eMailActive = false;//should i comment this out so more than one email can be sent?
//Nov7 DON'T REMOVE EVENT LISTENER BECAUSE NO WAY OF REINSTATING IT WITHOUT RUNNING DISPLAYTABLE AGAIN.
//STsecondDataNameTd.removeEventListener;
//STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);//added this July8 should it be removed?
//STsecondDataNameTd.style.backGroundColor="lightpink";
//STsecondDataNameTd.setAttribute('class','stHeadRow');
//window.open( String( 'mailto:recipient^example.com' ).replace('^', '@') )
//<a href="tel:+919876543210">Call</a>;

window.open( String( 'mailto:' + eMailAddress));
eMailAlertFlag = false;
//STsecondDataNameTd.setAttribute('class','stHeadRow');//to reset flashing because now activation deactivated via resetActive Field Headers!
//resetActiveFieldHeaders();//added Nov6 because going to TELEPHONE right after did not work anymore
return false;//added July7 2022
//window.open('mailto:STrecordTd.textContent');	
}//end if(c===3 && eMailActive) 


//code to send email IF eMailActive = true	

//alertx("telephoneActive = " + telephoneActive);
//code to call number IF telephoneActive = true	
if(c===2 && telephoneActive) {
let telephoneNumber = STrecordTd.textContent;
//alertx("Telephone number to dial is: " + telephoneNumber);
//eMailActive = false;//should i comment this out so more than one email can be sent?
//alertx("at c==2 && telephoneActive : STfirstDataNameTdListener = " + STfirstDataNameTdListener);

//Nov7 DON'T REMOVE EVENT LISTENER BECAUSE NO WAY OF REINSTATING IT WITHOUT RUNNING DISPLAYTABLE AGAIN.

//STsecondDataNameTd.removeEventListener;

//Nov7

//STfirstDataNameTd.removeEventListener('dblclick',STfirstDataNameTd.fn, false);

// Example:
// canvas.addEventListener('click', function abc(event) {
//     click++;
//     if (click >= 50) {
//         // remove event listener function `abc`
//         canvas.removeEventListener('click', abc);
//     }
//window.onmousemove = null
//<a href="tel:+919876543210">Call</a>;
//window.onmousemove = function(e){console.log("mouse cursor:", e.clientX, e.clientY)}


window.open( String( 'tel:' + telephoneNumber));
telephoneAlertFlag = false;
//STfirstDataNameTd.removeEventListener;

//alertx("about to remove eventListener .. at window.open…tel..STfirstDataNameTd.textContent = " + STfirstDataNameTd.textContent);
//STfirstDataNameTd.setAttribute('class','stHeadRow');
//eventListener on field title STfirstDataNameTd has been removed. Header still flashes and dblclick on td tel number still brings up dialer
//resetActiveFieldHeaders();//added Nov6 because going to TELEPHONE right after did not work anymore

return false;//added July7 2022
//window.open('mailto:STrecordTd.textContent');	
}//end if(c===3 && telephoneActive) 

if(c>3 && telephoneActive) {
let telephoneNumber = STrecordTd.textContent;
window.open( String( 'tel:' + telephoneNumber));
telephoneAlertFlag = false;

//NOV7

//STnextFieldHeading.removeEventListener('dblclick', STnextFieldHeading.fn);
STnextFieldHeading.setAttribute('class','stHeadRow');
//code to call telephone number IF telephoneActive = true	
return false;	
}//end if(c>3 && telephoneActive) 	

if(c>3 && eMailActive) {

let eMailAddress = STrecordTd.textContent;

window.open( String( 'mailto:' + eMailAddress));
eMailAlertFlag = false;
STnextFieldHeading.removeEventListener('dblclick', STnextFieldHeading.fn);
STnextFieldHeading.setAttribute('class','stHeadRow');
return false;//added July7 2022
//window.open('mailto:STrecordTd.textContent');	

//STfirstDataNameTd.removeEventListener;

}//end if(c>3 && telephoneActive) 	
	
	if(blockEdit) {
		alert("Before editing/activating this data cell, Tap Return to Home Screen first to initialize the table layout you just edited or created!");
		homeScreenBtn.setAttribute('class','borderBlink');
	homeScreenBtn2.setAttribute('class','borderBlink');
		//blockEdit = false;
		resetFields = true;
		return false;
	}
		
if(deleteRecordNewTable) {

//chance to backout v
if (window.confirm("Delete record :  " + tableArray[i] + "? : \n" + " \n CANCEL will Return to Table")) {

} else {
	deleteRecordNewTable = false;
	return;
}//end prompt else
//chance to backout ^

let deletedRecordNewTable = tableArray.splice(i,1);
tableTitle.length = tableTitle.length-1;
//deleteRecordNewTable = false;
deleteRecordNewTableBtn.style.display = "none";
saveTableBtn.setAttribute('class','borderBlink');
saveTableBtn2.setAttribute('class','borderBlink');
homeScreenBtn.disabled = true;//to help force Save..now reset after flashing SAVE
			 homeScreenBtn2.disabled = true;
moreTablesBtn.disabled = true;

alert("You have deleted the record: " + deletedRecordNewTable);
resetFields = true;
blockEdit = true;//to stop a double click from deleting a record again

//ADD THIS CODE SO THAT A REPEAT DBL CLICK INTENDED FOR EDITING DOES NOT DELETE A RECORD! Date: June7
deleteRecordNewTable = false;
//ADD THIS CODE SO THAT A REPEAT DBL CLICK INTENDED FOR EDITING DOES NOT DELETE A RECORD! Date: June7

displayTable();

savedTablesArray[loadTableIndex]=tableArray.slice();
	
	//alertx("After deleting new table record - Back from displayTable — TDCell edit completed and refreshBtn just tapped: tableArray = " + tableArray + ". loadTableIndex = " + loadTableIndex + ". savedTablesArray should be newTable mode! savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + ". newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1]);
	
	console.log("After deleting new table record - Back from displayTable — TDCell edit completed and refreshBtn just tapped: tableArray = " + tableArray + ". loadTableIndex = " + loadTableIndex + ". savedTablesArray should be newTable mode! savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + ". newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1]);
	
return;	
}//end if deleteRecordNewTableBtn
	//to hasten edit disable Use Link Label Oct 28 2021 not necessary must have been a glitch related to experimenting with spaces? So this code is disabled
		// if(linkLabel) {
		// 	alert("If editing table cells disabling 'Use Link Labels' in Preferences is recommended!");
		// }//end if linkLabel
		
	//to hasten edit disable Use Link Label Oct 28 2021
		
		
		theLink = "";//clear reset the link
	//	let dblTappedOnce = true;
		const editTD = document.createElement('p');
		const editTDInput = document.createElement('input');
		const editTDInputBtn = document.createElement('button');
		editTDInputBtn.textContent = ' Clear/Initialize ';
		editTDInput.value = tableArray[i][c];
		editTD.textContent = 'Current value: '+ tableArray[i][c];
		STrecordTd.appendChild(editTD);
		if (c !== 1) {
		STrecordTd.appendChild(editTDInput);	
		}//end if c!==1 (Date)
		
		
		//code to add date input to double click TD date cell
		if (c === 1) {
			editTDInputBtn.textContent = 'OK ?';//
			// var input = document.createElement("input");
			// input.setAttribute('type', 'text');
			//
		var dateSelect = document.createElement("input");
		//for just the date use type 'date' instead of date time-local
	if (tableDateTime) {
		dateSelect.setAttribute('type','datetime-local');
	}//end if tableDateTime
	if(!tableDateTime) {
		dateSelect.setAttribute('type','date');
	}//end if !tableDateTime
	
		//('input[type="date"]');
		STrecordTd.appendChild(dateSelect);
			
			
		}//end if c===1 -  STrecordTd.textContent = DATE
		
		//code above to add date input to double click TD date cell
		
		STrecordTd.appendChild(editTDInputBtn);
		
editTDInputBtn.onclick = function (){
dataAltered = true;//flag to provide warning if data changed but not saved 
			console.log('editInputBtn tapped!');
//added Dec4 REMOVE IF MESSED UP
if (!makeContactsTable && !loadFromTableOptions) {//SO YOU DON'T TRY TO OVERSCROLL A NOTES SECTION
recordId = getRecordId(i);
scrollHere = true;//added Dec4
scrollBtn.textContent = "Scroll to Last EDIT";
}//end if (!makeContactsTable && !loadFromTableOptions) {

		//STrecordTd.disable = true;//to prevent repeat inputc 
	if(!toggleTdInputBtn) {	editTDInputBtn.setAttribute('class','attentionBtn');
			editTDInputBtn.textContent = 'Enter new value';
			editTDInput.value = '';
			toggleTdInputBtn = true;
		} else {
		toggleTdInputBtn = false;
			editTDInputBtn.setAttribute('class','normalBtn');
			//editTDInputBtn.textContent = 'OK - Clear';
			
			if (c===1){
				//dealing with the Date field
				//editTDInputBtn.textContent = 'OK?';//}
				

		//STrecordTd.removeChild(dateSelect);
		
		//trim seconds off time if tableDateTime
		if (tableDateTime) {
			dateSelect.value = dateSelect.value.slice(0,16);
		}//end if tableDateTime
		tableArray[i][c] = dateSelect.value;
		
//don't run code below if newTables because there are no notes for newTables
		
if (!makeContactsTable && !loadFromTableOptions) {
	
	editedTDchange = dateSelect.value;	
		//put code to edit date in notes here
		//Feb 13
		//Get record id from tableTitle[i][0]
		recordId = getRecordId(i);
		
		//pass recordId and the edited date(editedTDchange) to the editNoteDate function as parameters
		editNotesRecord(recordId,editedTDchange,c);
		scrollHere = true;//added Dec4
		scrollBtn.textContent = "Scroll to Last EDIT";
	}//end if (!makeContactsTable && !loadFromTableOptions) 
	
//don't run code above if newTables because there are no notes for newTables	

		//put code to edit date in notes above  here
		
		}//end if c===1 -field STrecordTd.textContent = DATE
	// 	if (c !==1) {
	// 	//keep record id for field 0
	// 	if (c === 0) {
	// 		tableArray[i][c] = recordId + '> ' + editTDInput.value;
	// 	} else {//end if c===0
	// 	tableArray[i][c] = editTDInput.value;
	// 	}//end if c===0 else
	// }//end if c !==1
	
// if (c===2 && tableArray[i][2].includes("Cost to date = $")) {
// 	sumAcrossInfoP.style.display = "unset";
// }//end id c === 2
	
	//PUT NEW ENTY INTO DYNAMIC FIELDS TABLE ARRAY. THESE DO NOT HAVE TO BE SAVED IN NOTES
	if (c > 3) {
		//working in dynamic fields
		
		//ADD CODE HERE TO SUM TD CELLS HORIZONTALLY ALL IN THE ROW
		
	//	if(editTDInput.value === "sumAcross" ||  editTDInput.value.includes("Sum across = ")) {
//NOV16 if dbltapping last field and sumAcross entered		
if(c===numberOfFields-1 && editTDInput.value.trim() === "sumAcross" ||c===numberOfFields-1 && editTDInput.value.trim() === "Sum across" || c===numberOfFields-1 && editTDInput.value.trim() === "sum across" ||c===numberOfFields-1 && editTDInput.value.trim() ===  "sum Across" || c===numberOfFields-1 && editTDInput.value.trim() === "SumAcross" || c===numberOfFields-1 && editTDInput.value.trim() === "Sumacross") {
		
		// if(c===numberOfFields-1 && editTDInput.value === "railroadCrossing") {
		
		rowSummed = true;//flag to tell edit td cell routine to update row total. May have to save this variable!?
		//alertxy("showRULEonce = " + showRULEonce);
		
		if(!showRULEonce) {
			showRULEonce = true;
			alert("RULE: 'sumAcross' keyword inserted in last column of the FIRST record of the table and then subsequent records, will initiate summing of all numerical entries in DYNAMIC fields only, across that record row of the table. Any character(s) added to the number entry (i.e. 100% or 100!) will exclude that number from the 'sum across' addition. The TOTAL keyword in the field heading of the last column in the table will facilitate adding all numerical entries vertically in the table column, IF THE LAST DATA CELL (last column) OF THE FIRST RECORD  was initialized with the 'sumAcross' keyword. The total is updated in the first data section of notes if the text 'Cost to date = $' or 'Total to date = ' is pre-entered in the NOTES data cell. The TOTAL keyword in field headings of all other columns (DYNAMIC fields only) works as indicated.");
		}//end if(!showRULEonce) {
rowSUM = sumAcross(i,c);

//alertxy("rowSUM = " + rowSUM);

//editTDInput.value =  "Sum across = " + rowSUM;
//editTDInput.value =  sumRowTxt + rowSUM;
editTDInput.value = tableArray[i][0] + ": " + sumRowTxt + rowSUM;
//update data entry at 3rd column
//alert("tableArray[i][2] = " + tableArray[i][2]);
//DATE: Nov 22 2022 Cost to date = $ is specific to a budget spreadsheet table! You will lose anything after the : unless you add more code to retain the data after the : which could be done using .splice()
if (tableArray[i][2].includes("Cost to date = $")) {
	tableArray[i][2] = "Cost to date = $"+rowSUM;
	//update notes
	editedTDchange =  "Cost to date = $"+rowSUM;	
		//put code to edit date in notes here
		//Feb 13
		//Get record id from tableTitle[i][0]
		recordId = getRecordId(i);
		
		//pass recordId and the edited date(editedTDchange) to the editNoteDate function as parameters
		editNotesRecord(recordId,editedTDchange,2);//make c = 2 here so as not to have to change value of c as code proceeds
		scrollHere = true;
		scrollBtn.textContent = "Scroll to Last EDIT";
	}//end if tableArray[][].includes("Cost to date")
	
	if (tableArray[i][2].includes("Total to date = ")) {
	tableArray[i][2] = "Total to date = "+rowSUM;
	//update notes
	editedTDchange =  "Total to date = "+rowSUM;	
		//put code to edit date in notes here
		//Feb 13
		//Get record id from tableTitle[i][0]
		recordId = getRecordId(i);
		
		//pass recordId and the edited date(editedTDchange) to the editNoteDate function as parameters
		editNotesRecord(recordId,editedTDchange,2);//make c = 2 here so as not to have to change value of c as code proceeds
		scrollHere = true;
		scrollBtn.textContent = "Scroll to Last EDIT";
	}//end if tableArray[][].includes("Total to date")
	
rowSUM = 0;//reset rowSum
}//end if(editTDInput.value === "sumAcross" ||  editTDInput.value.contains("Sum across = ") {
		//if(editTDInput.value === sumAcross) {
			//sumAcross(rowSum);
			//editTDInput.value = editTDInput.value + rowSum;
		//}//end if(editTDInput.value === sumAcross
//NOTE THIS CODE IS IN THE ADDEVENTLISTENER(ONCLICK FUNCTION SO I AND C WILL BE FIXED)		
		tableArray[i][c] = editTDInput.value;
		console.log('c is > 3 so tableArray[][] is set to editTDInput.value');
		console.log('tableArray[i][c] = ' + tableArray[i][c]);
		
//when editing a td cell check if a horizontak row total needs updating i.e. rowSummed is true
//see if rowSummed variable can be set to true so as to avoid having to store it
//for (k = 4;k<numberOfFields;k++) {
				//if(tableArray[i][k].includes("Sum across = ")	) {
	//NOTE AT THIS POINT C ITERATION value  IS FIXED  SO A K ELEMENT MIGHT NOT YET EXIST AND IF SO tableArray[i][k]MIGHT BE AS YET UNDEFINED GENERATING THIS ERROR!	so make k = c here.don't need to iterate through k because sumAcross puts sumRowTxt in each cell that it is entered in. .does that fix it?		
	//TypeError: undefined is not an object (evaluating 'tableArray[i][k].includes')	
	//alertxy("In addEventListener editTDcell: checking if rowSummed so an update will be done. tableArray[i][numberOfFields-1] = " + tableArray[i][numberOfFields-1]);
		
	if(tableArray[i][numberOfFields-1]===undefined || tableArray[i][numberOfFields-1] === 0 || tableArray[i][numberOfFields-1] === "") {
		tableArray[i][numberOfFields-1] = "EDIT";
	}//end if(tableArray[i][numberOfFields-1]===undefined) {
	
	//alertxy("tableArray[i][numberOfFields-1] = " + tableArray[i][numberOfFields-1]); 
	
	//TypeError: undefined is not an object (evaluating 'tableArray[i][k].includes')	
				if(tableArray[i][numberOfFields-1].includes(sumRowTxt)	) {
					rowSummed = true;
				} else {
					rowSummed = false;
					}//end if else
		//		}//end for (k = 4;k<numberOfFields;k++) {
				
//MAYBE TRY THIS:.. just check last columns data cell for sumRowTxt
// if(tableArray[i][numberOfFields-1].includes(sumRowTxt)	) {
// 					rowSummed = true;
// 				} else {
// 					rowSummed = false;
// 					}//end if else
				
//alertxy("rowSummed = " + rowSummed);

//FOR UPDATING SUM OF ALL COLUMN ENTRIES IN THE ROW IF THERE IS AN EDIT!
		if(rowSummed) {
			//for (k = 4;k<numberOfFields;k++) {
				//if(tableArray[i][k].includes("Sum across = ")	) {
		//this allows the sumAcrossbtotal to be in any DYNAMIC column ..not just the last..but not sure this will ever be required if always putting the sumAcross total in the end column	
		//this will update by calling the sumAcross function getting the updated rowSUM, and will tack on the record item label first column id label and put it all in the td cell that had contained the sumRowTxt(which should be the last column if user follows the sumAcross rule)
				//if(tableArray[i][k].includes(sumRowTxt)	) {
					rowSUM = sumAcross(i,c);
					
					//alertxy("in if rowSummed - rowSUM = " + rowSUM + "   i = " + i);
					//tableArray[i][k] = "Sum across = " + rowSUM;
					//tableArray[i][k] =  sumRowTxt + rowSUM;
					tableArray[i][numberOfFields-1] = tableArray[i][0] + ": " + sumRowTxt + rowSUM;
					
	//trim white spaces at end if any were added..why does parseString.length increase by 1 	?	MAYBE rowSUM GETS an extra space why? BUT THIS WORKED.. TRIMMED OFF WHITESPACE!	
	tableArray[i][numberOfFields-1] = tableArray[i][numberOfFields-1].trim();
	
	//update data entry at 3rd column if Cost to date text is present this is an automatic update without having to dbl-tap third column as occurs in code at line 10459
if (tableArray[i][2].includes("Cost to date = $")) {
	tableArray[i][2] = "Cost to date = $"+rowSUM;
	//update notes
	editedTDchange =  "Cost to date = $"+rowSUM;	
		//put code to edit date in notes here
		//Feb 13
		//Get record id from tableTitle[i][0]
		recordId = getRecordId(i);
		
		//pass recordId and the edited date(editedTDchange) to the editNoteDate function as parameters
		editNotesRecord(recordId,editedTDchange,2);//make c = 2 here so as not to have to change value of c as code proceeds
		scrollHere = true;
		scrollBtn.textContent = "Scroll to Last EDIT";
	}//end if tableArray[][].includes("")
	
	if (tableArray[i][2].includes("Total to date = ")) {
	tableArray[i][2] = "Total to date = "+rowSUM;
	//update notes
	editedTDchange =  "Total to date = "+rowSUM;	
		//put code to edit date in notes here
		//Feb 13
		//Get record id from tableTitle[i][0]
		recordId = getRecordId(i);
		
		//pass recordId and the edited date(editedTDchange) to the editNoteDate function as parameters
		editNotesRecord(recordId,editedTDchange,2);//make c = 2 here so as not to have to change value of c as code proceeds
		scrollHere = true;
		scrollBtn.textContent = "Scroll to Last EDIT";
	}//end if tableArray[][].includes("Total to date")
		
	//alertxy("In rowSummed after an edit and tableArray[i][numberOfFields-1] is being reconstructed: tableArray[i][numberOfFields-1] = " + tableArray[i][numberOfFields-1] + " tableArray[i][numberOfFields-1].length = " + tableArray[i][numberOfFields-1].length + " SHOULD STILL BE 32 for West Jet");
	
	//alertxy("tableArray[i][0].length = " + tableArray[i][0].length + " sumRowTxt.length = " + sumRowTxt.length + " rowSUM.length = " + rowSUM.length);					
			//	}//end if(editTDInput.value.includes("Sum across 
			//	}//end if(editTDInput.value.includes("Sum across 
			//	}//end for (k = 4;k<numberOfFields;k++)
		}//end if(rowSummed) {
		
	}//end if c  3
	//new edited entry of dynamic fields now entered in tableArray
	//if newTable save values to savedTablesArray
	if (loadFromTableOptions || makeContactsTable) {
plusContactsEntered = true;//borrowed flag to prevent return to home screen btn from flashing after a td edit to save user extra steps in viewing the edited table Date: Mar22 2023		
homeScreenBtn.textContent = "RETURN to Home Screen";
homeScreenBtn2.textContent = "RETURN to Home Screen";

		if(c === 1) {
			tableArray[i][c] = dateSelect.value;
			//savedTablesArray[tableIndex][c] = dateSelect.value;
		} else {
		tableArray[i][c] = editTDInput.value;
		
// if(deleteRecordNewTable) {
// let deletedRecordNewTable = tableArray.slice(i,1);
// deleteRecordNewTable = false;
// deleteRecordNewTable tn.style.display = "none";
// alert("You have deleted the record: " + deletedRecordNewTable);
	
// }//end if deleteRecordNewTableBtn


	//THIS IS WRONG …[c] has to be the whole tableArray value …so make savedTablesArray[loadTableIndex] = tableArray.slice() at refresh table btn after all edits?
		//savedTablesArray[tableIndex][c] = editTDInput.value;
		}//end if c===1
		
		//alertx("tableIndex = " + tableIndex + " loadTableIndex = " + loadTableIndex + " tableID = " + tableID + " tableArray[i][c] = " + tableArray[i][c] + " savedTablesArray[tableIndex] = " + savedTablesArray[tableIndex] + ". Is tableArray still in newTable mode?" + ".  savedTablesArray[tableID] = " + savedTablesArray[tableID] + " newTableFieldsArray = " + newTableFieldsArray);
		
		console.log("tableIndex = " + tableIndex + " loadTableIndex = " + loadTableIndex + " tableID = " + tableID + " tableArray[i][c] = " + tableArray[i][c] + " savedTablesArray[tableIndex] = " + savedTablesArray[tableIndex] + ". Is tableArray still in newTable mode?" + ".  savedTablesArray[tableID] = " + savedTablesArray[tableID] + " newTableFieldsArray = " + newTableFieldsArray);
		
		}//end if (loadFromTableOptions || makeContactsTable) 
	//to save the edits in the fixed fields to Notes. Remember the other fields are dynamic fields in table only and do not have to be saved to notes
	
//IF NEWTABLE CODE RUNNING SKIP ALL BELOW BECAUSE NEWTABLES DON'T HAVE NOTES
if (!makeContactsTable && !loadFromTableOptions) {
	
	if (c===0 | c===2 | c===3) {
	recordId = getRecordId(i);
	console.log('In editTDBtn.onclick. recordId as returned from getRecordId function = ' + recordId);
	//save recordId in tableArray for first ield
	if (c !==1) {
		//keep record id for field 0
		if (c === 0) {
			tableArray[i][c] = recordId + '> ' + editTDInput.value;
		} else {//end if c=== 0
		tableArray[i][c] = editTDInput.value;
	//THIS SHOULD MEAN THAT LINKS CAN BE ADDED TO THE LAST 2 DATA FIELDS IN THE TABLE..JUST NOT THE FIRST TITLE FIELD (BECAUSE tableArray[][] had a > added to it, and the second fixed field is the date field so don't even touch that one!)
		}//end if c===0 else
	}//end if c !==1
//send edit info back to ediNotes section	
	editedTDchange = editTDInput.value;	editNotesRecord(recordId,editedTDchange,c);
	scrollHere = true;//added Dec4
	scrollBtn.textContent = "Scroll to Last EDIT";
	}//end if c=0|c=2|c=3
	
}//end if (!makeContactsTable && !loadFromTableOptions) 	
//IF NEWTABLE CODE RUNNING SKIP ALL ABOVE BECAUSE NEW TABLES DON'T HAVE NOTES 
			
		if (c !== 1) {
		STrecordTd.removeChild(editTDInput);
		}//end if c!==1
		STrecordTd.removeChild(editTDInputBtn);
		const refreshBtn = document.createElement('button');
		refreshBtn.textContent = 'REFRESH TABLE';
	//	if (dblTappedOnce) {
		STrecordTd.appendChild(refreshBtn);
	//	dblTappedOnce = false;
	//}//end if dblTapped
	editTD.textContent = 'Current value: '+ tableArray[i][c];
		
	refreshBtn.onclick = function () {
	
	//code to prevent persisting email active
	
	if(STsecondDataNameTdListener) {
STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
	//STsecondDataNameTd.removeEventListener;
	STsecondDataNameTdListener = false;
	eMailActive = false;
}//end if(STsecondDataNameTdListener)

if(STfirstDataNameTdListener) {
STfirstDataNameTd.removeEventListener('dblclick',STfirstDataNameTd.fn, false);
	//STfirstDataNameTd.removeEventListener;
	STfirstDataNameTdListener = false;
	telephoneActive = false;
STfirstDataNameTd.removeEventListener;	
 STfirstDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STfirstDataNameTdListener)

//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED
if(telephoneActive || eMailActive || STfirstDataNameTdListener || STsecondDataNameTdListener) {
resetActiveFieldHeaders();
resetFixedFieldActivity();
}//end if(telephoneActive || eMailActive) {

//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED

		//there is a glitch here somewhere. The STHeadRow can get messed up if refreshed = 1 after an edit of the current displayed table. Do I need editCurrentTable set to 0 here?????!!!!!
		//keeping track of Save Btn Date: Feb 26 2021
		console.log('refreshBtn just clicked. Now on way to displayTable')
		saveTableBtn.setAttribute('class','colorBtn');
		saveTableBtn2.setAttribute('class','colorBtn');//was colorBtn
		flipMenu.setAttribute('class','colorBtn');
		$("#flip").css({"background-color": "yellow", "border-color": "red"});
		
		
			refreshed = 1;//so added field name headings are not generated twice
			editCurrentTable = 0; //Nov 22 so added field name headings are not generated twice
			STrecordTd.removeChild(editTD);
			STrecordTd.removeChild(refreshBtn);
			//STRows or STHeadRow
	// 	while (STheadRow.firstChild) {
    // STheadRow.removeChild(STheadRow.firstChild);
	// 	}//end while
		//changed firstChild to secondChild
		while (STrows.firstChild) {
    STrows.removeChild(STrows.firstChild);
	
	}//end while
	changeDB = true;//put in here because field headers got messed up after an edit Date:Feb13
// 	//code to regenerate field headings prior to rebuilding Table
// 	STheadName.textContent = fieldNamesArray[0];//listName header first column
// 	STfirstDataNameTd.textContent = fieldNamesArray[2];
// 	STsecondDataNameTd.textContent = fieldNamesArray[3];
// 	//create the added fields required
// 	for (let k = 4; k < numberOfFields; k++) {
// 	const STnextFieldHeading = document.createElement('td');
// 	STnextFieldHeading.textContent = fieldNamesArray[k];	
// 	STheadRow.appendChild(STnextFieldHeading);
		
// }//end for loop

// 	//end code to regenerate Field Headings

//to maintain header after refresh
STtableHeader.textContent = dbTableName.value;
STtableHeader.setAttribute('class','attentionBtn');
STrows.appendChild(STtableHeader);
	STrows.appendChild(STheadRow);
	
	console.log('At refreshBtn.onclick..a data cell is being edited!: refreshed = ' + refreshed + ' renewed = ' + renewed +'. displayedTable variable = ' + displayedTable + '. The table is cleared, and table header and field header row reconstructed in the refreshBtn.onclick code, and ADDED to STRows..now going to displayTable with refreshed variable set to 1 by refreshBtn.onclick so that field headings will not duplicate or repeat.' );	
	
	//would clearing editTDInput.value help fix the disappearing postLinkInfo issue
	//editTDInput.value = "";
	
	//before display table and refreshbtn tapped tableArray is in newTable mode
	//alertx("Back from displayTable — TDCell edit completed and refreshBtn just tapped: tableArray = " + tableArray + ". loadTableIndex = " + loadTableIndex + ". savedTablesArray should be newTable mode! savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + ". newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  newTableFieldsArray[tableID] = " + newTableFieldsArray[tableID]);
	
	console.log("Back from displayTable — TDCell edit completed and refreshBtn just tapped: tableArray = " + tableArray + ". loadTableIndex = " + loadTableIndex + ". savedTablesArray should be newTable mode! savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + ". newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  newTableFieldsArray[tableID] = " + newTableFieldsArray[tableID]);
	
//after refresh btn click keep table at record just edited instead of scrolling back to top!	
recordId = getRecordId(i);	//REMOVE IF MESSES UP DATE Dec11 2023 think it works!
	
			displayTable();//this line stays!!
			
document.querySelector('#STforRows').children[recordId-2].scrollIntoView(true);	//REMOVE IF MESSES UP DATE Dec11 2023

//IF YOU MAKE RECORDID -2 the record viewed will be more centered to the screen??
			
if(loadFromTableOptions) {
//is this line correct? Yes it is
//ADDED THIS LINE MAR5 to fix issue of losing ADRESS FIELD IF DOING A TABLEEDIT! Don't understand why it is needed here??? Because?  newTableFieldsArray variable is set to last new table preceding this one and has to be reset for current new table?!!!?,

newTableFieldsArray = newTableSpecificVariables[tableID][1];
	savedTablesArray[loadTableIndex]=tableArray.slice();
	
	//alertx("Back from displayTable — TDCell edit completed and refreshBtn just tapped: tableArray = " + tableArray + ". loadTableIndex = " + loadTableIndex + ". savedTablesArray should be newTable mode! savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + ". newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1]);
	
	console.log("Back from displayTable — TDCell edit completed and refreshBtn just tapped: tableArray = " + tableArray + ". loadTableIndex = " + loadTableIndex + ". savedTablesArray should be newTable mode! savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + ". newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1]);
	
//	works but did not work after immediate edit after adding of new field!!!
}//end if loadTableFromOptions
			
			//!!!!!!!!!!!!MAYBE NEED refreshed = 0; statement here to fix field header problem?
			//Dec 28 so far without a rerun everything works?!
			refreshed = 0; //ADDED JAN 2 2021
			//!!!!!!!!!!!!!
			}//end refreshBtn.onclick
		}//end else if !toggleTdInputBtn
		}//end editTDInputBtn.onclick
		
	});//end addEventListener
	
	
// 	//CHECK IF ROWS SUMMED date Nov13
// //alertx("checking if rowSummed!")
// 	//alert("checking for rowSummed");
// if(tableArray[i][c].includes(sumRowTxt)	) {
// 				rowSummed = true;
// 				}//end if(tableArray[i][c].includes(sumRowTxt)	) {
					
//TypeError: undefined is not an object (evaluating 'tableArray[i][c].includes') GOT THIS ERROR WHEN THIS CODE WAS AT LINE 9815
//PROBABLY NEED TO STORE rowSummed variable in tableVariables array?
		// alert("does this code ever run? rowSummed = " + rowSummed);			
		// 		} else {
		// 			rowSummed = false;
		// 			alert("in else part does this code ever run? rowSummed = " + rowSummed);
		// 			}//end if else
	//CHECK IF ROWS SUMMED
			
		}//end for c =
			
		}//end for i = to show all records
		
		

	
		
//alertx("In displayTable, recreating record rows: fromSearch is true..before removing duplicates..searchedHitsTableArray = " + searchedHitsTableArray);	

//REMOVE DUPLICATES IN SEARCHEDHITSTABLEARRAY TO ACCOUNT FOR QUERY APPEARING MORE THAN ONCE IN A RECORD..did not use fromSearcheRecords as condition because it is now false..see line v8840

if (searchedHitsTableArray.length > 0) {

 searchedHitsTableArray = [...new Set(searchedHitsTableArray)];
 //alertx("after removing duplicates searchedHitsTableArray = " + searchedHitsTableArray);
}//end if (fromSearchRecord) {
	
		//should this code be near tableScreen section so you can return to home screen direct from displayTable??
		//const homeScreenBtn = document.querySelector('#homeScreenBtn');
		homeScreenBtn.onclick = function () {
		
backupBtn1.style.display = "none";
backupBtn2.style.display = "none";//maybe should just be tdEdit?
		
		reNamedDBFileName = false;
		totalInfoP.style.display = "none";
		sumAcrossInfoP.style.display = "none";
		fieldSUM = 0;//clear to 0 in case TOTAL function has been used
		rowSummed = false;
		originalOrder = true;//reset this flag so that a warning does not appear in an unrelated database if you sorted a previous table and did not go to SAVE afterwards while in that table but instead went to a new db then clear this flag!
		 showRULEonce = false;//flag for alert notice to be displayed once on first initializing sumAcross
emailBtn.setAttribute('class','tdEdit');//if cancel CONTACTS or ignore flashing CONTACTS AND GO TO HOME SCRN CONTACTS BTN WILL STAY FLASHING!

//alertx("homeScreenBtn.onclick: fromSearchRecord = " + fromSearchRecord + " hits.length = " + hits.length);
console.log("homeScreenBtn.onclick: fromSearchRecord = " + fromSearchRecord + " hits.length = " + hits.length);
//alertx("STsecondDataNameTdListener = " + STsecondDataNameTdListener + "  fieldNamesArray[3] = " + fieldNamesArray[3] + "  eMailActive = " + eMailActive);

if(STsecondDataNameTdListener) {
STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
	//STsecondDataNameTd.removeEventListener;
	STsecondDataNameTdListener = false;
	eMailActive = false;
	STsecondDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STsecondDataNameTdListener)

if(STfirstDataNameTdListener) {
STfirstDataNameTd.removeEventListener('dblclick',STfirstDataNameTd.fn, false);
	//STfirstDataNameTd.removeEventListener;
	STfirstDataNameTdListener = false;
	telephoneActive = false;
	STfirstDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STfirstDataNameTdListener)
//DO I NEED THIS NOW THAT CODE IS IN DISPLAYTABLEBTN???
// if(telephoneActive || eMailActive) {
// STnextFieldHeading.removeEventListener('dblclick', STnextFieldHeading.fn);
// //for (let k = 4; k < numberOfFields; k++) {
// STnextFieldHeading.setAttribute('class','stHeadRow');//this line does not work!


//NOT SURE WHERE TO PUT THIS - RETURN TO GETFILENAMES AFTER FINISHED CREATING NEW DB IN ORDER TO INITIATE REMOVAL OF .creatingDB tag
if(creationDONE && !ranOnce) {
//code to remove .creatingDB which maybe should be changed to -creatingDB in case js thinks its a method!	
//code to rename db with tag removed
//dataBaseName = databases[i].name;
dataBaseName = dbTableName.value;//helps insure dataBaseName is not wiped out in creation new db process
alert("Finishing up: Now removing '.creatingDB' extension from ' " + dataBaseName + "' and restoring newly created database into DougieBase.");
//renameDataBaseFileName(dataBaseName);
dbFileName.textContent = dataBaseName.substring(0, dataBaseName.length-11);//trim off .creatingDB
renamedFileName = dbFileName.textContent; 
reNamedDBFileName = true;
dbTitle.textContent = renamedFileName;
dbTableName.value = renamedFileName//dbTableName is stored in variable1 and represents the variable in view settings that reflects the table name 
saveVariables();
backupDataBase(dataBaseName);//go to backup with original name!! And new filename is now in variable 	 renamedFileName = dbFileName.textContent


//NOW NEED TO RETURN TO FILE NAMES WITH RESTORE BTN BLINKING
//code to rename db with tag removed

//creationDONE = false;
ranOnce = true;//to prevent rerun
}//end if(creationDONE)	


if(telephoneActive || eMailActive) {
resetActiveFieldHeaders();
//}//end if telephone active
// alert("did it work? STOP")
// return
// telephoneActive = false;//so now code in displayTableBtn won't run good!
// eMailActive = false;
// // 	//to reset attribute stHeadRow if telephone activated in dynamic fields return to displayTable with resetFields true BUT NOW CAN'T REINSTATE DBLCLICK ADDEVENTLISTENER!
// //resetFields = true;
// // 	//tableConstructed = false;
// //displayTable();//NEED THIS TO RESET FIELD ATTRIBUTE TO NON BLINK so maybe just put setAttribute to stHeadRow in the resetField code? AND REMOVE displayTable because this will repeat records!
// // }//end if(telephoneActive || eMailActive) {


// //TO RESET BLINK IF EMAIL TELEPHONE ACTIVE
// 	clearHeadRow();
// console.log('Removed dynamic fields! ' + STheadRow);

// //TRY THIS,! Date: Feb17 2022
// //addFieldHeaders();
// //TRY THIS,! Date: Feb17 2022


// //
// STheadRow.appendChild(STheadName);
// STheadRow.appendChild(secondFieldName);
// STheadRow.appendChild(STfirstDataNameTd);
// STheadRow.appendChild(STsecondDataNameTd);
// //field labels of static fields now restored!
// for (let k = 4; k < numberOfFields; k++) {
// 	const STnextFieldHeading = document.createElement('td');
// 	STnextFieldHeading.textContent = fieldNamesArray[k];	
// 	//to reset field header if blinking
// 	STnextFieldHeading.setAttribute('class','stHeadRow');//resets cancels blinking if previously applied by an addEventListener
	
// 	STheadRow.appendChild(STnextFieldHeading);
	
// 	//reapply eventListeners
// if(fieldNamesArray[k].includes("TOTAL")|| fieldNamesArray[k].includes("AVERAGE")) {
// 	//alertx("adding event listener"); 
// 		STnextFieldHeading.addEventListener('dblclick', function () {
// 		//check if table initialized
// 		if(blockEdit) {
// 		alert("Before tapping this Field Title, Tap Return to Home Screen first to initialize the table layout you just edited or created!");
// 		//blockEdit = false;
// 		return false;
// 	}
	
// 			totalActive = true;
// 			totalFieldNameIndex = k;
// 			//summing();
// 			if(fieldNamesArray[k].includes("TOTAL")) {
// 			summing();
// 		} else if (fieldNamesArray[k].includes("AVERAGE")) {
// 			averaging();
// 		}//end if else if if(fieldNamesArray[k].includes("TOTAL")) {
// 			//STnextFieldHeading.textContent = " TOTAL = " + fieldSUM;
			
// 	if (fieldNamesArray[k].includes("COST")) {
// 		STnextFieldHeading.textContent = fieldNamesArray[k]+ " $" + fieldSUM;
// 		// } else if (fieldNamesArray[k].includes("AGE")) {
// 		// 	STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " yrs";
// 		} else {	
			
// 			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM;
// 			}//end if (fieldNamesArray[k].includes("COST")) {
			
// if (fieldNamesArray[k].includes("UNITS")) {
// 		//alertx("fieldNamesArray[k] = " + fieldNamesArray[k] + " so why am I adding yrs? STnextFieldHeading.textContent = " + STnextFieldHeading.textContent );
		
// 			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " units";
// 			}//end if (fieldNamesArray[k].includes("AGE")) {
			
// if (fieldNamesArray[k] === "AGE" + " (TOTAL)" || fieldNamesArray[k] === "AGE" + " (AVERAGE)") {
// 		//alertx("fieldNamesArray[k] = " + fieldNamesArray[k] + " so why am I adding yrs? STnextFieldHeading.textContent = " + STnextFieldHeading.textContent );
		
// 			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " yrs";
// 			}//end if (fieldNamesArray[k].includes("AGE")) {
				
// 			fieldSUM = 0;
// 			totalFieldNameIndex = 0;	STnextFieldHeading.removeEventListener;
			
// 			//fieldNamesArray[totalFieldNameIndex].textContent = " TOTAL = " + fieldSUM;
// 			});//end addEventListener
		
// 		}//end if (STnextFieldHeading.textContent === "TOTAL")
		
// //ADDING CODE FOR TELEPHONE AND EMAIL IN //ADDING CODE FOR TELEPHONE AND EMAIL IN DYNAMIC HEADERS	vvv must includ in resetFields section!
// if(fieldNamesArray[k].includes("TELEPHONE") || fieldNamesArray[k].includes("EMAIL")){
// alert("at fieldNamesArray contains TELEPHONE..adding eventListener");
// //STfirstDataNameTd.addEventListener('dblclick', STfirstDataNameTd.fn=function fn() {
// 	STnextFieldHeading.addEventListener('dblclick', STnextFieldHeading.fn=function fn() {
// 		//check table is initialized
// 		if(blockEdit) {
// 		alert("Before tapping this Field Title, Tap Return to Home Screen first to initialize the table layout you just edited or created!");
// 		//blockEdit = false;
// 		return false;
// 	}
			
// STnextFieldHeading.setAttribute('class','borderBlink');
// 	if(fieldNamesArray[k].includes("TELEPHONE")) {
// 			telephoneActive = true;
// 			telephoneAlertFlag2 = false;
// 			eMailAlertFlag2 = true;
// 		} else if (fieldNamesArray[k].includes("EMAIL")) {
// 			eMailActive = true;
// 			eMailAlertFlag2 = false;
// 			telephoneAlertFlag2 = true;
// 		}//end if else if	
		
// //STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
// //k is 4 or > so this applies only to dynamic fields
// if(!eMailAlertFlag2) {
// 	alert("eMail address now active! Double click on email address to SEND EMAIL!");
// eMailAlertFlag2 = true;
// 	}//end if(!eMailAlertFlag) 
	
// if(!telephoneAlertFlag2) {
// 	alert("Telephone number is now active! Double click on telephone number to PHONE!");
// telephoneAlertFlag2 = true;
// 	}//end if(!eMailAlertFlag) 

// STnextFieldHeading.removeEventListener('dblclick', STnextFieldHeading.fn, false);

// //STnextFieldHeading.setAttribute('class','stHeadRow');
// //STnextFieldHeading.setAttribute('class','borderBlink')

// });//end STnextFieldHeading.addEventListener

// }//end if(fieldNamesArray[k].includes("TELEPHONE") ||



// //Date:Oct25 this works so now need more debugging!!
// //ADDING CODE FOR TELEPHONE AND EMAIL IN DYNAMIC HEADERS	^^^
// 	}//end for loop
	
}//end if(telephoneActive || eMailActive) {
//TO RESET BLINK IF EMAIL TELEPHONE ACTIVE	
	

//reset fromSearchRecord to false and hits.length to 0 to fix search bug if using a td referenced search followed by a first column tableTitle search Date: Jun2 2022
fromSearchRecord = false;
hits.length = 0;

		//alertx("searchedHitsTableArray = " + searchedHitsTableArray);
	//alertx("homeScreeBtn.onclick..loadFromTableOptions = " + loadFromTableOptions +  ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex]);
	
if(hitsTable) {
emailBtn.textContent = "CONTACTS";
hitsTable = false;
makeHitsTable = false;
resetFields = true;//field headers got messed up after making a new table from a new table
}//end if hitsTable


//to cover case where user chooses to delete a new table then changes his mind and hitting the return to home screen btn
if(deleteFromTableOptions) {	tableScreen.removeChild(renameNewTableBtn);
	}//end if(deleteFromTableOptions) 
		homeScreenBtn.setAttribute('class','tdEdit');
	
homeScreenBtn2.setAttribute('class','tdEdit');
blockEdit = false;//so td edit will work again
		
		//	alert("changeDB = "+ changeDB + " mainDBedit =  " + mainDBedit);
			
			if(changeDB && !mainDBedit) {
			removeHeadRow();//VERY IMPORTANT LINE..MAKES IT WORK!!!Date: Feb12 2022..new function This line placed here Feb13 to prevent field headers from disappearing if displayTableBtn tapped twice in a row
		//	proved that this line is responsible for the STHeadRow disappearing when loading a newTable after a main db edit, but the header that appears has 5 dynamic fields of the previous main db!
		}//end if changeDB
			//clearTableRows();//prevent added dynamic fields from persisting if going to a new table after main db
homeScreenBtn.textContent = "RETURN to Home Screen";
homeScreenBtn2.textContent = "RETURN to Home Screen";
flipMenu.textContent = "Tap - Click to show / hide TABLE MENU";

	//if makeContactsTable AND new table not saved we need to delete this new table from the listing	
	//after resetFromContacts makeContactsTable will be false so next segment of code will not run!
	if(makeContactsTable) {
		homeScreenBtn.setAttribute('class','normalBtn');	
		homeScreenBtn2.setAttribute('class','normalBtn');	
	}//end if makeContactsTable
	
		if(makeContactsTable || loadFromTableOptions) {
				//NCJan10..If messed up go back to fallBackJan10
				//clearHeadRow();	
		//trimHeadRow();
	//	clearTableRows();
		//removeDynamicFields();
		changeDB = true;//IMPORTANT KEEP setupNewTable makes this false so it needs to be made true here for field headers to be set up properly after showing a newTable but the 2nd homebtn #2 did not need it so not sure????
				
		resetFromContacts();
			}//end if makeContactsTable
	
			fromViewSort = false;//turn off sort flag
			console.log('homeScreenBtn clicked');
			
//return menu bar in table back to original if post search
//flipMenu.textContent = "Click - Tap to show / hide TABLE MENU";		
	//keeping track of save Btn Date: Feb 26 2021
	saveTableBtn.setAttribute('class','normalBtn');	
	saveTableBtn2.setAttribute('class','normalBtn');	
	flipMenu.setAttribute('class','normalBtn');
	$("#flip").css({"background-color": "lightgrey", "border-color": "black"});
			showTable.setAttribute('class', 'hidden');
		// LEFT OFF HERE DEC 24 2020 have to figure out refreshed = 0 and refreshed = 1 so field headers are generated or not	deleteWindow.setAttribute('class','hidden');
		}//end homeScreenBtn.onclick
		
		//const homeScreenBtn2 = document.querySelector('#homeScreenBtn2');
		homeScreenBtn2.onclick = function () {
		
backupBtn1.style.display = "none";
backupBtn2.style.display = "none";//maybe should just be tdEdit?

		reNamedDBFileName = false;
		totalInfoP.style.display = "none";
		sumAcrossInfoP.style.display = "none";
		fieldSUM = 0;//clear to 0 in case TOTAL function has been used
		rowSummed = false;
		originalOrder = true;//reset this flag so that a warning does not appear in an unrelated database if you sorted a previous table and did not go to SAVE afterwards while in that table but instead went to a new db then clear this flag!
		showRULEonce = false;//flag for alert notice to be displayed once on first initializing sumAcross
		
emailBtn.setAttribute('class','tdEdit');//if cancel CONTACTS or ignore flashing CONTACTS AND GO TO HOME SCRN CONTACTS BTN WILL STAY FLASHING!
//alertx("STsecondDataNameTdListener = " + STsecondDataNameTdListener);
if(STsecondDataNameTdListener) {
STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
	//STsecondDataNameTd.removeEventListener;
	STsecondDataNameTdListener = false;
	eMailActive = false;
	STsecondDataNameTd.setAttribute('class','stHeadRow');
}//end if(STsecondDataNameTdListener)

if(STfirstDataNameTdListener) {
STfirstDataNameTd.removeEventListener('dblclick',STfirstDataNameTd.fn, false);
	//STfirstDataNameTd.removeEventListener;
	STfirstDataNameTdListener = false;
	telephoneActive = false;
	STfirstDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STfirstDataNameTdListener)

//NOT SURE WHERE TO PUT THIS - RETURN TO GETFILENAMES AFTER FINISHED CREATING NEW DB IN ORDER TO INITIATE REMOVAL OF .creatingDB tag

if(creationDONE && !ranOnce) {
//code to remove .creatingDB which maybe should be changed to -creatingDB in case js thinks its a method!	
//code to rename db with tag removed
//dataBaseName = databases[i].name;
dataBaseName = dbTableName.value;//helps insure dataBaseName is not wiped out in creation new db process
alert("Finishing up: Now removing '.creatingDB' extension from '" + dataBaseName + "' and restoring newly created database into DougieBase.");
//renameDataBaseFileName(dataBaseName);
dbFileName.textContent = dataBaseName.substring(0, dataBaseName.length-11);//trim off .creatingDB
renamedFileName = dbFileName.textContent; 
reNamedDBFileName = true;
dbTitle.textContent = renamedFileName;
dbTableName.value = renamedFileName//dbTableName is stored in variable1 and represents the variable in view settings that reflects the table name 
saveVariables();
backupDataBase(dataBaseName);//go to backup with original name!! And new filename is now in variable 	 renamedFileName = dbFileName.textContent


//NOW NEED TO RETURN TO FILE NAMES WITH RESTORE BTN BLINKING
//code to rename db with tag removed

//creationDONE = false;
ranOnce = true;//to prevent rerun
}//end if(creationDONE)	


// if(creationDONE) {
// alert("Now going back to filenames list to remove .createNewDB tag!");
// 	getFileNames();
// }//end if(creationDONE)


//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED
if(telephoneActive || eMailActive) {
resetActiveFieldHeaders();
}//end if(telephoneActive || eMailActive) {

//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED


//reset fromSearchRecord to false and hits.length to 0 to fix search bug if using a td referenced search followed by a first column tableTitle search Date: Jun2 2022
fromSearchRecord = false;
hits.length = 0;

		
if(hitsTable) {
emailBtn.textContent = "CONTACTS";
hitsTable = false;
makeHitsTable = false;
}//end if hitsTable

//to cover case where user chooses to delete a new table then changes his mind and hitting the return to home screen btn
if(deleteFromTableOptions) {	tableScreen.removeChild(renameNewTableBtn);
	}//end if(deleteFromTableOptions) 
		
		homeScreenBtn.setAttribute('class','tdEdit');
homeScreenBtn2.setAttribute('class','tdEdit');
blockEdit = false;//so td edit will work again

			if(changeDB && !mainDBedit) {
			removeHeadRow();//VERY IMPORTANT LINE..MAKES IT WORK!!!Date: Feb12 2022..new function This line placed here Feb13 to prevent field headers from disappearing if displayTableBtn tapped twice in a row
			}//end if changeDB
			
homeScreenBtn.textContent = "RETURN to Home Screen";
				homeScreenBtn2.textContent = "RETURN to Home Screen";
				flipMenu.textContent = "Tap - Click to show / hide TABLE MENU";
				
	if(makeContactsTable) {
		homeScreenBtn.setAttribute('class','normalBtn');	
		homeScreenBtn2.setAttribute('class','normalBtn');	
	}//end if makeContactsTable
	
	if(makeContactsTable || loadFromTableOptions) {
				//NCJan10..If messed up go back to fallBackJan10
					//clearHeadRow();	
		//trimHeadRow();
	//	clearTableRows();
		//removeDynamicFields();
		changeDB = true;//IMPORTANT KEEP setupNewTable makes this false so it needs to be made true here for field headers to be set up properly after showing a newTable but the 2nd homebtn #2 did not need it so not sure????
				
	resetFromContacts();
			}//end if makeContactsTable
			
			fromViewSort = false;//turn off sort flag
			console.log('homeScreenBtn2 clicked');
	//keeping track of save Btn Date: Feb 26 2021
	saveTableBtn.setAttribute('class','normalBtn');	
	saveTableBtn2.setAttribute('class','normalBtn');	
	flipMenu.setAttribute('class','normalBtn');//does not respond to js only jQuery
	$("#flip").css({"background-color": "lightgrey", "border-color": "black"});
	
			showTable.setAttribute('class', 'hidden');
		// LEFT OFF HERE DEC 24 2020 have to figure out refreshed = 0 and refreshed = 1 so field headers are generated or not	deleteWindow.setAttribute('class','hidden');
	}//end homeScreenBtn2.onclick
	
//moreTablesBtn
moreTablesBtn.onclick = function () {
clickedMoreTables = true;
//alertx("moreTablesBtn tapped .. STsecondDataNameTdListener = " + STsecondDataNameTdListener);

		totalInfoP.style.display = "none";
		sumAcrossInfoP.style.display = "none";
		fieldSUM = 0;//clear to 0 in case TOTAL function has been used
		rowSummed = false;
		originalOrder = true;//reset this flag so that a warning does not appear in an unrelated database if you sorted a previous table and did not go to SAVE afterwards while in that table but instead went to a new db then clear this flag!
		showRULEonce = false;//flag for alert notice to be displayed once on first initializing sumAcross
		
emailBtn.setAttribute('class','tdEdit');//if cancel CONTACTS or ignore flashing CONTACTS AND GO TO HOME SCRN CONTACTS BTN WILL STAY FLASHING!

if(STsecondDataNameTdListener) {
STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
	//STsecondDataNameTd.removeEventListener;
	STsecondDataNameTdListener = false;
	eMailActive = false;
	STsecondDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STsecondDataNameTdListener)

if(STfirstDataNameTdListener) {
STfirstDataNameTd.removeEventListener('dblclick',STfirstDataNameTd.fn, false);
	//STfirstDataNameTd.removeEventListener;
	STfirstDataNameTdListener = false;
	telephoneActive = false;
	
//alertx("moreTablesBtn tapped: STfirstDataNameTdListener = " + STfirstDataNameTdListener);
	STfirstDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STfirstDataNameTdListener)

//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED
if(telephoneActive || eMailActive) {
resetActiveFieldHeaders();
}//end if(telephoneActive || eMailActive) {

//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED


fromSearchRecord = false;
hits.length = 0;

if(hitsTable) {
emailBtn.textContent = "CONTACTS";
hitsTable = false;
makeHitsTable = false;
resetFields = true;//field headers got messed up after making a new table from a new table
}//end if hitsTable
if(deleteFromTableOptions) {	tableScreen.removeChild(renameNewTableBtn);
	}//end if(deleteFromTableOptions) 
		homeScreenBtn.setAttribute('class','tdEdit');
	
homeScreenBtn2.setAttribute('class','tdEdit');
blockEdit = false;//so td edit will work again
		
	
			
			if(changeDB && !mainDBedit) {
			removeHeadRow();//VERY IMPORTANT LINE..MAKES IT WORK!!!Date: Feb12 2022..new function This line placed here Feb13 to prevent field headers from disappearing if displayTableBtn tapped twice in a row
		//	proved that this line is responsible for the STHeadRow disappearing when loading a newTable after a main db edit, but the header that appears has 5 dynamic fields of the previous main db!
		}//end if changeDB
homeScreenBtn.textContent = "RETURN to Home Screen";
homeScreenBtn2.textContent = "RETURN to Home Screen";
flipMenu.textContent = "Tap - Click to show / hide TABLE MENU";		
	if(makeContactsTable) {
		homeScreenBtn.setAttribute('class','normalBtn');	
		homeScreenBtn2.setAttribute('class','normalBtn');	
	}//end if makeContactsTable
	
		if(makeContactsTable || loadFromTableOptions) {
				//NCJan10..If messed up go back to fallBackJan10
				//clearHeadRow();	
		//trimHeadRow();
	//	clearTableRows();
		//removeDynamicFields();
		changeDB = true;//IMPORTANT KEEP setupNewTable makes this false so it needs to be made true here for field headers to be set up properly after showing a newTable but the 2nd homebtn #2 did not need it so not sure????
				
		resetFromContacts();
			}//end if makeContactsTable
	
			fromViewSort = false;//turn off sort flag
			console.log('homeScreenBtn clicked');
			
	saveTableBtn.setAttribute('class','normalBtn');	
	saveTableBtn2.setAttribute('class','normalBtn');	
	flipMenu.setAttribute('class','normalBtn');
	$("#flip").css({"background-color": "lightgrey", "border-color": "black"});
	
			showTable.setAttribute('class', 'hidden');
			//tableScreen.setAttribute('class','showing');
			tableScreen.setAttribute('class','showing');
			
			tableScreenOptions();
		
		}//end moreTablesBtn.onclick
//moreTablesBtn
	
		
		// //return to search table window
		// 	const toSearchScreenBtn = document.querySelector('#toSearchScr');
		// toSearchScreenBtn.onclick = function () {
		// 	console.log('toSearchScreenBtn clicked');
			
		// 	showTable.setAttribute('class', 'hidden');
		// 	searchWindow.setAttribute('class','showing');
		// }//end toSearchScreenBtn.onclick
	//toScreenBtn clicked then program stops running no error message is elicited. Window taps are not responsive why???
//Any relation to addEventListener??	maybe should replace addEventListener with .ondbleclick??This happens if going to search screen directly from table display. If you return to Home Screen first and then go to search screen all is well!Seems to happen on first run of program after a re-run post DONE button, when going from notes to search screen DIRECT. After program has been running it seems I can go direct to search screen from notes without issue..at least when found record list is present. When this issue happens is it possible the first time a found record list item has not been created??
		//saveTableBtn declared as global variable at start of createTable code
	//maybe comment this one out?
	//saveTableBtn.setAttribute('class','colorBtn');
		saveTableBtn.textContent = 'SAVE';
		saveTableBtn2.textContent = 'SAVE';
		
		//flipMenu.setAttribute('class','colorBtn');//does not work! ? Because its a jQuery element??
		//$("#flip").css({"background-color": "yellow", "border": "red"});
	//$$LEFT OFF HERE,!!!	
	saveTableBtn.onclick = function () { 
	fieldSUM = 0;//clear to 0 in case TOTAL function has been used
	eMailActive = false;//flag set here to prevent an email if just editing a td
	telephoneActive = false;
	//tableIndex = 7;testing fixing screw ups
	resetFields = true;//if you hit SAVE twice fields can get messed up
	homeScreenBtn.disabled = false;//to help force Save..now reset after flashing SAVE
			 homeScreenBtn2.disabled = false;
			 moreTablesBtn.disabled = false;
newTableFieldsBtn.disabled = false;//to prevent an inadvertant tap of Field Labels btn at this stage creating crashing..reset
	
	 if(renameNewTableFlag) {
displayTableBtn.setAttribute('class','tdEdit');
saveTableBtn.setAttribute('class','tdEdit');
saveTableBtn2.setAttribute('class','tdEdit');

renameNewTableFlag = false;

}//end if(renameNewTableFlag)
	
	//alertx("saveTableBtn.onclick (table screen) .. loadFromTableOptions = " + loadFromTableOptions +  ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex]);
	
	console.log("saveTableBtn.onclick (table screen) .. loadFromTableOptions = " + loadFromTableOptions +  ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex]);
		console.log("NOTE savedTableArray NOT created until saveBtn.onclick if makeContactsTable = true! So at point of saveBtn.onclick prior to first save savedTablesArray is empty!Just tapped saveTableBtn.onclick… savedTablesArray[0] = " + savedTablesArray[0]);
//NOTE savedTableArray NOT created until saveBtn.onclick if makeContactsTable = true! So at point of saveBtn.onclick prior to first save savedTablesArray is empty!
// ERROR HERE		
// Just tapped saveTableBtn.onclick… savedTablesArray[0] = Doug Dyer,
// Contact Name , Feb 06 2022 00:20, ,username@shaw.ca,(250) 658-5645,addyer@telus.net BETWEEN EDIT (REFRESH BTN AND BACK TO SAVE SOMETHING HAPPENS??)also check originalNumberRecords set to that of new table (contacts table) …4 see line 12119 4 is main db should be 3 line 12116 tableArray = Doug Dyer,
// Contact Name , Feb 06 2022 00:20, ,username@shaw.ca,(250) 658-5645,addyer@telus.net fieldNamesArray = CONTACT NAME,DATE,TELEPHONE,EMAILtableIndex = 0 tableTitle.length = 4 should be 3?
//ERROR HERE!!!!	savedTablesArray is wrong before going to saveVariables!!	
		console.log('Save Table btn tapped: makeContactsTable = ' + makeContactsTable + ' loadFromTableOptions = ' + loadFromTableOptions);
		//alert(" I removed parameter! saveTableBtn.onclick..savedTablesArray[0] = " + savedTablesArray[0]);
		//alert("newTableName =  " + newTableName);
		//Date:Jan25Remove if messes up
		if(makeContactsTable || loadFromTableOptions) {
		flipMenu.textContent = " ✅ New Table Name: " + newTableNames[tableIndex] + ". " + newTableName;
		}//end if makeContactsTable ||vloadFromTableOptions
		//flipMenu.textContent = " ✅ New Table Name: " + newTableName;//have to repeat this for second run to get it to work.not sure why?????Date: Jan2
		let abortSave = false;
		//before dtavObject.tableArray is assingned new values of an edited table make check that saveTableBtn is not being pushed from a contacts table and if it is go to saveNewTable function first to restore original tableArray values and copyTableArray values, and setup the savedTables array values etc.
		
		//return menu bar in table back to original if post search
		//flipMenu.textContent = "Click - Tap to show / hide TABLE MENU";
		
		if(!makeContactsTable && !loadFromTableOptions) {
		flipMenu.textContent = "Click - Tap to show / hide TABLE MENU";
		}//end if !makeContactsTable
		
		
	
	
	//NCJan10..If messed up go back to fallBackJan10
	// prompt to give choice for saving a contacts table or return to table
 //confirm choice window
 if(makeContactsTable || loadFromTableOptions) {
	 //NCJan10..If messed up go back to fallBackJan10
	 //when makeContactsTable and loadFromTableOptions are true tableArray is in newTable mode so have to restore to main db mode prior to any save!ResetFromContacts does this AND also sets savedOriginal to false
		 if (window.confirm("SAVE Contacts - New Table ? : \n" + "  CANCEL will Return to Table")) {
			 if(!makeHitsTable && loadFromTableOptions) {
				 makeContactsTable = false;
				 //HAVE TO SAVE THE ORIGINAL IF DOING A SAVE DIRECT FROM LOADFROMTABLEOPTIONS!!!?//you do want to save a newTable if an edit has been made!,

	//return homeBtn to normal
	homeScreenBtn.disabled = false;
homeScreenBtn2.disabled = false;
	homeScreenBtn.textContent = "RETURN to Home Screen";
	homeScreenBtn2.textContent = "RETURN to Home Screen";
	
			resetFromContacts();
	}//end if loadFromTableOptions
			 if(makeContactsTable) {loadFromTableOptions = false;
			 saveNewTable();
	}//end if makeContactsTable saveNewTable takes you to resetFromContacts it also creates savedTablesArray[tableIndex]? If abort save should tableIndex be brought back to tableIndex-1 ?
			
			
			homeScreenBtn.textContent = "Clear CONTACTS Table";
			 homeScreenBtn2.textContent = "Clear CONTACTS Table";
//MUST DISABLE SEARCH SORT EDIT AFTER THE SAVE BECAUSE tableArray has beebpn reset to db values prior to saveVariables…otherwise db values are erased by contacts!! Date: Jan30 the search sort with tableArray set to db values will mess up a sort of contacts or new table.	
	toSortScrBtn.style.backgroundColor = "lightgrey";
	toSortScrBtn.disabled = true;
	toEditTableScrBtn.style.backgroundColor = "lightgrey";
	toEditTableScrBtn.disabled = true;
	toSearchScreenBtn.style.backgroundColor = "lightgrey";
	toSearchScreenBtn.disabled = true;
//homeScreenBtn was disabled in eMailBtn.onclick in choice prompt after getNewTableName	
homeScreenBtn.disabled = false;
homeScreenBtn2.disabled = false;
	homeScreenBtn.setAttribute('class','borderBlink');
	homeScreenBtn2.setAttribute('class','borderBlink');
	
	//alert("In SAVETableBtn.onclick —manualContactsEntered = " + manualContactsEntered + " plusContactsEntered = " + plusContactsEntered);
	
	if(plusContactsEntered) {
		plusContactsEntered = false;
		homeScreenBtn.setAttribute('class','tdEdit');
	homeScreenBtn2.setAttribute('class','tdEdit');
	}//end if(plusContactsEntered)..true in setUpNewTable..make false here..in aid of not having user return to homescreen (stop flashing btn) before viewing his contacts table Date Mar21 2023
	
	blockEdit = true;//flag to prevent savedTablesArray getting messed up prevent dblClick edit of td cell if just finished editing layout of table via editBtn.onclick..because otherwise tableArray will no longer be in newTable mode and savedTablesArray will get messed up DOES NOT SEEM TO WORK AFTER A SAVE POST DELETE FIELD.
	
/*	} else {
	toSortScrBtn.style.backgroundColor = "rgb(240, 248, 255)";
	toSortScrBtn.disabled = false;
	toEditTableScrBtn.style.backgroundColor = "rgb(240, 248, 255)";;
	toEditTableScrBtn.disabled = false;
	toSearchScreenBtn.style.backgroundColor = "rgb(240, 248, 255)";
	toSearchScreenBtn.disabled = false;
*/	
		 
			
			 
			// saveNewTable();
			// return//.?temporary to prevent saving variables until code written for it Jan12022
			} else {
				saveTableBtn.textContent = "SAVE";
			// saveTableBtn2.disabled = true;
			saveTableBtn2.textContent = "SAVE";
			saveTableBtn.setAttribute('class', 'normalBtn');
			saveTableBtn2.setAttribute('class', 'normalBtn');
			
//homeScreenBtn was disabled in eMailBtn.onclick in choice prompt after getNewTableName	
homeScreenBtn.disabled = false;
homeScreenBtn2.disabled = false;
homeScreenBtn.setAttribute('class','borderBlink');
homeScreenBtn2.setAttribute('class','borderBlink');

if(loadFromTableOptions || makeContactsTable) {
	emailBtn.style.display = "none";
	newTableFieldsBtn.style.display = "none";
}//end if loadFromTableOptions || makeContactsTable

//saveNewTable takes you to resetFromContacts it also creates savedTablesArray[tableIndex]? If abort save should tableIndex be brought back to tableIndex-1 ? Date:April13 2022..not tested and what about newTableSpecificVariables?
if(makeContactsTable) {
tableIndex = tableIndex-1;
//code from CANCEL getnew TableName to reset savedTablesArray and newTableVariables array after not saving and cancelling it out

let cancelledSavedTablesArray = savedTablesArray.pop();
	newTableNames.pop();
let cancelledNewTableSpecificVariables = newTableSpecificVariables.pop();
//now have to restore savedTablesArray.length as in a delete
//now restore array length
//[-1,[],0]
cancelledNewTableSpecificVariables.length = 0;
newTableSpecificVariables.push(cancelledNewTableSpecificVariables);
cancelledSavedTablesArray.length = 0;
savedTablesArray.push(cancelledSavedTablesArray);

console.log("savedTablesArray.length = " + savedTablesArray.length);
//alertx("savedTablesArray.length = " + savedTablesArray.length);

	}//end if makeContactsTable

			//resetFromContacts();
				//makeContactsTable=false;
				selectedContact.length = 0;//this statement IS necessary to clear as the API must clear it on rerun? 
				abortSave = true;
				
	resetFromContacts();//will this fix CANCEL SAVE errors and issues..not tested as of April25 2022
				
//if makeContactsTable AND new table not saved we need to delete this new table from the listing	

				//displayTable();
				//return//.?temporary to prevent saving variables until code written for it Jan12022
		}//end if window.confirm else
		//end prompt
	}//end if makeContactsTable makeContactsTable || loadFromTableOptionsto ask to save contactsTable. ?should this go in saveVariables function?
	
	
		console.log("Back from saveNewTable, OR just continuing in saveTableBtn.onclick")
		//function clickedSaveTableBtns
			// let abortSave = false;declared at top of function saveTableBtn.onclick
			if(!originalOrder) {
				
			let warning = document.createElement('p');
		showTable.appendChild(warning);	warning.setAttribute('class','simulator');
				warning.textContent = 'THE ORIGINAL RECORD LIST ORDER HAS BEEN CHANGED!';
				if(!window.confirm('⚠️ The original record list order might be lost. Tap CANCEL to abort SAVE. Reset to original order in Sort. OK to SAVE anyway.(SAVE does not retain sort)')) {
				showTable.removeChild(warning);	showTable.setAttribute('class', 'hidden');
					sortTable();
					abortSave = true;
					} else {
						showTable.removeChild(warning);
						originalOrder = true;
						if(!makeContactsTable){
						abortSave = false;}//end if !makeContactsTable
						//carryOnSave();
				}//end if else confirm alert
				
			}//end if !originalOrder
			if (!abortSave) {carryOnSave();}
			
		function carryOnSave ()	{
		//alert("In carryOnSave.. tableListExists = " + tableListExists);
	
		saveTableBtn.setAttribute('class', 'normalBtn');
			saveTableBtn.textContent = 'SAVED';
				saveTableBtn2.setAttribute('class', 'normalBtn');
				saveTableBtn2.textContent = 'SAVED';
			//should copyOfTableArray be set here???Mar16
		//reset copyOfTableArray fixes reset!Mar15 alpha sort might not change tableArray, only HTML so alpha sort won't lose the original order but reverse sort does so this will protect against losing original order if reverse sort and save is pressed
		//tableArray at this point should be original database because resetFromContacts.. (restoreOriginal) was called by saveNewTable in prep for saveVariables..so now copyOfTableArray will also be original db so restoreSort will be using the wrong copyOfTableArray..i.e. originalDb instead of contacts.. so make copyOfTableArray = tableArray(contacts) in Sort itself! ?won't tableArray also be originaldb now instead of contacts because of saveVariables after contacts table is constructed…because saveNew calls restoreFromContacts to equate tableArray to original db prior to saveVariables!!! At this point after save makeContactsTable should still be true!
copyOfTableArray = tableArray.slice(0,tableTitle.length);
copyOfTableTitle = tableTitle.slice();
console.log('copyOfTableArray = ' + copyOfTableArray);

console.log('copyOfTableTitle = ' + copyOfTableTitle);
//copyOfTableTitle = 2> TSX500,3> Standard and Poors,4> Additional Note
// update copy to reflect new originalMar 15 not tested!			
			//save all necessary arrays to notes_os
	for(let i = 0;i<tableTitle.length;i++) {
			for(let j=0;j<numberOfFields;j++) {
				console.log('tableArray[' +i + '][' + j +'] = ' + tableArray[i][j]);
				
			}//end for j =
			
			
		}//end for i =
		//reset datav.object to save potential edits
		
newTableVariablesArray[0] = tableIndex;
newTableVariablesArray[1] = newTableNames;
newTableVariablesArray[2] = tableListExists;

//should loadTablIndex be tableID because you can come here from either makeContactsTable or loadTableIndex at any time? Mar2 

newTableSpecificVariables[tableID][0] = newTableEdit;
newTableSpecificVariables[tableID][1] = newTableFieldsArray.slice();

//newTableFieldsArray is wrong at this point..after a tdEdit it = the [0][1] instead of the tableID[1]
newTableSpecificVariables[tableID][2] = numberOfNewTableAddedFields;

//alertx("About to save! newTableFieldsArray = " + newTableFieldsArray + ". tableID = " + tableID + "tableIndex = " + tableIndex + ". newTableSpecificVariables[tableID][1] = " + newTableSpecificVariables[tableID][1]);

console.log("About to save! newTableFieldsArray = " + newTableFieldsArray + ". tableID = " + tableID + "tableIndex = " + tableIndex + ". newTableSpecificVariables[tableID][1] = " + newTableSpecificVariables[tableID][1]);

// newTableSpecificVariables[loadTableIndex][0] = newTableEdit;
// newTableSpecificVariables[loadTableIndex][1] = newTableFieldsArray;
// newTableSpecificVariables[loadTableIndex][2] = numberOfNewTableAddedFields;


		dataVobj.tableArray = tableArray;
		dataVobj.newTableVariables = newTableVariablesArray;
		dataVobj.tableSpecific = newTableSpecificVariables;
		
		console.log('At saving current table values! and going to saveVariables. dataVobj.tableArray = ' + dataVobj.tableArray + "  \n dataVobj.savedTables = " + dataVobj.savedTables + "dataVobj.newTableVariables = " + newTableVariablesArray + "newTableSpecificVariables[tableIndex] = " + newTableSpecificVariables[tableIndex]);
//	If loadFromTableOptions tableArray will be contacts so SAVE WILL DESTROY DB	
		//At saving current table values! and going to saveVariables. dataVobj.tableArray = 2> CN3205, Dec 21 2021 01:38,Yard3 Track 2,Tsunami2 TSU-1100 ,4,128 dataVobj.savedTables = name,DATE,tel,email,name2,DATE,tel2,email2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
//alert("going to saveVariables");

		//return false;
		saveVariables();
		//so that data appears after returning to Home Screen followiNg a displayTable function after having deleted a table record!!! Otherwise you have to 'reset tData in preferences.Date:Dec19g OR MAYBE IF DELETEDrecord Don't erase table rowas back in displayTable
		//prefWindow.setAttribute('class','showing');//instead of displayData whiCh repeats record list twice!
		
		//HAVE TO MAKE SURE SORT AND SEARCH ARE DISABLES IF THERE IS ASAVE IN LOADFROMTABLEOPTIONS
		options();//this seems to do the job!!
		//displayData();//might have to REMOVE if still repeating record list after a delete table record???THERE IS SOME ISSUE WITH CONCURRENT RUNNING OF TWO ITERATIONS OF DISPLAY DATA!!!!
	//the if else for save warning were added here Mar13..remove if messes up!!
		}//end function carryOnSave
		
// 	If a new note or record is added update the 
// 	tableArray = saveTableArray.slice();
// copyOfTableArray = saveCopyOfTableArray.slice(); 
if(recordAdded) {
saveTableArray = tableArray.slice();
copyOfTableArray = tableArray.slice();
saveCopyOfTableArray = saveTableArray.slice();

//alert("After refresh table copyOfTableArray now = " + copyOfTableArray);
recordAdded = false;
tableConstructed = 0;
displayedTable = 0;	
	}//end if(recordAdded) 
		
}//end saveTableBtn.onclick
	//saveTableBtn2.onclick = clickedSaveTable();
	
	//for saveTableBtn2
	
	saveTableBtn2.onclick = function () { 
	fieldSUM = 0;//clear to 0 in case TOTAL function has been used
	//tableIndex = 7;testing fixing screw ups
	resetFields = true;//if you hit SAVE twice fields can get messed up
	homeScreenBtn.disabled = false;//to help force Save..now reset after flashing SAVE
			 homeScreenBtn2.disabled = false;
			 moreTablesBtn.disabled = false;
			 
newTableFieldsBtn.disabled = false;//to prevent an inadvertant tap of Field Labels btn at this stage creating crashing..reset
	
	 if(renameNewTableFlag) {
displayTableBtn.setAttribute('class','tdEdit');
saveTableBtn.setAttribute('class','tdEdit');
saveTableBtn2.setAttribute('class','tdEdit');

renameNewTableFlag = false;

}//end if(renameNewTableFlag)
	
	//alertx("saveTableBtn.onclick (table screen) .. loadFromTableOptions = " + loadFromTableOptions +  ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex]);
	
	console.log("saveTableBtn.onclick (table screen) .. loadFromTableOptions = " + loadFromTableOptions +  ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex]);
		console.log("NOTE savedTableArray NOT created until saveBtn.onclick if makeContactsTable = true! So at point of saveBtn.onclick prior to first save savedTablesArray is empty!Just tapped saveTableBtn.onclick… savedTablesArray[0] = " + savedTablesArray[0]);
//NOTE savedTableArray NOT created until saveBtn.onclick if makeContactsTable = true! So at point of saveBtn.onclick prior to first save savedTablesArray is empty!
// ERROR HERE		
// Just tapped saveTableBtn.onclick… savedTablesArray[0] = Doug Dyer,
// Contact Name , Feb 06 2022 00:20, ,username@shaw.ca,(250) 658-5645,addyer@telus.net BETWEEN EDIT (REFRESH BTN AND BACK TO SAVE SOMETHING HAPPENS??)also check originalNumberRecords set to that of new table (contacts table) …4 see line 12119 4 is main db should be 3 line 12116 tableArray = Doug Dyer,
// Contact Name , Feb 06 2022 00:20, ,username@shaw.ca,(250) 658-5645,addyer@telus.net fieldNamesArray = CONTACT NAME,DATE,TELEPHONE,EMAILtableIndex = 0 tableTitle.length = 4 should be 3?
//ERROR HERE!!!!	savedTablesArray is wrong before going to saveVariables!!	
		console.log('Save Table btn tapped: makeContactsTable = ' + makeContactsTable + ' loadFromTableOptions = ' + loadFromTableOptions);
		//alert(" I removed parameter! saveTableBtn.onclick..savedTablesArray[0] = " + savedTablesArray[0]);
		//alert("newTableName =  " + newTableName);
		//Date:Jan25Remove if messes up
		if(makeContactsTable || loadFromTableOptions) {
		flipMenu.textContent = " ✅ New Table Name: " + newTableNames[tableIndex] + ". " + newTableName;
		}//end if makeContactsTable ||vloadFromTableOptions
		//flipMenu.textContent = " ✅ New Table Name: " + newTableName;//have to repeat this for second run to get it to work.not sure why?????Date: Jan2
		let abortSave = false;
		//before dtavObject.tableArray is assingned new values of an edited table make check that saveTableBtn is not being pushed from a contacts table and if it is go to saveNewTable function first to restore original tableArray values and copyTableArray values, and setup the savedTables array values etc.
		
		//return menu bar in table back to original if post search
		//flipMenu.textContent = "Click - Tap to show / hide TABLE MENU";
		
		if(!makeContactsTable && !loadFromTableOptions) {
		flipMenu.textContent = "Click - Tap to show / hide TABLE MENU";
		}//end if !makeContactsTable
		
		
	
	
	//NCJan10..If messed up go back to fallBackJan10
	// prompt to give choice for saving a contacts table or return to table
 //confirm choice window
 if(makeContactsTable || loadFromTableOptions) {
	 //NCJan10..If messed up go back to fallBackJan10
	 //when makeContactsTable and loadFromTableOptions are true tableArray is in newTable mode so have to restore to main db mode prior to any save!ResetFromContacts does this AND also sets savedOriginal to false
		 if (window.confirm("SAVE Contacts - New Table ? : \n" + "  CANCEL will Return to Table")) {
			 if(!makeHitsTable && loadFromTableOptions) {
				 makeContactsTable = false;
				 //HAVE TO SAVE THE ORIGINAL IF DOING A SAVE DIRECT FROM LOADFROMTABLEOPTIONS!!!?//you do want to save a newTable if an edit has been made!,

	//return homeBtn to normal
	homeScreenBtn.disabled = false;
homeScreenBtn2.disabled = false;
	homeScreenBtn.textContent = "RETURN to Home Screen";
	homeScreenBtn2.textContent = "RETURN to Home Screen";
	
			resetFromContacts();
	}//end if loadFromTableOptions
			 if(makeContactsTable) {loadFromTableOptions = false;
			 saveNewTable();
	}//end if makeContactsTable saveNewTable takes you to resetFromContacts it also creates savedTablesArray[tableIndex]? If abort save should tableIndex be brought back to tableIndex-1 ?
			
			
			homeScreenBtn.textContent = "Clear CONTACTS Table";
			 homeScreenBtn2.textContent = "Clear CONTACTS Table";
//MUST DISABLE SEARCH SORT EDIT AFTER THE SAVE BECAUSE tableArray has beebpn reset to db values prior to saveVariables…otherwise db values are erased by contacts!! Date: Jan30 the search sort with tableArray set to db values will mess up a sort of contacts or new table.	
	toSortScrBtn.style.backgroundColor = "lightgrey";
	toSortScrBtn.disabled = true;
	toEditTableScrBtn.style.backgroundColor = "lightgrey";
	toEditTableScrBtn.disabled = true;
	toSearchScreenBtn.style.backgroundColor = "lightgrey";
	toSearchScreenBtn.disabled = true;
//homeScreenBtn was disabled in eMailBtn.onclick in choice prompt after getNewTableName	
homeScreenBtn.disabled = false;
homeScreenBtn2.disabled = false;
	homeScreenBtn.setAttribute('class','borderBlink');
	homeScreenBtn2.setAttribute('class','borderBlink');
	
if(plusContactsEntered) {
		plusContactsEntered = false;
		homeScreenBtn.setAttribute('class','tdEdit');
	homeScreenBtn2.setAttribute('class','tdEdit');
	}//end if(manualContactsEntered)..true in setUpNewTable..make false here..in aid of not having user return to homescreen (stop flashing btn) before viewing his contacts table Date Mar21 2023	
	blockEdit = true;//flag to prevent savedTablesArray getting messed up prevent dblClick edit of td cell if just finished editing layout of table via editBtn.onclick..because otherwise tableArray will no longer be in newTable mode and savedTablesArray will get messed up DOES NOT SEEM TO WORK AFTER A SAVE POST DELETE FIELD.
	
/*	} else {
	toSortScrBtn.style.backgroundColor = "rgb(240, 248, 255)";
	toSortScrBtn.disabled = false;
	toEditTableScrBtn.style.backgroundColor = "rgb(240, 248, 255)";;
	toEditTableScrBtn.disabled = false;
	toSearchScreenBtn.style.backgroundColor = "rgb(240, 248, 255)";
	toSearchScreenBtn.disabled = false;
*/	
		 
			
			 
			// saveNewTable();
			// return//.?temporary to prevent saving variables until code written for it Jan12022
			} else {
				saveTableBtn.textContent = "SAVE";
			// saveTableBtn2.disabled = true;
			saveTableBtn2.textContent = "SAVE";
			saveTableBtn.setAttribute('class', 'normalBtn');
			saveTableBtn2.setAttribute('class', 'normalBtn');
			
//homeScreenBtn was disabled in eMailBtn.onclick in choice prompt after getNewTableName	
homeScreenBtn.disabled = false;
homeScreenBtn2.disabled = false;
homeScreenBtn.setAttribute('class','borderBlink');
homeScreenBtn2.setAttribute('class','borderBlink');

if(loadFromTableOptions || makeContactsTable) {
	emailBtn.style.display = "none";
	newTableFieldsBtn.style.display = "none";
}//end if loadFromTableOptions || makeContactsTable

//saveNewTable takes you to resetFromContacts it also creates savedTablesArray[tableIndex]? If abort save should tableIndex be brought back to tableIndex-1 ? Date:April13 2022..not tested and what about newTableSpecificVariables?
if(makeContactsTable) {
tableIndex = tableIndex-1;
//code from CANCEL getnew TableName to reset savedTablesArray and newTableVariables array after not saving and cancelling it out

let cancelledSavedTablesArray = savedTablesArray.pop();
	newTableNames.pop();
let cancelledNewTableSpecificVariables = newTableSpecificVariables.pop();
//now have to restore savedTablesArray.length as in a delete
//now restore array length
//[-1,[],0]
cancelledNewTableSpecificVariables.length = 0;
newTableSpecificVariables.push(cancelledNewTableSpecificVariables);
cancelledSavedTablesArray.length = 0;
savedTablesArray.push(cancelledSavedTablesArray);

console.log("savedTablesArray.length = " + savedTablesArray.length);
//alertx("savedTablesArray.length = " + savedTablesArray.length);

	}//end if makeContactsTable

			//resetFromContacts();
				//makeContactsTable=false;
				selectedContact.length = 0;//this statement IS necessary to clear as the API must clear it on rerun? 
				abortSave = true;
				
	resetFromContacts();//will this fix CANCEL SAVE errors and issues..not tested as of April25 2022
				
//if makeContactsTable AND new table not saved we need to delete this new table from the listing	

				//displayTable();
				//return//.?temporary to prevent saving variables until code written for it Jan12022
		}//end if window.confirm else
		//end prompt
	}//end if makeContactsTable makeContactsTable || loadFromTableOptionsto ask to save contactsTable. ?should this go in saveVariables function?
	
	
		console.log("Back from saveNewTable, OR just continuing in saveTableBtn.onclick")
		//function clickedSaveTableBtns
			// let abortSave = false;declared at top of function saveTableBtn.onclick
			if(!originalOrder) {
				
			let warning = document.createElement('p');
		showTable.appendChild(warning);	warning.setAttribute('class','simulator');
				warning.textContent = 'THE ORIGINAL RECORD LIST ORDER HAS BEEN CHANGED!';
				if(!window.confirm('⚠️ The original record list order might be lost. Tap CANCEL to abort. Reset to original order in Sort.')) {
				showTable.removeChild(warning);	showTable.setAttribute('class', 'hidden');
					sortTable();
					abortSave = true;
					} else {
						showTable.removeChild(warning);
						originalOrder = true;
						if(!makeContactsTable){
						abortSave = false;}//end if !makeContactsTable
						//carryOnSave();
				}//end if else confirm alert
				
			}//end if !originalOrder
			if (!abortSave) {carryOnSave2();}
			
		function carryOnSave2 ()	{
		//alert("In carryOnSave.. tableListExists = " + tableListExists);
	
		saveTableBtn.setAttribute('class', 'normalBtn');
			saveTableBtn.textContent = 'SAVED';
				saveTableBtn2.setAttribute('class', 'normalBtn');
				saveTableBtn2.textContent = 'SAVED';
			//should copyOfTableArray be set here???Mar16
		//reset copyOfTableArray fixes reset!Mar15 alpha sort might not change tableArray, only HTML so alpha sort won't lose the original order but reverse sort does so this will protect against losing original order if reverse sort and save is pressed
		//tableArray at this point should be original database because resetFromContacts.. (restoreOriginal) was called by saveNewTable in prep for saveVariables..so now copyOfTableArray will also be original db so restoreSort will be using the wrong copyOfTableArray..i.e. originalDb instead of contacts.. so make copyOfTableArray = tableArray(contacts) in Sort itself! ?won't tableArray also be originaldb now instead of contacts because of saveVariables after contacts table is constructed…because saveNew calls restoreFromContacts to equate tableArray to original db prior to saveVariables!!! At this point after save makeContactsTable should still be true!
copyOfTableArray = tableArray.slice(0,tableTitle.length);
copyOfTableTitle = tableTitle.slice();
console.log('copyOfTableArray = ' + copyOfTableArray);

console.log('copyOfTableTitle = ' + copyOfTableTitle);
//copyOfTableTitle = 2> TSX500,3> Standard and Poors,4> Additional Note
// update copy to reflect new originalMar 15 not tested!			
			//save all necessary arrays to notes_os
	for(let i = 0;i<tableTitle.length;i++) {
			for(let j=0;j<numberOfFields;j++) {
				console.log('tableArray[' +i + '][' + j +'] = ' + tableArray[i][j]);
				
			}//end for j =
			
			
		}//end for i =
		//reset datav.object to save potential edits
		
newTableVariablesArray[0] = tableIndex;
newTableVariablesArray[1] = newTableNames;
newTableVariablesArray[2] = tableListExists;

//should loadTablIndex be tableID because you can come here from either makeContactsTable or loadTableIndex at any time? Mar2 

newTableSpecificVariables[tableID][0] = newTableEdit;
newTableSpecificVariables[tableID][1] = newTableFieldsArray.slice();

//newTableFieldsArray is wrong at this point..after a tdEdit it = the [0][1] instead of the tableID[1]
newTableSpecificVariables[tableID][2] = numberOfNewTableAddedFields;

//alertx("About to save! newTableFieldsArray = " + newTableFieldsArray + ". tableID = " + tableID + "tableIndex = " + tableIndex + ". newTableSpecificVariables[tableID][1] = " + newTableSpecificVariables[tableID][1]);

console.log("About to save! newTableFieldsArray = " + newTableFieldsArray + ". tableID = " + tableID + "tableIndex = " + tableIndex + ". newTableSpecificVariables[tableID][1] = " + newTableSpecificVariables[tableID][1]);

// newTableSpecificVariables[loadTableIndex][0] = newTableEdit;
// newTableSpecificVariables[loadTableIndex][1] = newTableFieldsArray;
// newTableSpecificVariables[loadTableIndex][2] = numberOfNewTableAddedFields;


		dataVobj.tableArray = tableArray;
		dataVobj.newTableVariables = newTableVariablesArray;
		dataVobj.tableSpecific = newTableSpecificVariables;
		
		console.log('At saving current table values! and going to saveVariables. dataVobj.tableArray = ' + dataVobj.tableArray + "  \n dataVobj.savedTables = " + dataVobj.savedTables + "dataVobj.newTableVariables = " + newTableVariablesArray + "newTableSpecificVariables[tableIndex] = " + newTableSpecificVariables[tableIndex]);
//	If loadFromTableOptions tableArray will be contacts so SAVE WILL DESTROY DB	
		//At saving current table values! and going to saveVariables. dataVobj.tableArray = 2> CN3205, Dec 21 2021 01:38,Yard3 Track 2,Tsunami2 TSU-1100 ,4,128 dataVobj.savedTables = name,DATE,tel,email,name2,DATE,tel2,email2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
//alert("going to saveVariables");

		//return false;
		saveVariables();
		//so that data appears after returning to Home Screen followiNg a displayTable function after having deleted a table record!!! Otherwise you have to 'reset tData in preferences.Date:Dec19g OR MAYBE IF DELETEDrecord Don't erase table rowas back in displayTable
		//prefWindow.setAttribute('class','showing');//instead of displayData whiCh repeats record list twice!
		
		//HAVE TO MAKE SURE SORT AND SEARCH ARE DISABLES IF THERE IS ASAVE IN LOADFROMTABLEOPTIONS
		options();//this seems to do the job!!
		//displayData();//might have to REMOVE if still repeating record list after a delete table record???THERE IS SOME ISSUE WITH CONCURRENT RUNNING OF TWO ITERATIONS OF DISPLAY DATA!!!!
	//the if else for save warning were added here Mar13..remove if messes up!!
		}//end function carryOnSave2
		
// 	If a new note or record is added update the 
// 	tableArray = saveTableArray.slice();
// copyOfTableArray = saveCopyOfTableArray.slice(); 
if(recordAdded) {
saveTableArray = tableArray.slice();
copyOfTableArray = tableArray.slice();
saveCopyOfTableArray = saveTableArray.slice();

//alert("After refresh table copyOfTableArray now = " + copyOfTableArray);
recordAdded = false;
tableConstructed = 0;
displayedTable = 0;	
	}//end if(recordAdded) 
		

	}//end saveTableBtn(2).onclick
		
		
	console.log('At END displayTable(). This means a table now exists..rerun or not.: displayedTable = ' + displayedTable + '. tableConstructed = ' + tableConstructed + '. renewed (added record) = ' + renewed + '. refreshed (data cell edit) = ' + refreshed + '. edit = ' + edit + '. DTBtnTappedOnce = ' + DTBtnTappedOnce + '. editCurrentTable = ' + editCurrentTable + '. editCurrentTable variable is set 0 every time tableScreenOptions is run.The refreshed variable is controlled by the REFRESH Btn in the edit phase of the showTable data cell, and is also set to 1 in refreshTable function. refreshed is set to 0 in showBtn.onclick (DISPLAY TABLE) Btn, and also from a rerun..initialized to 0. The renewed variable is controlled by the refreshTable function.' + '. originalNumberOfFields = ' + originalNumberOfFields + '. numberOfFields = ' + numberOfFields + '. numberOfDynamicFields = ' + numberOfDynamicFields + '. originalNumberRecords = ' + originalNumberRecords + '. addedNumberOfRecords = ' + addedNumberOfRecords + '. See refreshTable and editBtn.onclick');
	//moved goToSearchBtn.onclick here to see if this fixes program in limbo issue after first table appearance and then tapping goToSearchBtn???FIXED BY ADDING CALL TO SEARCH FUNCTION,!!
	//return to search table window
			const toSearchScreenBtn = document.querySelector('#toSearchScr');
		toSearchScreenBtn.onclick = function () {
		fieldSUM = 0;//clear to 0 in case TOTAL function has been used
if(STsecondDataNameTdListener) {
STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
	//STsecondDataNameTd.removeEventListener;
	STsecondDataNameTdListener = false;
	eMailActive = false;
	STsecondDataNameTd.setAttribute('class','stHeadRow');
}//end if(STsecondDataNameTdListener)

if(STfirstDataNameTdListener) {
STfirstDataNameTd.removeEventListener('dblclick',STfirstDataNameTd.fn, false);
	//STfirstDataNameTd.removeEventListener;
	STfirstDataNameTdListener = false;
	telephoneActive = false;
	STfirstDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STfirstDataNameTdListener)
		
//reset fromSearchRecord to false and hits.length to 0 to fix search bug if using a td referenced search followed by a first column tableTitle search Date: Jun2 2022
fromSearchRecord = false;
hits.length = 0;

				fromViewSort = false;//turn off sort flag
			console.log('toSearchScreenBtn clicked');
			
			showTable.setAttribute('class', 'hidden');
			searchRecords();
		
			//searchWindow.setAttribute('class','showing');
		}//end toSearchScreenBtn.onclick
	//to edit table from table screen
	//MAKE GLOBAL BECAUSE USED IN TABLESCREENOPTIONS! Date: Feb9 2022
	
	//const toEditTableScrBtn = document.querySelector('#toEditTableScr');
		toEditTableScrBtn.onclick = function () {
		//blockEdit = true;//ADDED OCT10 2022..remove if messes up flag to prevent savedTablesArray getting messed up
		fieldSUM = 0;//clear to 0 in case TOTAL function has been used
		if (loadFromTableOptions & DTBtnTappedOnce === 0) {
		alert('Before editing this table you need to initialize the main database table first by tapping DISPLAY TABLE at least once!');	//tableScreen.setAttribute('class','hidden');
			//createTableWindow.setAttribute('class', 'hidden');	
			showTable.setAttribute('class', 'hidden');
			displayTableBtn.setAttribute('class','borderBlinkGrn');
			displayTableBtn.textContent = "INITIALIZE TABLE";
			tableScreenOptions();
			return;
			}//end if (loadFromTableOptions & DTBtnTappedOnce === 0)
				
		//return menu bar in table back to original if post search
		if(!makeContactsTable) {
		flipMenu.textContent = "Click - Tap to show / hide TABLE MENU";
	}//end if !makeContactsTable
	//clearTableWindow is the infoP bar across top of Create A Table or Display Current Table screen. clearTableWindowEditBtn is the word EDIT in this bar
clearTableWindow.setAttribute('class','borderBlinkGrn');	
	clearTableWindowEditBtn.setAttribute('class','borderBlink');
			
			fromViewSort = false;//turn off sort flag
			console.log('toEditTableScrBtn clicked');
			
			showTable.setAttribute('class', 'hidden');
			tableScreenOptions();
		
			//searchWindow.setAttribute('class','showing');
		}//end toEditTableScrBtn.onclick
	
	//to SORT TABLE CODE	
	const toSortScrBtn = document.querySelector('#toSortScr');
	
//DISABLE SORT SEARCH AND EDIT IF CREATING A CONTACTS TABLE SO RESTORE SORT ETC IS NOT MESSED UP. SORT AND SEARCH WILL ONLY BE ALLOWED IN A NEW TABLE IF IT IS LOADED FROM THE NEW TABLE LIST! But no SAVE can be allowed if either makeContactsTable OR loadFromTableOptions is true because that would corrupt the db tableArray!
if(makeContactsTable) {
	toSortScrBtn.style.backgroundColor = "lightgrey";
	toSortScrBtn.disabled = true;
	toEditTableScrBtn.style.backgroundColor = "lightgrey";
	toEditTableScrBtn.disabled = true;
	toSearchScreenBtn.style.backgroundColor = "lightgrey";
	toSearchScreenBtn.disabled = true;
	
} else {
	toSortScrBtn.style.backgroundColor = "rgb(240, 248, 255)";
	toSortScrBtn.disabled = false;
	toEditTableScrBtn.style.backgroundColor = "rgb(240, 248, 255)";;
	toEditTableScrBtn.disabled = false;
	toSearchScreenBtn.style.backgroundColor = "rgb(240, 248, 255)";
	toSearchScreenBtn.disabled = false;
	
}//end if makeContactsTable

//-xxxx-xxx
	
		toSortScrBtn.onclick = function () {
		fieldSUM = 0;//clear to 0 in case TOTAL function has been used
			
			//return menu bar in table back to original if post search
			//flipMenu.textContent = "Click - Tap to show / hide TABLE MENU";
			
			console.log('toSortScrBtn clicked');
		//fromViewSort = false;//turn off sort flag
			showTable.setAttribute('class', 'hidden');
			sortTable();
		}//end toSortScrBtn.onclick
		
		//get contacts	
	// const emailBtn = document.querySelector('#email');//made global
	const contactTableDiv = document.querySelector('#contactTableDiv');
	const contactTableP = document.createElement('p');
	
	//relabel newTableFields..Field Labels btn
	newTableFieldsBtn.onclick = async function () {
	fieldSUM = 0;//clear to 0 in case TOTAL function has been used
fromEditFieldLabels = true;	newTableFieldsBtn.setAttribute('class','tdEdit');
	checkTableLimit();
if (tableLimit) {
tableLimit = false;
showTable.setAttribute('class','hidden');
fromAddContacts = false;//flag to tell editNewTableFieldNames to flash and return to ADD CONTACTS added here May7
return;	
}
	
	//alertx("Field Labels btn just clicked! contactsFieldNames = " +contactsFieldNames);
	console.log("Field Labels btn just clicked! contactsFieldNames = " +contactsFieldNames);
	
	
	//let defaultFieldNames = [];
	defaultFieldNames = "CONTACT NAME,DATE,TELEPHONE,EMAIL,ADDRESS";
if(contactsFieldNames.length !== 0) {
	defaultFieldNames = "";
	//defaultFieldNames.length = 0;
}

//code for promptBox 3 btns .. EDIT FIELD NAMES, USE CURRENT FIELD NAMES, CANCEL
promptBox.setAttribute('class','showing');
//	tableScreen.setAttribute('class','hidden');
// tableNameTxt.setAttribute('style', 'white-space: pre;');//enable line breaks add \r\n in text everywhere You want for line-break (new line)
//tableNameTxt.setAttribute('class','ppref');
tableNameTxt.setAttribute('style', 'white-space: pre-wrap; background-color: black; color: white; border: 2px solid red; padding:5px');//enable line breaks add \r\n in text everywhere You want for line-break (new line)
if(fromAddContacts) {
tableNameTxt.textContent = `ADD CONTACTS/RECORDS allows manual entry of records. The ContactPicker API is not available here.`+`\r\n`+` The current field headings are: ` +`\r\n` +defaultFieldNames + contactsFieldNames +` \r\n ` + `
    EDIT FIELD NAMES will allow re-naming field labels \r\n
     \r\n
      CANCEL returns to main table.`;
  } else {  
   tableNameTxt.textContent = `Edit Field Labels allows changing the titles of current field headings. CONTACTS will then create a table with these field headings using the device's ContactPickerAPI. The current field headings are: ` +`\r\n` +defaultFieldNames + contactsFieldNames +` \r\n ` + `
    EDIT FIELD NAMES will allow re-naming field headings \r\n USE CURRENT FIELD NAMES creates the table using field headings above.
     \n
      CANCEL returns to table - alternate 4/5 fields.`;  
  }//end if else (fromAddContacts)
      
actionLoadBtn.textContent = "EDIT FIELD NAMES";
actionRenameBtn.textContent = "USE CURRENT FIELD NAMES";
actionCancelBtn.textContent = "CANCEL";
actionDeleteBtn.style.display = "none";

if(fromAddContacts) {
	actionRenameBtn.style.display = "none";
} else {	
actionRenameBtn.style.display = "unset";
}//end if(fromAddContacts)

actionLoadBtn.onclick = async function () {
await editNewTableFieldNames();
if(fromAddContacts) {
	actionLoadBtn.style.display = "none";//so only use current appears when returning to this screen via ADD CONTACTS/RECORDS during the EDIT FIELD NAMES process of ADD CONTACTS Date:May1..doesn't work because this screen revisited before final ADD CONTACTS!
	actionLoadBtn.setAttribute('class','tdEdit');//normalize this btn to ready for its next appeance
}//end if fromAddContacts
promptBox.setAttribute('class','hidden');
}//end actionLoadBtn.onclick

actionRenameBtn.onclick = function() {
//KEEP THIS ALERT!
alert("The new table Field Names are set to: " + defaultFieldNames + contactsFieldNames);
	emailBtn.setAttribute('class','borderBlink');
	promptBox.setAttribute('class','hidden');
	}//end function actionRenameBtn.onclick
	
actionCancelBtn.onclick = function() {
promptBox.setAttribute('class','hidden');
fromAddContacts = false;//in case we CANCEL here during an addContacts/Records process	
fromEditFieldLabels = false;

actionRenameBtn.setAttribute('class','tdEdit');//in case flashing from a cancelled edit field names
actionLoadBtn.setAttribute('class','tdEdit');//so EDIT FIELD NAMES btn is not flashing when you go back to the Action Prompt screen	
contactsFieldNames.length = 0;//May14 .This will reset contactsFields which will allow switching back and forth between 4 fields ending in email OR 5 fields ending in ADDRESS. Depending on whether CONTACTS or FIELD LABELS is tapped first you get 4 or 5 fields. If you get 4 but you want 5 with ADDRESS just tap CANCEL in the ENTER NEW TABLE NAME window, and do again
}//end function actionCancelBtn.onclick


//prompt to give choice to edit field names
//confirm choice window
//if(fromAddContacts) don't allow CANCEL choice ..this will mess up!
	// 	 if (window.confirm("The current field headings are: " + defaultFieldNames + contactsFieldNames +" \n" + "  OK will allow EDITing of field labels \n CANCEL will create a new Table with the current headings above.")) {
	// 	 //showTable.setAttribute('class', 'showing');
	// 	 await editNewTableFieldNames();
	// 	 } else {
	
	
	// alert("The new table Field Names are set to: " + defaultFieldNames + contactsFieldNames);
	// emailBtn.setAttribute('class','borderBlink');
	
	// 	}//end choice prompt
//After pre-set field names, field labels >CANCEL does not work		
//go direct to creating table
/*homeScreenBtn.textContent = "Clear CONTACTS Table";
			homeScreenBtn2.textContent = "Clear CONTACTS Table";
			clearFoundRecordListFunc();
			test = true;
await	
	 allContactInfo(selectedContact);
*/		
	}//end newTableFieldsBtn.onclick
	
	//CONTACTS BTn
	if(hitsTable) {emailBtn.textContent = "HITS>TABLE";}
	
	//alertbkup("dataBaseName = " + dataBaseName + " dbTableName.value = " + dbTableName.value);
	
	backupBtn2.onclick = function (dataBaseName) {
	dataBaseName = dbTableName.value;
backMeUp(dataBaseName);
	}//end function call
	
emailBtn.onclick = async function () {
//alert("newTableNames.length = " + newTableNames.length);
fieldSUM = 0;//clear to 0 in case TOTAL function has been used
//SHOULD THESE VARIABLES BE CLEARED AT THE START OF CONTACTS SO REPEAT RECORDS DON'T HAPPE??? Date Jun6

contactsArray.length = 0;
selectedContact.length = 0;//this statement IS necessary to clear

//SHOULD THESE VARIABLES BE CLEARED AT THE START OF CONTACTS SO REPEAT RECORDS DON'T HAPPE??? Date Jun6


if(!fromEditFieldLabels) {contactsFieldNames.length = 0; fromEditFieldLabels=false}//to force a simple contacts list
//fromEditFieldLabels = false;
console.log("CONTACTS BTN CLICKED");	

//alertx("tableIndex = " + tableIndex);
console.log("tableIndex = " + tableIndex);

checkTableLimit();
if (tableLimit) {
tableLimit = false;
loadFromTableOptions = false;//added May3 because this messes up screen display later?
showTable.setAttribute('class','hidden');
return;	
}

emailBtn.setAttribute('class','tdEdit');
//CODE TO CREATE A NEW TABLE USING SEARCHED HITS vv
if(hitsTable) {

//alertx("Hits>Table just tapped: makeHitsTable is true..searchedHitsTableArray = " + searchedHitsTableArray);
console.log("Hits>Table just tapped: makeHitsTable is true..searchedHitsTableArray = " + searchedHitsTableArray);

//code to CANCEL new table creation v
 //confirm choice window
		 if (window.confirm("Create New Table ? : \n" + query + " \n CANCEL will Return to Table")) {

	makeContactsTable= true;
	makeHitsTable = true;
checkScreenMode();
if(screenDark) {
	newTableNameWin.style.backgroundColor = "black";
	newTableNameWin.style.color = "white";
	showNewTableNameP.style.color = "white";
} else {
	newTableNameWin.style.backgroundColor = "#eee";
	newTableNameWin.style.color = "black";
	showNewTableNameP.style.color = "black";
}//end if else screenDark

newTableNameWin.setAttribute('class', 'showing');
newTableTitle.textContent = dbName;

//code to CANCEL new table creation v

//code to CANCEL new table creation ^

			getNewTableName();
		
	//-xxxxxxxxxxx	
			saveTableBtn.setAttribute('class','borderBlink');
			 saveTableBtn2.setAttribute('class','borderBlink');
homeScreenBtn.disabled = true;
homeScreenBtn2.disabled = true;
moreTablesBtn.disabled = true;
			// saveTableBtn.disabled = true;
setupNewTable();
//SHOULD IT BE MANDATORY TO SAVE HERE TO AVOID ERROR IN FUTURE RE NEWTABLESPECIFICVARIABLES FIELDS NOT BEING SAVED ????
return;

		} else {

makeContactsTable=false;
makeHitsTable = false;
emailBtn.textContent = "CONTACTS";
emailBtn.style.display = "none";
newTableFieldsBtn.style.display = "none";
hitsTable = false;
makeHitsTable = false;

				contactsArray.length = 0;
				selectedContact.length = 0;//this statement IS necessary to clear as the API must clear it on rerun? 
	searchedHitsTableArray.length = 0;
		
	homeScreenBtn.textContent = "RETURN to Home Screen";
			homeScreenBtn2.textContent = "RETURN to Home Screen";	
			return;		
		}//end if window.confirm else
//end prompt	 

}//end if(HitsTable)	
		
//CODE TO CREATE A NEW TABLE USING SEARCHED HITS ^^

		
//choice option for crreating contacts
// var selected = 0;
// $("#dialog").dialog({
//   title: "Prompt",
//   buttons: {
//     "First": function() {
//       selected = 1;
//     },
//     "Second": function() {
//       selected = 2;
//     },
//     "Third": function() {
//       selected = 3;
//     },
//     "Fourth": function() {
//       selected = 4;
//     }
//     // ..............
//   }
// });
//choice option for crreating contacts
			//newTableNameWin.setAttribute('class','showing');
			
		//await getNewTableName(newTableName);
			
			homeScreenBtn.textContent = "Clear CONTACTS Table";
			homeScreenBtn2.textContent = "Clear CONTACTS Table";
			clearFoundRecordListFunc(); //use line below instead?
			//if(contactsTable) {contactsTable.length = 0;
			//}//end if contactsTable
			//savedOriginal = false;//flag that prevents repeatedContactsTables from overwriting original. Set back to false here (to allow for changing databases, but not returned to false in CONTACTSbtn in display table which allows for repeated contacts tables but not overwriting original table)

		
			test = true;
			//return menu bar in table back to original if post search
			//flipMenu.textContent = "Click - Tap to show / hide TABLE MENU";
			
			console.log('emailBtn clicked');
			
//for a contacts table using contactPickerAPI  we want only the 4 fields vv
//manualContactsEntered = false;
//contactsFieldNames.length = 4;	
//for a contacts table using contactPickerAPI  we want only the 4 fields ^^

		//fromViewSort = false;//turn off sort flag
			//showTable.setAttribute('class', 'hidden');
			//getEmail(selectedContact);
			//alert("about to go to allContactInfo function: test = " + test);
//	if(test){
await	
	 allContactInfo(selectedContact);//contactsTable
		//allContactInfo(contactsTable);//contactsTable
	
	//alert("back from allContactInfo . test should be true.. =  " + test + " contacts: (selectedContact) = " + selectedContact);
		//selectedContact = ["Steve Ansell", "ansell.s@gmail.com"],["
//Gordon Armstrong","gtarmstrong@shaw.ca"],[
//"Andrea", "ajull@telus.net"];
 if(!test) {
	alert("Creating Contacts manually. ContactPickerAPI is not available test =  " + test);
	 manuallyCreateContacts(selectedContact);
	//create a selectedContact array
	
/*	
//REMOVE REFERENCES BELOW..after finished coding THEY ARE ALL GLOBAL	
//references for manualContacts entry code
const manualContactsWindow = document.querySelector('#manualContactsWin');
const contactsNameInput = document.querySelector('#contactsName');
const telephoneInput = document.querySelector('#telephone');
const contactsEmailInput = document.querySelector('#contactsEmail');
const contactsAddressInput = document.querySelector('#contactsAddress');
const manualContactsInstructionP = document.querySelector('#manualContactsInstruction');
const enterContactBtn = document.querySelector('#enterContactBtn');
const cancelContactEntryBtn = document.querySelector('#cancelContactEntry');
const cancelAllBtn = document.querySelector('#cancelAll');
const statusContactEntryP = document.querySelector('#statusContactEntry');
const finishedContactsEntryBtn = document.querySelector('#finishedContactsEntry');

//references above for manualContacts entry code
//REMOVE REFERENCES ABOVE..THEY ARE ALL GLOBAL
*/


}//end if !test

if(test) {
//RETURNING FROM allContactInfo()
			//alert("Use COPY/PASTE to insert desired information into record or table data cell: \n selected Contacts: " + selectedContact);
//CREATING contactsArray from selectedContact
	

	//var contactsArray = [];//declared global		
for(i=0;i<selectedContact.length;i++) {
contactsArray[i] = cutName(selectedContact[i]);
console.log(Array.isArray(contactsArray[i]));
//alert(arr);
}//end for i


//use this for the copy paste notice
alert("Use COPY/PASTE to insert desired information into record or table data cell: \n selected Contacts: \n" + contactsArray);
//need to update todayString!!
 today = new Date();
 todayS = today.toString();
 todayString = todayS.slice(3, 21);
 //alert('todayString = ' + todayString);

for(i=0;i<selectedContact.length;i++) {
contactsArray[i].splice(1, 0,todayString);
}//end for i


}//end if test

// prompt to give choice for making a contacts table
 //confirm choice window
		 if (window.confirm("Create Contacts Table ? : \n" + "  CANCEL will Return to Table")) {
			 makeContactsTable= true;
//await editNewTableFieldNames();
	//-xxxxxxxxxxx	
	
//resetting newTableSpecificVariables to correct undefined error April12

//redefinenewTableSpecificVariables ();	
//alert("Back from redefine tableSpecificVariables") ;
			//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	newTableNameWin.style.backgroundColor = "black";
	newTableNameWin.style.color = "white";
	showNewTableNameP.style.color = "white";
} else {
	newTableNameWin.style.backgroundColor = "#eee";
	newTableNameWin.style.color = "black";
	showNewTableNameP.style.color = "black";
}//end if else screenDark

newTableNameWin.setAttribute('class', 'showing');
newTableTitle.textContent = dbName;

			getNewTableName();
		
	//-xxxxxxxxxxx	
			saveTableBtn.setAttribute('class','borderBlink');
			 saveTableBtn2.setAttribute('class','borderBlink');
//to help force a SAVE of newly created table. If not saved there might be a mess? Date: April28
	homeScreenBtn.disabled = true;
	homeScreenBtn2.disabled = true;	
	moreTablesBtn.disabled = true;	 


			// saveTableBtn.disabled = true;
			//  saveTableBtn.textContent = "Save CONTACTS";
			// // saveTableBtn2.disabled = true;
			//  saveTableBtn2.textContent = "Save CONTACTS";
			//getNewTableName();
			
//code moved from below
//alertx("contactsFieldNames = " + contactsFieldNames);
console.log("contactsFieldNames = " + contactsFieldNames);

setupNewTable();

//alertx("tableIndex = " + tableIndex);
console.log("tableIndex = " + tableIndex);
//works to here
//NOTE savedTableArray NOT created until saveBtn.onclick if makeContactsTable = true! So at point of saveBtn.onclick prior to first save savedTablesArray is empty!

return false;//to stop run away? Reloading of DougieBase after making new table?or is the error causing this ? Feb24 date:Mar20 2023- get to here ok and now left with flashing SAVE btn ..investigating why a second contacts table is created?
			} else {
				makeContactsTable=false;
				contactsArray.length = 0;
				selectedContact.length = 0;//this statement IS necessary to clear as the API must clear it on rerun? 
	homeScreenBtn.textContent = "RETURN to Home Screen";
			homeScreenBtn2.textContent = "RETURN to Home Screen";			
		}//end if window.confirm else
//end prompt

//if(!test) 


/*	
 //THIS CODE BELOW CREATES contactsTable array
contactsTable = new Array(seletedContact.length);


//for (var i = 0; i < recordCounter; i++) {
	
for (var i = 0; i < selectedContact.length; i++) {

contactsTable[i] = new Array(4);

}//number of fields means all fields

//if(makeContactsTable) {
	alert("in makeContacts table. selectedContact.length = " + selectedContact.length);

for(i=0;i<selectedContact.length;i++) {
  for (c=0;c<4;c++) {
     if (c==0) {
	
		 console.log("contactsTable[i][0] = " + contactsTable[i][0]);
      contactsTable[i][0] = arr[i][0];
	  
	  alert("contactsTable["+i+"][0] = " + contactsTable[i][0]);
	  //contactsTable[i][0] = Steve Ansell
           }//end if c=0
      if(c==1) {
         contactsTable[i][1] = todayString;//date funtion wrong!
		console.log("contactsTable[i][1] = " + contactsTable[i][1]); 
          }//end if c=1
       if (c==2) {
           contactsTable[i][2] = arr[i][2];
          }//end c=2
        if (c==3) {
           contactsTable[i][3] = arr[i][1];
          }//end c=3
    }//end for c=0 loop   
  }//end for i =0 loop
//}//end if makeContactsTable
//}//END if (!test)
//CODE ABOVE CREATES contactsTable array
 alert("contactsTable[1][3] email = " + contactsTable[1][3]);
 
//arr[i][0]=name arr[i][1]=email arr[i][2]=tel
	
// //THIS CODE BELOW CREATES contactsTable array
// var contactsTable = new Array(selectedContact.length);

// //for (var i = 0; i < recordCounter; i++) {
	
// for (var i = 0; i < selectedContact.length; i++) {

// contactsTable[i] = new Array(4);

// }//number of fields means all fields

// if(makeContactsTable) {
// 	alert("in makeContacts table. selectedContact.length = " + selectedContact.length);

// for(i=0;i<selectedContact.length;i++) {
//   for (c=0;c<4;c++) {
//      if (c==0) {
// 		 console.log("selectedContact[i].name = " + selectedContact[i].name);
// 		 console.log("contactsTable[i][0] = " + contactsTable[i][0]);
//       contactsTable[i][0] = selectedContact[i].name;
// 	  alert("selectedContact[i].name = " + selectedContact[i].name);
// 	  alert("contactsTable[i][0] = " + contactsTable[i][0]);
// 	  //contactsTable[i][0] = Steve Ansell
//            }//end if c=0
//       if(c==1) {
//          contactsTable[i][1] = todayString;//date funtion wrong!
// 		console.log("contactsTable[i][1] = " + contactsTable[i][1]); 
//           }//end if c=1
//        if (c==2) {
//            contactsTable[i][2] = selectedContact[i].tel;
//           }//end c=2
//         if (c==3) {
//            contactsTable[i][3] = selectedContact[i].email;
//           }//end c=3
//     }//end for c=0 loop   
//   }//end for i =0 loop
// }//end if makeContactsTable
// //}//END if (!test)
// //CODE ABOVE CREATES contactsTable array (contactsTable)
*/

//REMOVED THIS CODE FROM HERE AND PUT IN Ok prompt above

// alert("contactsFieldNames = " + contactsFieldNames);
// setupNewTable();
// //works to here
// //NOTE savedTableArray NOT created until saveBtn.onclick if makeContactsTable = true! So at point of saveBtn.onclick prior to first save savedTablesArray is empty!

// return false;//to stop run away? Reloading of DougieBase after making new table?or is the error causing this ? Feb24

//REMOVED THIS CODE FROM HERE AND PUT IN Ok prompt above Date: April 28 2022
}//end emailBtn.onclick
	//END EMAILBTN.ONCLICK..END OF CREATING AND DISPLAYING CONTACTS	
	
//ADD CONTACTS TO PRE-EXISTING CONTACTS TABLE DATE: FEB 19 2022
//will create a conditional flag that indicates if new table derived from a searchmain db in aid of preventing + - icons appearing in such a table..aadding a record herevwould crash! Use the > in tableArray[0][0] to indicate from a maindb search table
/*
//experimental print table
printBtn.onclick = function () {
alert("This is an experimental option. It will not work on all browsers. Select the tables page range, then tap PRINT in your browsers printerAPI. This results in a PDF of the screen that accepts the choice options of the share sheet.");
// document.querySelectorAll("table").forEach(elem => 
//  elem.onclick = () => print_this(elem))	
  
document.querySelectorAll("table").forEach(elem => elem.addEventListener('click',print_this(elem))
  )
  
}//end function printBtn.onclick
//experimental print table
*/

if(loadFromTableOptions) {
 
 if(tableArray[0][0].includes(">")) {
plusContactsBtn.style.display = "none";//or use visibility:hidden
deleteRecordNewTableBtn.style.display = "none";
} else {
plusContactsBtn.style.display = "unset";//or use visibility:hidden
deleteRecordNewTableBtn.style.display = "unset";
	}//end if else (!tableArray[0][0].includes(">"))
	
	plusContactsBtn.onclick = function () {
	fieldSUM = 0;//clear to 0 in case TOTAL function has been used
	contactsArray.length = 0;
	manualContacts.length = 0;//clear from a previous use
	//moved from addingMoreContactsvv
	plusContacts = true;
	plusContactsEntered = true;////using this flag to prevent home btn from flashing after creating a + contact ..made false in saveTableBtn.onclick Date-Mar21 2023 also used in tdEdit and deleteRecordNewTableBtn
	
	fromAddingMoreContacts = true;//forcing a resetFields when displayTableBtn is tapped
resetFields = true;

console.log("newTableFieldsArray = " + newTableFieldsArray);
//alertx("newTableFieldsArray = " + newTableFieldsArray);

contactsFieldNames = newTableFieldsArray.slice();
//moved from addingMoreContacts^^
	//addingMoreContacts();after more testing remove theaddingMoreContacts function for speeding up code
	manuallyCreateContacts();
	};//end plusContactsBtn.onclick
	//ADD CONTACTS TO PRE-EXISTING CONTACTS TABLE DATE: FEB 19 2022
	//delete a record from a new table
//or use visibility:hidden
deleteRecordNewTableBtn.onclick = function () {
plusContactsEntered = true;////using this flag to prevent home btn from flashing after creating a + contact ..made false in saveTableBtn.onclick Date-Mar21 2023 also used in tdEdit

fieldSUM = 0;//clear to 0 in case TOTAL function has been used
	deleteRecordNewTable = true;//set flag for record deletion to run delete code in display table
	//blockEdit = true;//to stop a double click from deleting a record again
	alert("Double-tap on the record you wish to delete!");
	};//end deleteRecordNewTableBtn.onclick

	} else {
	deleteRecordNewTable = false;	deleteRecordNewTableBtn.style.display = "none";
	plusContactsBtn.style.display = "none";//or use visibility:hidden
	
}//end if else loadFromTableOptions ..add contacts	
	
//alert below is outside displayTable code and won't run??	Dec31	
//alert("At end of displayTable: tableArray = " + tableArray);	

//do sum if totalActive
//do sum if totalActive line 11202
// alert("totalFieldNameListener = " + totalFieldNameListener + "fieldNamesArray[totalFieldNameIndex] = " + fieldNamesArray[totalFieldNameIndex]);
// //TypeError: null is not an object (evaluating 'sumField.addEventListener')
// if(totalFieldNameListener) {

// // sumField.addEventListener('dblclick', sumField.fn = function fn() {
// 	totalActive =true; 
// // 		alert("Summing contents of TOTAL column!");
// // 		});//end addEventListener	
// }//end if totalFieldNameListener
// if(totalFieldNameListener) {
// alert("summing");
// 	for (i =0;i <tableTitle.length;++i) {
// 	fieldSUM = fieldSUM + tableArray[i][totalFieldNameIndex];

// fieldNamesArray[totalFieldNameIndex].textContent = " TOTAL = " + fieldSUM;
// 	}//end for loop
// 	totalFieldNameListener = false;
// 	displayTable();
// }//end ifTotalActive

//in RETURN TO HOME Btn reset variables and remove addeventListener

//do sum if totalActive

// //CHECK IF ROWS SUMMED date Nov13
// alert("checking if rowSummed!")
// 	//alert("checking for rowSummed");
// 	if(tableArray[i][c].includes(sumRowTxt)	) {
// 					rowSummed = true;
// //TypeError: undefined is not an object (evaluating 'tableArray[i][c].includes') GOT THIS ERROR WHEN THIS CODE WAS AT LINE 9815
// //PROBABLY NEED TO STORE rowSummed variable in tableVariables array?
// 		alert("does this code ever run? rowSummed = " + rowSummed);			
// 				} else {
// 					rowSummed = false;
// 					alert("in else part does this code ever run? rowSummed = " + rowSummed);
// 					}//end if else
// 	//CHECK IF ROWS SUMMED

//change month of budget sheet

//change month of budget sheet
changeMonthBtn1.onclick = changeMonthBudgetSheet;
}//end function displayTable ..!!!! showTable

//when incorporating into IndexedDBNotes will have to have a mechanism to save the table and field arrays

// // prompt to give choice for saving a contacts table or return to table
//  //confirm choice window
//  if(makeContactsTable) {
// 		 if (window.confirm("SAVE Contacts Table ? : \n" + "  CANCEL will Return to Table")) {
// 			 makeContactsTable= true;
// 			 saveContactsTable();
// 			} else {
// 				makeContactsTable=false;
// 				selectedContact.length = 0;//this statement IS necessary to clear as the API must clear it on rerun? 
				
// 		}//end if window.confirm else
// 		//end prompt
// 	}//end if makeContactsTable to ask to save contactsTable. ?should this go in saveVariables function?
		
function refreshTable () {
	console.log('Entered refreshTable. fromViewSort = ' + fromViewSort);
	//Left off here Oct 28
	//removed refresh=1 Nov 22 so that field headings will be geNerated after adding a record and update
	//if refreshed not set to 1 then field headings will repeat when going to display table, but if at 0 a rerun will recreate the field headings which is what you want. So maybe add line refresh = 0 on return from displayTable .see below
refreshed = 1;//to keep field titles from repeating (same for if edit = 1)
renewed = 1;//variable in refreshTable()to create header row in displayTable when coming from refrehTable
console.log('At refreshTable: refreshed = ' + refreshed + ' renewed = ' + renewed +'. refreshed variable gets set to 1 in the edit data cell section of the STshowTable code, as well as here in the refreshTable function. (Removed Nov 22 so field headings will again be generated? It is not returned to 0 in refreshTable function so that if there is a rerun, extra fields will not repeat in displayTable(). The renewed variable is set to 1 in refreshTable, and is returned to 0 after refreshTable() completes.');
tableScreen.setAttribute('class','hidden');
showTable.setAttribute('class', 'showing');
	//might you have to clear the previous showTable screen of all content first to prevent repeat display of table?
	//ReferenceError: Can't find variable: buildRecordRows IS THIS BECAUSE BUILDRECORDROWS FUNC IS WITHIN THE MAKETABLE FUNCTION.???? So will try placing buildRecordRows function outside of makeTable!!
	if (!fromViewSort) {
	console.log('Going to buildRecordRows() from refreshTable. tableArray = ' + tableArray);
		}
	//tableArray has not been updated
	console.log('tableTitle[] = ' + tableTitle);
	//table is updated but taBleArray not yet updated
	console.log('tableArray[] = ' + tableArray);
	
	//tableTitle[] = CN3205,CN4800,CN4700,CP6700
	//tableTitle has been updated
	
	//trial code to define new tableArray
	originalNumberOfFields = numberOfFields;
	addedNumberOfRecords = tableTitle.length-originalNumberRecords;
	currentNumberOfFields = fieldNamesArray.length;
	
	//redefineTableArray();
	//update original if records added to be able to restore sort. But don't do this from sort as origiNal will be lost..it will become the sorted version
	// if (!fromViewSort) {
	// copyOfTableArray = tableArray.slice(0,tableTitle.length);
	// copyOfTableTitle = tableTitle.slice();
	// }//end if !fromViewSort
	//copyOfTableArray = tableArray.slice();
	//copyOfTableTitle = tableTitle.slice();

	testing = true;
	
	//LEFT OFF HERE DEC 12
	
	//tableTitle[] = CN3205,CN4800,CN4700,EN102,EN102
	
	
	
	//if (!deleteRecord) {
	//added from xsort	
	if (!fromViewSort) {
		//console.log('fromViewSort = false so going to buildRecordRows');	
		
		buildRecordRows();//buildRecordRows
		console.log('Back from buildRecordRows..clear the table before repopulating.')
	
	}//end if !fromViewSort added from  xsort	
//	}//end if !deleteRecord
	
	//clearing old header row prior to going back to displayTable to update% after adding the record. .??maybe the header clear not necessary here?, because you had to rebuild it in displayTable..Romberg you are only adding a record in refreshTable, not adding a field!
	while (STrows.firstChild) {
   STrows.removeChild(STrows.firstChild);
	 }//end while
	originalNumberRecords = tableTitle.length;//use to give refresh table option each time a record is added originally set in newBtn.onclick of CreateTable..Romberg new originalNumberRecords for next reboot
	if (!fromViewSort) {
	console.log('Returning from buildRecordRows and going to displayTable after clearing table prior to repopulating in displayTable');
		}
	
	console.log('In refreshTable(). tableTitle.length = ' + tableTitle.length);
	console.log('tableArray = ' + tableArray);
	testing = false;
	displayTable();
//removed refreshed=0 because it is not used here and it causes repeat of extra fields in displayTable (Noc 5 2020)
//refreshed = 0;//NOTE ADDED IT BACK IN DEC 20 2020	
console.log('Back from displayTable. renewed is set back to 0, but refreshed = ' + refreshed + ' for run through displayTable, but is now going to be set to 0 again at end of refreshTable() function. If tapping Display Table again..which means added fields will not be repeated by displayTable if run through displayTable again, for example by a rerun.');
renewed = 0;
refreshed = 0;//see Nov 5 note above..not sure what that refers to..maybe in edit? But otherwise works for a refresh table call after adding a new record Dec20
//keeping track of SAVE Btn (in table)
//code below should run only if (!fromViewSort) Mar 10
if(!fromViewSort) {

saveTableBtn.setAttribute('class','borderBlinkGrn');//was colorBtn
saveTableBtn.textContent = 'SAVE !'
saveTableBtn2.setAttribute('class','borderBlinkGrn');
saveTableBtn2.textContent = 'SAVE !'
flipMenu.setAttribute('class','colorBtn');
$("#flip").css({"background-color": "yellow", "border-color": "red"});


tableNeedsUpdate = false;
editNote = false;//flag to refreshTable if notes edited
copyOfTableArray = tableArray.slice(0,tableTitle.length);
//copyOfTableArray now up to date after record added but dynamic fields are blank (until there is a further edit of data cells and save from table)
copyOfTableTitle = tableTitle.slice();
console.log('copyOfTableArray = ' + copyOfTableArray);
}//end if (!from iewSort)
}//end refreshTable()

//function to redefine tableArray
function redefineTableArray () {
	//function to redefinetableArray
	
	var r = originalNumberRecords; //start from rows 3
var c = originalNumberOfFields; //start from col 5..if edit don't forget to increase the numberOfFields value

var rows = tableTitle.length;//current total number of rows after adding new ones will = tableTitle.length
var cols = currentNumberOfFields;

for (var i = 0; i < rows; i++) {
  var start;
  if (i < r) {
    start =  c;
  } else {
    start = 0;
    tableArray.push([]);
  }
  for (var j = start; j < cols; j++) {
        tableArray[i].push(0);
    }
}
return tableArray;
//above is trial code to define new tableArray
//PUTS 7 0's after each record ? How come?
}//end function redefineTableArray

// javascript for createTable above

//function to  add STHeader and STHeadRow
function addFieldHeaders () {
	console.log('Adding Field Headers');	STtableHeader.setAttribute('class','attentionBtn');
STrows.appendChild(STtableHeader);
STrows.appendChild(STheadRow);
	
}//end function addFieldHeaders
//ReferenceError: Can't find variable: STtableHeader
//function to remove fieldHeaders
//error:NotFoundError: The object can not be found here.
//NotFoundError: The object can not be found here.Jan30

function removeHeadRow () {
	while (STheadRow.firstChild) {
		STheadRow.removeChild(STheadRow.firstChild);
	}//end while
}//end function removeHeadRow

function removeFieldHeaders () {
	console.log('Removing Field Headers (STHeadRow)');	//STtableHeader.setAttribute('class','attentionBtn');
//STrows.removeChild(STtableHeader);
STrows.removeChild(STheadRow);
}//end function to removeFieldHeaders

//function to clear table screen
function clearTableRows () {
	console.log('Clearing table rows in order to repopulate.');
	while (STrows.firstChild) {
   STrows.removeChild(STrows.firstChild);
	}//end while
}//end function clearTableRowns

//function trI’m STHeadRow to original four field headings
function trimHeadRow () {
	console.log('Trim Field Headers back to original 4 fields before tacking on extra fields.(STHeadRow.fithChild)');
	
	while (STheadRow.fourthChild) {
   STheadRow.removeChild(STheadRow.fourthChild);
	}//end while
}//end function trimHeadRow

function resetFieldDisplay () {
	clearTableRows();
			
			addFieldHeaders();
			trimHeadRow();
			
	}//end function resetFieldDisplay
	

function clearHeadRow () {
console.log('clearing head row');	document.getElementById("STheadRow").innerHTML = "";
}

function removeDynamicFields () {
	console.log('Removing Dynamic Fields');
  var row = document.getElementById("STheadRow");
  for (let i = originalNumberOfFields;i>4;i--) {
  row.deleteCell(-1);
  //TypeError: null is not an object (evaluating 'row.deleteCell')
}//end for i =
}//end 

//function below never called remove??
function deleteFirstRow() {
  document.getElementById("STforRows").deleteRow(0);
}

function myCreateFunction() {
  var table = document.getElementById("myTable");
  var row = table.insertRow(0);
  var cell1 = row.insertCell(0);
  var cell2 = row.insertCell(1);
  cell1.innerHTML = "NEW CELL1";
  cell2.innerHTML = "NEW CELL2";
}

function myDeleteFunction() {
  document.getElementById("myTable").deleteRow(0);
}
//LEFT OFF HERE NOV 26
function editMoreFields () {
//called by editBtn.onclick	
    //  const addToDynamicFields = document.createElement('p');//referenced with createTable elements  above
	  addToDynamicFields.textContent = 'How many more fields do you wish to ADD to current number of Dynamic Fields?';
	//  const moreFieldsInput = document.createElement('input');
	//  const fieldsBtn = document.createElement('button');
	  fieldsBtn.setAttribute('class','attentionBtn');
	  fieldsBtn.textContent = 'ENTER!';
	 addToDynamicFields.appendChild(moreFieldsInput);
	 addToDynamicFields.appendChild(fieldsBtn);
	 createTableWindow.appendChild(addToDynamicFields);
	 addToDynamicFields.setAttribute('class','borderBlink')
	//  //flash border add to fields
	// var flashingOn = setInterval(flashOn,1000);
	// var flashingOff = setInterval(flashOff,2000);	
	// function flashOn () {
	// 	addToDynamicFields.setAttribute('class','flashBorder')
	// }//end function flashOn
	
	// function flashOff () {
	// 	addToDynamicFields.setAttribute('class','hideFlashBorder')
	// }//end function flashOff
	//   //flash border add to fields
	 
	 fieldsBtn.onclick =  function() {
		 // clearTimeout(flashingOn);
		 // clearTimeout(flashingOff);
		 // if(moreFieldsInput.value = "") {
			//  moreFieldsInput.value = "0";
			//  alert("No new dynamic fields will be added. (Same as entering 0");
		 // }//end if moreFieldsInput.value=""
		 
		 moreFields = moreFieldsInput.value;
		let addFields = Number(moreFields); 
		  console.log('addFields = ' + addFields);
		dynamicFieldTotal = Number(numberOfDynamicFields) + Number(addFields);
console.log('dynamicFieldTotal = ' + dynamicFieldTotal);	
	 numberOfDynamicFields = Number(numberOfDynamicFields) + Number(moreFields);
	// At editMoreFields. numberOfDynamicFields = NaN
	 console.log('At editMoreFields. numberOfDynamicFields = '+ numberOfDynamicFields);
	additionalFields.value = numberOfDynamicFields;  
	
	//alertx("In editMoreFields after adding more fields post edit: — numberOfDynamicFields = " + numberOfDynamicFields);
	
	console.log("In editMoreFields after adding more fields post edit: — numberOfDynamicFields = " + numberOfDynamicFields);
	
submitBtn.setAttribute('class','attentionBtn');
submitBtn.disabled = false;

//clear moreFieldsInput.value in prep for next edit Sept16
moreFieldsInput.value = "";

createTableWindow.removeChild(addToDynamicFields);

//code to disable goToHomeScreen btn so table is not messed up if user taps returnToHome screen after having entered a number into the add dynamic fields input..forces finish of this process
goHomeBtn.disabled = true;
  }//end FieldsBtn.onclick
}//end editMoreFields function

//remove editMoreFieldsElements
function removeEditMoreFieldsElements () {
	addToDynamicFields.removeChild(moreFieldsInput);
	 addToDynamicFields.removeChild(fieldsBtn);
	 createTableWindow.removeChild(addToDynamicFields);
	
}//end removeEditMoreFieldsElements function


//setTable called from displayData() to trim table arrays

//refine set table to allow for links

function settingTable (cursor,counter) {
	//console.log('In settingTable paraBody[counter -1] = ' + paraBody[counter -1]);
	//alert('paraBody[counter -1] = ' + paraBody[counter -1]);
	if (paraBody[counter -1].indexOf('http'||'https'||'www')!== -1) {
	paraBody[counter -1] = paraBody[counter -1];//if contains a link leave intact
	linked = true;	
	setParaBodyTable(cursor,counter);
	}//end if indexOf'http'!== -1
	else {
		linked = false;
		setParaBodyTable(cursor,counter);//if no link, remove everything after a colon if there is a colon
		
	}//end if else paraBody[counter]
	
if (displayXtraFieldData[counter -1].indexOf('http'||'https'||'www') !== -1) {
	displayXtraFieldData[counter -1] = displayXtraFieldData[counter -1];//leave link alone
	linked = true;	
	setDisplayXtraFieldDataTable(cursor,counter);
} else {
	linked = false;	setDisplayXtraFieldDataTable(cursor,counter);
}//end  if else displayXtraFieldData[counter.indexOf http


//}//end function setting table put after function setTable or displayXtra????


function setParaBodyTable (cursor,counter) {
//console.log('In setParaBodyTable function. paraBody[counter-1] = ' + paraBody[counter-1]);	
let colonB = paraBody[counter -1].indexOf(':');

if(!linked){
	//console.log('No link');
if (colonB === -1) {
	//console.log('No link and no colon so paraBody = ' + paraBody[counter -1]);
	paraBody[counter -1] = paraBody[counter -1];
} else {
	
	paraBody[counter -1] = paraBody[counter -1].slice(0,colonB);
	//console.log('No link but there is a colon so paraBody is trimmed = ' + paraBody[counter -1]);

}//end if else colonB = -1
}//end if(!linked)


if(linked){
	//console.log('There is a link so there is also at least one colon in http://');
	if (colonB === -1) {
		//console.log('SHOULD NOT BE HERE BECAUSE THERE IS A COLON IN THE LINK!');
	paraBody[counter -1] = paraBody[counter -1];//no colon keep everything
} else {
	//console.log('There is a link also at least one colon in http:// so leave paraBody intact and deal with it in displayTable(). For interest I kept a record of the preceding note in keepTableNote[counter -1]');
	//keepTableNote[counter -1] = paraBody[counter -1].slice(0,colonB);
	
	//paraBody[counter -1] = paraBody[counter -1].slice(0,colonB);
	paraBody[counter -1] = paraBody[counter -1];
//this won't work because paraBody just becomes the same as keepTableNote
//re-set linked flag back to false for next go
//linked = false;

}//end if else colonB = -1
	
//re-set linked flag back to false for next go
linked = false;	
}//end if(linked)
}//end function setParaBodyTable
//DISPLAY TABLE WILL NOW DO THE REST TO PREPARE THE TABLE…NOTHING TO DO WITH NOTES

function setDisplayXtraFieldDataTable (cursor,counter) {
	console.log('In setDisplayXtraFieldDataTable function. displayXtraFieldData[counter -1] = ' + displayXtraFieldData[counter -1]);	
let colonD = displayXtraFieldData[counter -1].indexOf(':');

if(!linked){
	//console.log('No link');
if (colonD === -1) {
	//console.log('No link and no colon so displayXtraFieldData[counter -1] = ' + displayXtraFieldData[counter -1]);
	displayXtraFieldData[counter -1] = displayXtraFieldData[counter -1];
} else {
	
displayXtraFieldData[counter -1] = displayXtraFieldData[counter -1].slice(0,colonD);

//console.log('No link but there is a colon so displayXtraFieldData[counter -1] is trimmed = ' + displayXtraFieldData[counter -1]);

	}//end if colonD = -1
}//end if(!linked)

if(linked) {
	//console.log('There is a link so there is also at least one colon in http://url');
if (colonD === -1) {
	//console.log('SHOULD NOT BE HERE BECAUSE THERE IS A COLON IN THE LINK!');
	displayXtraFieldData[counter -1] = displayXtraFieldData[counter -1];//no : keep everything
} else {
	//console.log('There is a link also at least one colon in http:// so leave displayXtraFieldData[counter -1] intact and deal with it in displayTable(). For interest I kept a record of the preceding note in keepTableNote[counter -1]');
//keepTableNote[counter -1] = displayXtraFieldData[counter -1].slice(0,colonD);

displayXtraFieldData[counter -1] = displayXtraFieldData[counter -1];
//re-set linked flag back to false for next go
//linked = false;

}//end if colonD = -1	
	
//re-set linked flag back to false for next go
linked = false;	
}//end if linked


}//end function setDisplayXtraFieldDataTable
//DISPLAY TABLE WILL NOW DO THE REST TO PREPARE THE TABLE…NOTHING TO DO WITH NOTES

//Also, if you know that you want to extract all of the remaining characters in a string after a certain character, you don't have to include the second parameter! Instead, you only need to include the character position from where you want to extract the remaining characters in a string. Try the following:
	//browserType.slice(2);
	
	//let extractedTitle = tableTitle[counter-1].slice(indexOf('>'));

}////end function setting table put after function setTable or displayXtra????

//code to delete fields in table
//see references above at 
function deleteTableField() {
deletingTableField = true;//don't know where to make this false so I just left it true!!!! Mar18 2022 seems to work!flag to fire code in displayTable to reset field headers
	myFields.onclick = function(){submitFieldSelectionBtn.setAttribute('class', 'attentionBtn');}
	fromDeleteField = true;//flag to ensure field headings displayed correctly
	console.log('Now in deleteTableField function. fromDeleteField now = ' + fromDeleteField);
//fieldHeaders is the div referenced in HTML	
fieldHeaders.appendChild(STtableHeader);
fieldHeaders.appendChild(STheadRow);

backToEditBtn.onclick = function (){
	submitFieldSelectionBtn.setAttribute('class', 'normalBtn');
	resetDataList();
	deleteFieldWindow.setAttribute('class', 'hidden');
	createTableWindow.setAttribute('class', 'showing');	
}//end backToEditBtn.onclick
cancelToNotesBtn.onclick = function () {
	submitFieldSelectionBtn.setAttribute('class', 'normalBtn');
	resetDataList();
	deleteFieldWindow.setAttribute('class', 'hidden');
	createTableWindow.setAttribute('class', 'hidden');
	fromDeleteField = true;
	//trimHeadRow();
	removeFieldHeaders();//to keep dynamic fields from appending after a deleteField call
	//displayedTable=1;
	console.log('cancelToNotesBtn has been clicked. You should now see notes screen. fromDeleteField = ' + fromDeleteField);
}//end cancelToNotesBtn.onclick
//create list of fields
//so first field is not chosen set j=1 instead of 0 ..ONLY DYNAMIC FIELDS CAN BE REMOVED SO SET J=4!,!
for(let j=4;j<numberOfFields;j++) {
				console.log('fieldNamesArray[' +j+ '] = ' + fieldNamesArray[j]);
				const fieldOption = document.createElement('option');
	fieldOption.value = fieldNamesArray[j];	
	dataList.appendChild(fieldOption);
			}//end for j =
			
	//remove if messes up Feb 27 trying to show after submit!
	chosenFieldInfo.textContent = 'You have selected the Field labelled: ' + myFields.value +' to REMOVE!';
	
	submitFieldSelectionBtn.onclick = function() {
		submitFieldSelectionBtn.setAttribute('class', 'normalBtn');
		chosenFieldInfo.textContent = 'You have selected the Field labelled: ' + myFields.value +' to REMOVE!';
		if (window.confirm("Do you really want to DELETE : " + myFields.value +  " ? CANCEL will UNDO")) {
			
			let chosenField = myFields.value;
  			editTableArray(chosenField);
			//put resetDataList after call to editTableArray to preserve value of myFields.value
			resetDataList();
			//keep track of SAVE Btn Feb 26. Note here it might be better to reactivate the saveVariables statement down below..while TESTING...
			
			blockEdit = true;//flag to prevent savedTablesArray getting messed up prevent dblClick edit of td cell if just finished editing layout of table via editBtn.onclick..because otherwise tableArray will no longer be in newTable mode and savedTablesArray will get messed up DOES NOT SEEM TO WORK AFTER A SAVE POST DELETE FIELD.Mar1 2022
			saveTableBtn.setAttribute('class', 'colorBtn');
			saveTableBtn.textContent = 'SAVE !';
			saveTableBtn2.setAttribute('class', 'colorBtn');
			saveTableBtn2.textContent = 'SAVE !';
			flipMenu.setAttribute('class','colorBtn');
			$("#flip").css({"background-color": "yellow", "border-color": "red"});
			
			
			
			} else {
				//return to edit screen
				deleteFieldWindow.setAttribute('class', 'hidden');
					resetDataList();	createTableWindow.setAttribute('class', 'showing');	
			}//end if window.confirm else ...
	}//end submitFieldSelectionBtn.onclick
	
	function editTableArray (chosenField) {
	//alert('code for editTableArray function goes here');
	console.log('tableArray prior to edit =  ' + tableArray);
	//copyOfTableArray = tableArray.slice();//date: Feb 5..this should be tableArray.slice(0)??
	console.log('fieldNamesArray prior to edit = ' + fieldNamesArray);
	//remove selected field
	console.log('cleared alert.. in field deletion! chosenField = ' + chosenField);
	let fieldNamesArrayIndex = fieldNamesArray.indexOf(myFields.value);
	
console.log('myFields.value = ' + myFields.value);
console.log('fieldNamesArrayIndex = ' + fieldNamesArrayIndex);
//fieldNamesArrayIndex = -1
console.log('fieldNamesArray[fieldNamesArrayIndex] = ' + fieldNamesArray[fieldNamesArrayIndex]);

let removedField = fieldNamesArray.splice(fieldNamesArrayIndex,1);
console.log('removedField = ' + removedField);
//removedField= removedField = Deceleration 
console.log('fieldNamesArray = ' + fieldNamesArray);
for(let j=0;j<fieldNamesArray.length;j++) {
				console.log('fieldNamesArray[' +j+ '] = ' + fieldNamesArray[j]);
				
			}//end for j =
			
//edit tableArray
//copy Array if needed



for (let i = 0;i<tableTitle.length;++i) {

let removedItem = tableArray[i].splice(fieldNamesArrayIndex, 1) // this is how to remove an item

}//end for i

console.log('tableArray = ' + tableArray);
console.log('copy of original tableArray = ' + copyOfTableArray);
			
//end edit tableArray
//now recreate table
deleteFieldWindow.setAttribute('class', 'hidden');
numberOfFields = fieldNamesArray.length;
numberOfDynamicFields = numberOfDynamicFields - 1;
while (STrows.firstChild) {
    STrows.removeChild(STrows.firstChild);
	}//end while	

displayedTable = 0;
refreshed = 0;

STtableHeader.textContent = dbTableName.value;
if(!loadFromTableOptions) {
dataVobj.tableArray = tableArray;
	}//end if(!loadFromTableOptions)
		console.log('At saving current table values! and going to saveVariables. dataVobj.tableArray = ' + dataVobj.tableArray);
	//WHILE TESTING DISABLED SAVEVARIABLES
//	saveVariables();//may not need because displayedTable also leads to saveVariables Feb 2 ?

//editCurrentTable === 1;
//removeFieldHeaders();
//NotFoundError: The object can not be found here.
fieldDeleted = true;
//refreshed=1;//flag REMOVE IF DOESN'T WORK
//while (STrows.firstChild) {
 //   STrows.removeChild(STrows.firstChild);
//	}//end while	
changeDBtable();//to keep field names from getting messed up Date: Feb13
displayTable();
//preserve changes for newTable prior to save
if(loadFromTableOptions) {
	savedTablesArray[loadTableIndex]=tableArray.slice();
	newTableFieldsArray = fieldNamesArray.slice();
	numberOfNewTableAddedFields = numberOfDynamicFields;
	
newTableSpecificVariables[loadTableIndex][1] = newTableFieldsArray.slice();
newTableSpecificVariables[loadTableIndex][2] = numberOfDynamicFields;
	
	alert("deleteFields completed: tableArray = " + tableArray + ". loadTableIndex = " + loadTableIndex + ". savedTablesArray: savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + "newTableFieldsArray = " + newTableFieldsArray + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1]);
	
	//should I update newTableSpecificVariables here??
	
}//end if loadTableFromOptions


}//end function editTableArray


//function to cLear and reset dataList
	function resetDataList () {
		//remove if messes up Feb 27
		chosenFieldInfo.textContent = 'You have selected the Field labelled: ' + myFields.value +' to REMOVE!';
		myFields.value = "";
		while (dataList.firstChild) {
   dataList.removeChild(dataList.firstChild);
		}//end while
	}//end function resetDataList


}//end function deleteTableField

//end of code to delete fields in table

function getDateString(n) {
 var d = new Date();
 //TypeError: d.toDateString is not a function. (In 'd.toDateString()', 'd.toDateString' is undefined)HAVE TO USE newDate function that rebuRns a date object!
  var n = d.toDateString();
 // document.getElementById("demo").innerHTML = n;
 return n;
}

//start function getRecordId used in displayTable edit TD cell
function getRecordId (i) {
	console.log('In getRecordId function. tableArray [' + i + '][0] = ' + tableArray[i][0]);
		let endIndex = tableArray[i][0].indexOf(">");
		let editRecordId = tableArray[i][0].slice(0,endIndex);
		console.log('endIndex = '+ endIndex + '. editRecordId = ' + editRecordId );
		console.log('tableArray[' +i + '][0]  after slice  now =' + tableArray[i][0]);
		//ReferenceError: Can't find variable: recordId
	//	console.log('calling function editNotesDate' + '. recordId = ' + recordId + '. endIndex = ' + endIndex);
		return editRecordId;
	}//end function getRecordId
	//start function getRecordId used in displayTable edit TD cell
	
	
//function editNotesRecord to edit date change in notes after editing date in table
function editNotesRecord(recordId,editedTDchange,c) {
	console.log('In function editNotesRecord. recordId = '+ recordId);
let noteId = Number(recordId);
//let editedDate = dateSelect.value;
console.log('noteId = ' + noteId + '. editedTDchange = ' + editedTDchange);
//noteId = 3. editedDate = 1
let transaction = db.transaction([objectStoreName], 'readwrite');

let objectStore = transaction.objectStore(objectStoreName);

let request = objectStore.get(noteId);
//Date:Jan29 DataError: Failed to execute 'get' on 'IDBObjectStore': The parameter is not a valid key.
//var request = objectStore.get();noteId = 3 and this was deleted in this dB. Have to parse tableArray[i][c] to get the date
request.onerror = function(event) {
  // Handle errors!
  console.log("edit failed");
};//end request.o error
request.onsuccess = function(event) {
	//original note in data variable
	var data = event.target.result;
	//create the tools for doing the edit
	console.log('Will edit item # ' + data.id + '. data.title = ' + data.title + ' ' + data.created + ' , ' + data.body);
	//reference editTitle input this works
	//changed data.title = editedTDchange to data.title = noteId + '> ' + editedTDchange NO DON'T HAVE data.title is just the title, not id
if(c===0) {data.title = editedTDchange}
console.log('data.title now = ' + data.title);
if (c===1) {data.created = editedTDchange}
if (c===2) {data.body = editedTDchange}
if (c===3) {data.xtraField = editedTDchange}


var requestUpdate = objectStore.put(data);
//};//end request.onsuccess ?might have to move to end of function?
   requestUpdate.onerror = function(event) {
     // Do something with the error
	 editBanner.textContent = 'Whoops! ERROR! Transaction now inactive!'
   };
   requestUpdate.onsuccess = function(event) {
     // Success - the data is updated!
	 console.log("The record is updated!");
	 };
	 
 };//end request.onsuccess ?might have to move to end of function?
 }//end function editNotesDate(i,c) 
 
 //SORT TABLE FUNCTION - START
 function sortTable () {
 // const viewSortBtn = document.createElement('button');//scope includes the sort function
 sortWindow.appendChild(viewSortBtn);
	viewSortBtn.setAttribute('class','attentionBtn');
	viewSortBtn.textContent = 'VIEW the SORTED TABLE';
	viewSortBtn.style.display = "none";
//const variable references are modelled after delete field code .. go to just ABOVE NewBtn.onclick all placed at top as global variables
//const sortOption = document.createElement('option');
console.log('In sort table function');
	sortWindow.setAttribute('class','showing');
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	sortWindow.style.backgroundColor = "black";
	sortWindow.style.color = "white";
} else {
	sortWindow.style.backgroundColor = "#eee";
	sortWindow.style.color = "black";
}//end if else screenDark
	
//these variables are referenced at top as global variables
//const selectedSortInput = document.querySelector('#sortType');
// const sortTypeDataList = document.querySelector('#sortTypeList');
const chosenSortInfo = document.querySelector('#chosenSort');
const submitSortTypeSelectionBtn =  document.querySelector('#submitSortTypeSelection');
	//const cancelToNotesFromSortBtn = document.querySelector("#cancelToNotesFromSort");//referenced twice one global!!

	cancelToNotesFromSortBtn.onclick = function (){
	viewSortBtn.style.display = "none";
	//sortWindow.removeChild(viewSortBtn);
//if running a new table savedOriginal will have run and therefore reset fromContacts will get real values in tablArray, but if newTable code has not run then resetFromContacts gets undefined values so don't run resetFromContacts if just running DB main table
	if(makeContactsTable || loadFromTableOptions) {
		resetFromContacts();//so refresh code in tableOptionsScrn does not activate when switching tables
		resetFields = true;//to keep field headers from messing up after a cancel in sort of a new table added Mar28
	}//end if makeContactsTable || loadFromTableOptions
	sortWindow.setAttribute('class','hidden');
		}//end canceLToNotesFromSortBtn.onclick
			
	const backToTableFromSortBtn = document.querySelector("#backToTableFromSort");
	backToTableFromSortBtn.onclick = function (){
		sortWindow.setAttribute('class','hidden');

		showTable.setAttribute('class', 'showing');
	 	}//end backToTableFromSortBtn.onclick
		
	const sb = document.querySelector('#chooseSortType');
	submitSortTypeSelectionBtn.onclick = (event) => {
		event.preventDefault();
            // show the selected index
           // alert(sb.selectedIndex);
		console.log('selectedSortType = ' + sb.value);
		
		if (window.confirm("Sort type chosen is : " +  sb.value +  "\n \n CANCEL will UNDO")) {
		viewSortBtn.style.display = "unset";
	//LEFT OFF HERE MAR 9		
			let chosenSort = sb.selectedIndex;
			let typeSort = sb.value;
			console.log('typeSort = ' + typeSort + ' sb.value = ' + sb.value);
  			sortTableArray(chosenSort,typeSort);
			//put resetDataList after call to editTableArray to preserve value of myFields.value
			resetSortDataList();
			//keep track of SAVE Btn Feb 26. Note here it might be better to reactivate the saveVariables statement down below..while TESTING...

			} else {
				//return to edit screen
			viewSortBtn.style.display = "none";	sortWindow.setAttribute('class', 'hidden');
					resetSortDataList();	showTable.setAttribute('class', 'showing');	
			}//end if window.confirm else ...
		};//end submitSortTypeSelectionBtn.onclick
		
  }//end sortTable function
	
function sortTableArray (chosenSort,typeSort) {
		console.log('In sortTableArray function. sortType = ' +  chosenSort);
		//Mar 10 copy only occurs at the CreateTable screen, otherwise it is the sorted array that is always copied. If Ever saved though then the original order will still be lost
		//copyOfTableArray = tableArray.slice();
		//copyOfTableTitle = tableTitle.slice();
		chosenSortInfo.textContent = 'You have selected : ' + typeSort + ' as the SORT type!';
		console.log('tableArray before slice =    ' + tableArray);
		//trim off ,,,,,,
		//tableTitle.length should be ok for sort of contacts because tableTitle.length was set to selectedContact.length in the makeContactTable section Jan1
		tableArray = tableArray.slice(0,tableTitle.length);
		console.log('tableArray after slice =    ' + tableArray);
		
		//DATE: JAN28 2022 tableArray AFTER SAVE OF CONTACTS BTN IS NOW ORIGINAL DB EVEN THOUGH AT THIS POINT THE CONTACTS ARE SHOWING ON THE SCREEN! But the point is on returning to original sort order the data in tableArray will be original db NOT contacts!!!! THE ALPHABETICAL SORT WORKS AT THIS STAGE BECAUSE IT USES THE DOM AND STROWS FOR SWITCHING INTO ALPHA ORDER! (table = document.getElementById("STforRows");) Wow complicated eh! Now lets see if makeContactsTable variable got messed up in setupContactsTable function 
		if(chosenSort === 0) {
			originalOrder = false;//flag used to prevent accidental loss of original table order by a save after a sort
			sortTableW3();
			//let startPos = tableArray[1].indexOf('>');
			//console.log('startPos = ' + startPos);
			//let startTitle;
			//let startTitle = tableTitle[1].indexOf('>');
			//console.log('startTitle = ' + startTitle);
			// for(let i = 0;i<tableTitle.length;i++) {
			// 	//let startTitle = tableTitle[i].indexOf('>')//to clear the numbers to make an alpha sort, remove the first field.;
			// 	tableArray[i] = tableArray[i].slice(1);
			// 	//clear the numbers from the first field might need indexOf > here? 3 will leave a blank space in records 10 and over
			// 	tableTitle[i] = tableTitle[i].slice(3);
			// 	tableArray[i] = tableTitle[i] +',' + tableArray[i];
			// 	//concatenate tableTitle array with tableArray, but also add the , which was lost in first step.
			// 	//LEFT OFF HERE MAR 12 LOST THE COMMA SEPARATOR FOR FIRST FIELD!I THINK ABOVE LINE SHOULD READ: tableArray[i] = tableTitle[i] + ',' + tableArray[i];
			// }//end for i
			
			// // tableArray = tableArray.slice(startPos + 1,tableTitle.length);
			// // tableTitle = tableTitle.slice(2,tableTitle.length);
			// //now tableArray has the record numbers removed allowing an alpha sort. BUT need a sort back to original to restore the record numbers which I assume necessary for searches, edits etc?
			// tableArray = tableArray.sort();
			// tableTitle = tableTitle.sort();
			// console.log('tableArray in alphabetical order = ' + tableArray);
			// console.log('tableTitle in alphabetical order = ' + tableTitle);
		}//end if chosenSort === 0
		
		if (chosenSort === 1) {
			originalOrder = false;//flag used to prevent accidental loss of original table order by a save after a sort
			tableArray = tableArray.reverse();
			//tableTitle was not created for contacts. ? Do I need it?
			tableTitle = tableTitle.reverse();
			console.log('tableArray reversed = ' + tableArray);
		}//end if chosenSort = 1
		
		if (chosenSort === 2) {
			originalOrder = true;//flag used to prevent accidental loss of original table order by a save after a sort
			console.log('copyOfTableArray = ' + copyOfTableArray);
	tableArray = copyOfTableArray.slice();
	//HERE TABLE Title will be original so a new tableTitle.length will not reflect the contacts list but do I need this? PROBABLY DO BECAUSE DISPLAY TABLE USES TABLEtitle array?
	tableTitle = copyOfTableTitle.slice();
	console.log('tableArray returned to original  =  ' + tableArray);
		}//end if chosenSort = 
		
	//experiment with alpha sort
	if (chosenSort === 3) {
		originalOrder = false;//flag used to prevent accidental loss of original table order by a save after a sort
		sortTableW3();
	// tableArray = tableArray.sort(0);
	// //TypeError: Array.prototype.sort requires the comparsion function be a function or undefined
	// tableTitle = tableTitle.sort();
	// 		console.log('tableArray experimental in alphabetical order = ' + tableArray);
	// 		console.log('tableTitle in alphabetical order = ' + tableTitle);	
		
		
	}//end of chosedSort = 3
	
		
	
	// const viewSortBtn = document.createElement('button');//made global to function sort
	// sortWindow.appendChild(viewSortBtn);
	// viewSortBtn.setAttribute('class','attentionBtn');
	// viewSortBtn.textContent = 'VIEW the SORTED TABLE';
	viewSortBtn.onclick = function () {
		sortWindow.removeChild(viewSortBtn);
		sortWindow.setAttribute('class', 'hidden');
		showTable.setAttribute('class', 'showing');	
		//flag to disable SAVE Btn
	fromViewSort = true;
		//should this be refreshTable?
		//displayTable();
		if(!sortW3) {
		
			//alertx("Restoring sort: makeContactsTable = " + makeContactsTable + ".  loadFromTableOptions = " + loadFromTableOptions);
			console.log("Restoring sort: makeContactsTable = " + makeContactsTable + ".  loadFromTableOptions = " + loadFromTableOptions);
			
			
			if(makeContactsTable || loadFromTableOptions) {tableTitle.length=newTableContactsTitleLength}//end if makeContactsTable
		//	makeContactsTable is true and loadFromTableOptions is FALSE when coming back from alpha sort!AFTER USING CONTACTS BTN 
		//loadFromTableOptions is TRUE after alpha sort when comijng from loadFromTableOptions and the rstore WORKS!
//NOTETHAT IN SAVE copyOfTableArray is made = tableArray so this might mess up?
		refreshTable();
		//set tableTitle.length to reflect contacts if in a contacts table
		
		}//end if !sortW3
	sortW3 = false;	
	}//end of viewSortBtn.onclick
	}//end sortTableArray function
	
	function resetSortDataList () {
		console.log('In reset sortDataList function..which you might not need because not a dynamic list!');
	}//end resetSortDataList function
	//end edit dataList code
		
 //HTML Sort function from W3Schools
 function sortTableW3() {
	 sortW3 = true;//flag to show table sorted by HTML and not go to refreshTable
   var table, rows, switching, i, x, y, shouldSwitch;
   let xString = '';
   let yString = '';
  table = document.getElementById("STforRows");
  switching = true;
  /*Make a loop that will continue until
  no switching has been done:*/
  while (switching) {
    //start by saying: no switching is done:
    switching = false;
    rows = table.rows;
    /*Loop through all table rows (except the
    first, which contains table headers):*/
    for (i = 1; i < (rows.length - 1); i++) {
      //start by saying there should be no switching:
      shouldSwitch = false;
      /*Get the two elements you want to compare,
      one from current row and one from the next:*/
      x = rows[i].getElementsByTagName("TD")[0];
      y = rows[i + 1].getElementsByTagName("TD")[0];
      //check if the two rows should switch place:create string to strip row numbers

	  
	 xString = x.innerHTML.toLowerCase();
	 yString = y.innerHTML.toLowerCase();
	 console.log('xString = ' + xString);
	 console.log('yString = ' + yString);
	 //strip row numbers
	 let posX = xString.indexOf('; ')+1;
	 let posY = yString.indexOf('; ')+1;
	 console.log('posX = ' + posX);
	 console.log('posY = ' + posY);
	 xString = xString.slice(posX);
	 yString = yString.slice(posY);
	 console.log('xString = ' + xString);
	 console.log('yString = ' + yString);
	 
	 
	 
	// alert('Stop!') ;
	 if (xString>yString) {
        //if so, mark as a switch and break the loop:
        shouldSwitch = true;
        break;
      }
    }
    if (shouldSwitch) {
      /*If a switch has been marked, make the switch
      and mark that a switch has been done:*/
      rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
      switching = true;
    }
  }
}
 //END SORT TABLE FUNCTION
 
 //scroll window function
 function scrollWin() {
	 alert('scrolling');
  window.scrollBy(0, 100);
}//end scroll window function

function topFunction() {
 document.body.scrollTop = 0; // For Safari
 document.documentElement.scrollTop = 0; //0 For Chrome, Firefox, IE and Opera
 }//end function topFunction
 
 //function initialize table if first run
function initializeTable () {
	
	if(DTBtnTappedOnce ===0 & tableExists){
		alert('The pre-existing main table has to be initialized first before Searching, Adding, or Editing a note! OR if changing databases. Tap the DISPLAY TABLE button.');
		tableScreenOptions();
	}//end if if(DTBtnTappedOnce ===0 & tableExists)
}//end function initializeTable

//a delay function used in getDataBaseName to get value of setup before code continues from gitconnected THIS CODE IS NOT USED
function sleepUntil(f, timeoutMs) {
    return new Promise((resolve, reject) => {
        timeWas = new Date();
        wait = setInterval(function() {
            if (f()) {
                console.log("resolved after", new Date() - timeWas, "ms");
                clearInterval(wait);
                resolve();
            } else if (new Date() - timeWas > timeoutMs) { // Timeout
                console.log("rejected after", new Date() - timeWas, "ms");
                clearInterval(wait);
                resolve;//reject();
            }
        }, 20);
    });
}

//function backup database
function backupDataBase(dataBaseName) {
//alert("ln function backupDataBase .. reNamedDBFileName = " + reNamedDBFileName + " dataBaseName = " + dataBaseName);
//alert("In backupDataBase - dataBaseName = " + dataBaseName + " dataBaseName.length = " + dataBaseName.length + " dbName = " + dbName + " dbNameInfo.textContent = " + dbNameInfo.textContent);

	finishedShareBtn.style.display = "none";//otherwise being able to tap this btn now highlights the textarea
	
	textarea.style.display = "unset";
	
	//THE FOLLOWING CODE PUTS THE SELECTED DATABASE TO BACKUP INTO THE VARIABLE json AS A JAVASCRIPT OBJECT NOTATION. 
	//alert('in function backup database?: ' + dataBaseName);
	let string = "";
	backingUpDBWin.setAttribute('class','showing');
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	backingUpDBWin.style.backgroundColor = "black";
	backingUpDBWin.style.color = "white";
	dbNameInfo.style.color = "black";
} else {
	backingUpDBWin.style.backgroundColor = "#eee";
	backingUpDBWin.style.color = "black";
	//dbNameInfo.style.color = "black";
}//end if else screenDark
	if(reNamedDBFileName) {
		dbNameInfo.textContent = renamedFileName;
	}//end if reNamedDBFileName
	else {
	dbNameInfo.textContent = dataBaseName;
	}//end if(reNamedDBFileName) {
	
	backingUpBanner.appendChild(dbNameInfo);
	
	const shareBtn = document.querySelector('#shareBtn');
	shareBtn.disabled = true;
	shareBtn.style.display = "none";
	const doneCopyBtn = document.querySelector('#doneCopy');
	doneCopyBtn.style.display = "none";
	const copyClipboardBtn = document.querySelector('#copyClipboardBtn');
	copyClipboardBtn.setAttribute('class','attentionBtn');
	
	// const doneCopyBtn = document.querySelector('#doneCopy');
	
	//enable disable DONE btn in backup window
	//doneCopyBtn.disabled = true;
	//enable disable DONE btn in backup window
	// finishedCopyBtn = document.createElement('button');
	// finishedCopyBtn.textContent = 'DONE';
	// finishedCopyBtn.setAttribute('style','display: block');
	
	
	copyClipboardBtn.onclick = function () {
	doneCopyBtn.style.display = "unset";
	//if renaming filename do string manipulation here?
	
	if(reNamedDBFileName) {
	
	//alertbkup("At copyClipboardBtn..in reNamedDBFileName..should not be here!");
	
		//reNamedDBFileName = false;
		 string = manipulateString(string);
		//manipulateString(string)
		//string = "This is a test of rename db filename!"
		//alertrnf("Back from manipulateString() - string now = " + string);
	}//end if reNamedDBFileName
	
	// if(reNamedDBFileName) {
		
	// }//end if reNamedDBFileName
	//alert("copyClipBoardBtn.onclick - variable values: loadSampleDb = " + loadSampleDb + " dataAltered = " + dataAltered + " bkupAlertsFlag = " + bkupAlertsFlag + " dataNotBackedUp = " + dataNotBackedUp + " convertingOldFile = " + convertingOldFile + " string = " + string);
	
	copyToClipboard(string);	copyClipboardBtn.setAttribute('class','normalBtn');
	// doneCopyBtn.disabled = false;	doneCopyBtn.setAttribute('class','attentionBtn');
	//doneCopyBtn.disabled = false;
	doneCopyBtn.setAttribute('class','attentionBtn');	
		textarea.setAttribute('class','colorBtn');
		console.log('In copyClipboardBtn.onclick function.  textarea.value = ' + textarea.value);
		//copyToClipboard(textarea.value);
		// copyInstructionP = document.createElement('p');
		// copyInstructionP.textContent = ' Now SAVE (PASTE) THE CLIPBOARD CONTENTS TO WHATEVER EXTERNAL FOLDER YOU WISH TO USE TO STORE YOUR BACKUPS. When finished with the clipboard, tap DONE to return to HOME screen.';
		// backingUpDBWin.appendChild(copyInstructionP);
		//backingUpDBWin.appendChild(finishedCopyBtn);
		
		//this code better times the activation of the done btn by waiting for the textarea to be tapped on first
		// textarea.onclick = function() {
		// doneCopyBtn.disabled = false;	doneCopyBtn.setAttribute('class','attentionBtn');	
			
		// }//end textarea.onclick
		//this code above better times the activation of the done btn by waiting for the textarea to be tapped on first
		// copyToClipboard(string);
		// doneCopyBtn.onclick = function () {
		// 	//enable disable DONE btn in backup window
		// 	doneCopyBtn.disabled = true;
		// 	//enable disable DONE btn in backup window
		// 	doneCopyBtn.setAttribute('class','normalBtn');
		// 	textarea.setAttribute('class','normalBtn');
		// backingUpDBWin.removeChild(copyInstructionP);
		// //backingUpDBWin.removeChild(finishedCopyBtn);
		
		// backingUpDBWin.setAttribute('class','hidden');
		// backupFilesWin.setAttribute('class','hidden');
		// alert('The database named..' + dataBaseName + ' has been copied to the clipboard! You can now PASTE it into your external BACKUP storage file.');
			
		// }//end function finishedCopyBtn.onclick
	//alertbkup("End copy to clipboard btn tapped .. json = " + json);
		
	}//end copyClipboardBtn.onclick
	
	//textarea = textarea.innerHTML.value;
	//copyClipboardBtn.onclick = copyToClipboard(textarea.value);
	//textarea.value = textarea.innerHTML.value;
	//copyClipboardBtn.onclick = copyToClipboard(textarea.value);
//ReferenceError: Cannot access uninitialized variable.
		//WRAP A FUNCTION AROUND THIS CODE
	//WRAP A FUNCTION AROUND THIS CODE
	
	//OPEN THE DELECTED DATABASE FOR BACKINGUP AND PUT IT IN JSON OBJECT FORMAT
	
		var dbName = dataBaseName;//Feb17 this has to be dataBaseName at this point whether you renamed the database or not because we have to open the original database to work on it
var json;
//alertbkup("dbName = " + dbName);
//var textarea;
 // const textarea = document.querySelector('#textAreaClip')
//alert("Now will create json - About to open dbName - dbName = " + dbName + " dbName.length = " + dbName.length); 
;(async () => {
try {
//alert("At backups copy to clipboard export object— dbName = " + dbName);

  var dbExists = await new Promise(resolve => {
    var request = window.indexedDB.open(dbName)
    request.onupgradeneeded = e => {
   // alert("in backups onupgradeneeded..what am I doing here!! dbName = " + dbName + " dataBaseName = " +dataBaseName);
    
      e.target.transaction.abort()
      resolve(false)
    }
    request.onerror = () => resolve(true)
    request.onsuccess = () => resolve(true)
  })

  if (!dbExists) {
    throw new Error('Database does not exist')
  }

  var idbDatabase = await new Promise((resolve, reject) => {
    var request = window.indexedDB.open(dbName)
    request.onerror = () => reject('Could not open the database')
    request.onsuccess = () => resolve(request.result)
  })

  var json = await new Promise((resolve, reject) => {
    const exportObject = {}
    if (idbDatabase.objectStoreNames.length === 0) {
      resolve(JSON.stringify(exportObject))
    } else {
      const transaction = idbDatabase.transaction(
        idbDatabase.objectStoreNames,
        'readonly'
      )
  
      transaction.addEventListener('error', reject)
  
      for (const storeName of idbDatabase.objectStoreNames) {
        const allObjects = []
        transaction
          .objectStore(storeName)
          .openCursor()
          .addEventListener('success', event => {
            const cursor = event.target.result
            if (cursor) {
              // Cursor holds value, put it into store data
              allObjects.push(cursor.value)
              cursor.continue()
            } else {
              // No more values, store is done
              exportObject[storeName] = allObjects
  
              // Last store was handled
              if (
                idbDatabase.objectStoreNames.length ===
                Object.keys(exportObject).length
              ) {
                resolve(JSON.stringify(exportObject))
              }
            }
          })
      }
    }
  })

  console.log(' ')
  console.log('Database has been exported:')
  //alertbkup('Database has been exported: json = ' + json);
  console.log(' ')
 // console.log(json)
  //string won't = anything here? Because json has not yet been put into textArea?
// alert("DataBase has been exported - json = " + json); 
  //iosCopyToClipboard(textarea,json) PUTS json INTO THE TEXTAREA (el)
   string = textarea.value;
iosCopyToClipboard(textarea,json)

//NOW textArea = json after returning from iosCopyToClipboard function SO NOW MAKE string = textArea?

//copyClipboardBtn.onclick = copyToClipboard(textarea.value);
 //copyClipboardBtn.onclick = copyToClipboard(textarea.innerHTML.value);
 // copyToClipboard(json);
 //RETURNING FROM iosCopyToClipboard should have put json into textarea
  console.log(' ')
  string = textarea.value;
  console.log("returned from iosCopyToClipboard! string now = " + string );
//  alert("returned from iosCopyToClipboard! string now = " + string );
  
  //alertbkup("returned from iosCopyToClipboard! Which puts json into the textArea! string now = " + string + " json = " + json + " Now tapping copyClipboardBtn.onclick should put textarea content into the clipboard.");
  
  //alertrnf("at line 13452 string = " + string);
// copyToClipboard(textarea.value)
} catch(error) {
  console.error(error)//
}
})()

//copyClipboardBtn.onclick = copyToClipboard(textarea.value);
//}//end function backup database


// 	function copyToClipboard(string) {
//   const textarea = document.querySelector('#textAreaClip')
//   let result;

//   try {
//    // textarea = document.createElement('textarea');
//     textarea.setAttribute('readonly', true);
//     textarea.setAttribute('contenteditable', true);
//     textarea.style.position = 'fixed'; // prevent scroll from jumping to the bottom when focus is set.
//     textarea.value = string;

//    // document.body.appendChild(textarea);
// console.log('in copyToClipboard function. json = '+ json)
// console.log('in copyToClipboard function. textarea.value = '+ textarea.value)
//     textarea.focus();
//     textarea.select();

//     const range = document.createRange();
//     range.selectNodeContents(textarea);

//     const sel = window.getSelection();
//     sel.removeAllRanges();
//     sel.addRange(range);

//     textarea.setSelectionRange(0, textarea.value.length);
//     result = document.execCommand('copy');
//   } catch (err) {
//     console.error(err);
//     result = null;
//   } finally {
//     document.execCommand('copy');
// 	  //document.body.removeChild(textarea);
//   }

//   // manual copy fallback using prompt
// //   if (!result) {
// //     const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
// //     const copyHotkey = isMac ? '⌘C' : 'CTRL+C';
// //     result = prompt(`Press ${copyHotkey}`, string); // eslint-disable-line no-alert
// //     if (!result) {
// //       return false;
// //     }
// //   }
// //   return true;
//  }

//the el (element) is textArea so code below puts json into the textArea!
function iosCopyToClipboard(el,json) {
//alertrnf("In iosCopyToClipboard function");
//alert("In iosCopyToClipboard function");

	console.log('In iosCopyToClipboard function.')
    var oldContentEditable = el.contentEditable,
        oldReadOnly = el.readOnly,
        range = document.createRange();
el.textContent = json;
    el.contentEditable = true;
    el.readOnly = false;
    range.selectNodeContents(el);

    var s = window.getSelection();
    s.removeAllRanges();
    s.addRange(range);

    el.setSelectionRange(0, 999999); // A big number, to cover anything that could be inside the element.

    el.contentEditable = oldContentEditable;
    el.readOnly = oldReadOnly;   
console.log('in iosCopyToClipboard function. json = '+ json);
console.log("el.textContent = " + el.textContent);
textarea.value = json;
console.log('in iosCopyToClipboard function. textarea.value = '+ textarea.value);

//alert('in iosCopyToClipboard function. textarea.value = '+ textarea.value);
//el.textContent = json; in iosCopyToClipboard function. textarea.value =  above has made textArea = json!

 //success =   document.execCommand('copy');
 // //UNCOMMENTED LINES BELOW AUG 20
 // if(success) {alert('Success! Backup copied to clipboard.')}
 // if(!success) {alert('Whoops. document.execCommand Copy failed.')}

}// I THINK THIS IS END FUNCTION iosCopyToClipboard(el,json) ??

//NOW GOING BACK TO line 7195 +2?
	//WRAP A FUNCTION AROUND THIS CODE
		
		
//}//end function backup database
//copyToClipboard puts text-area into clipboard
function copyToClipboard(string) {
//alertrnf("In copyToClipboard function");
//alertrnf("at line 13549 string = " + string);
//alert("In copyToClipboard(string) - variable values: loadSampleDb = " + loadSampleDb + " dataAltered = " + dataAltered + " bkupAlertsFlag = " + bkupAlertsFlag + " dataNotBackedUp = " + dataNotBackedUp + " convertingOldFile = " + convertingOldFile + " string =" + string);
 // const textarea = document.querySelector('#textAreaClip') //Aug20
  let result;

  try {
   // textarea = document.createElement('textarea');
    textarea.setAttribute('readonly', true);
    textarea.setAttribute('contenteditable', true);
    textarea.style.position = 'fixed'; // prevent scroll from jumping to the bottom when focus is set.
    textarea.value = string;

   // document.body.appendChild(textarea);
//console.log('in copyToClipboard function. json = '+ json)
//console.log('in copyToClipboard function. textarea.value = '+ textarea.value);

    textarea.focus();
    textarea.select();

    const range = document.createRange();
    range.selectNodeContents(textarea);

    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    textarea.setSelectionRange(0, textarea.value.length);
    result = document.execCommand('copy');
  } catch (err) {
    console.error(err);
    result = null;
  } finally {
    document.execCommand('copy');
	  //document.body.removeChild(textarea);
	  //CODE TO CLEAR COPY RANGE
	 // sel.removeAllRanges();
	  textarea.value = "";
	  textarea.textContent = "";
  }//end function try?
}//END FUNCTION copyToClipboard? Moved from below!
  // manual copy fallback using prompt
//   if (!result) {
//     const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
//     const copyHotkey = isMac ? '⌘C' : 'CTRL+C';
//     result = prompt(`Press ${copyHotkey}`, string); // eslint-disable-line no-alert
//     if (!result) {
//       return false;
//     }
//   }
//   return true;
alert("Copying to Clipboard. On the next Backup screen, first tap the green highlighted button 'Click here first'. Then Tap DONE to return to Notes! DO NOT USE 'COPY' AGAIN UNTIL PROCESS IS COMPLETED SO AS NOT TO CORRUPT YOUR DATABASE DATA!");
//textarea.disabled = true;//so return to notes btn will work without highlighting selecting textarea Apr1

doneCopyBtn.onclick = function () {
//alert("doneCopyBtn.onclick clicked - variable values: loadSampleDb = " + loadSampleDb + " dataAltered = " + dataAltered + " bkupAlertsFlag = " + bkupAlertsFlag + " dataNotBackedUp = " + dataNotBackedUp + " convertingOldFile = " + convertingOldFile + " string = " + string);
//alertflm("reNamedDBFileName = " + reNamedDBFileName + " creationDONE = " + creationDONE);

if(reNamedDBFileName && creationDONE) {
//reNamedDBFileName = false;

		alert("The newly created database has had its '.creatingDB' extension stripped from its filename and has been copied to the clipboard. To complete the process RESTORE '" + renamedFileName + "' to DougieBase by 'PASTING from the clipboard' into the text-area element of the RESTORE section.");
		alert("DougieBase will automatically delete the file '" + dataBaseName + "' and all data remnants used in creating the new database (as this file has now been rendered dysfunctional) when the browser releases its lock on the file.");
		}//end if(reNamedDBFileName && creationDONE) {
else if(reNamedDBFileName && !creationDONE) {
	alert("The database has been renamed. ( " + renamedFileName + " ) When restored to DougieBase it will appear in the filename list with its new name. DougieBase will delete the original ( " + dataBaseName + " ) (as this file has now been rendered dysfunctional) when the browser releases its lock on it. WHEN THE FILENAMES LIST APPEARS SCROLL DOWN AND TAP THE FLASHING RESTORE BUTTON!");
	mustTapRestore = true;//flag to force scroll to bottom of fileNamesWindow
	}//END else if(reNamedDBFileName && !creationDONE) 
	
if(reNamedDBFileName || creationDONE) {
	mustTapRestore = true;//flag to force scroll to bottom of fileNamesWindow
	closeDataBase(dataBaseName);
// }//end if(reNamedDBFileName) 

//CODE HERE TO AUTOMATICALLY DELETE ORIGINAL DB ?
originalDBName = dataBaseName;//probably won't use originalDBName??
resetFields = true;//to avoid fields messed up after restore and view
//Replaced deleteOriginalDB(originalDBName); function with just deleteDataBase(originalDBName);
//alert("In doneCopyBtn.onclick if(reNamedDBFileName || creationDONE) going to deleteDataBase(dataBaseName) ..  dataBaseName = " +dataBaseName);
//deleteOriginalDB(originalDBName);
deleteDataBase(dataBaseName);
//Set these variables (used in filenamesInfoP) on return from automatic delete function just as is the case with manually tapping the delete file btn.. added Dec23 2023
// if(!dbDeleted1) {dbDeleted1 = true;dbDeletedName1 = dataBaseName;}
// 	else if(dbDeleted1) {dbDeleted2 = true;dbDeletedName2 = dataBaseName;
// 	}else if(dbDeleted2) {dbDeleted3 = true;dbDeletedName3 = dataBaseName;
// 	}else if(dbDeleted3) {dbDeleted4 = true;dbDeletedName4 = dataBaseName;}
// //CODE HERE TO AUTOMATICALLY DELETE ORIGINAL DB ?

//alertblk("After an autodelete and returning from deletedatabase:  blockedName[0] = " + blockedName[0]  + " dbDeleted[0] = " + dbDeleted[0] + " dbDeleted[1] = " + dbDeleted[1] + " dbDeleted[2] = " + dbDeleted[2] + " blocked[0] = " + blocked[0] + " blocked[1] = " + blocked[1] + " blocked[2] = " + blocked[2] + " dbDeletedName[0] = " + dbDeletedName[0] + " dbDeletedName[1] = " + dbDeletedName[1] + " dbDeletedName[2] = " + dbDeletedName[2]);


}//end if(reNamedDBFileName || creationDONE) 
	
			//enable disable DONE btn in backup window
		//	doneCopyBtn.disabled = true;
			//enable disable DONE btn in backup window
			
if(!creationDONE) {		
	shareBtn.disabled = false;
	shareBtn.style.display = "unset";
	}//end if(!creationDONE) 	
	
		doneCopyBtn.setAttribute('class','normalBtn');
			textarea.setAttribute('class','normalBtn');
			//textarea.setAttribute('class','hidden');
	//so return to notes and backup info p can be visualized..otherwise they are covered by textarea		
	textarea.style.display = "none";
	finishedShareBtn.style.display = "unset";//otherwise being able to tap this btn now highlights the textarea	
		//backingUpDBWin.removeChild(copyInstructionP);
		//copyInstructionP,textContent = "";
		//backingUpDBWin.removeChild(finishedCopyBtn);
	let nameOfDataBase = "";
	//alertrnf("nameOfDataBase = " + nameOfDataBase + " reNamedDBFileName = " + reNamedDBFileName);
	
if(!reNamedDBFileName) {
nameOfDataBase = dataBaseName;
//alertrnf("nameOfDataBase = " + nameOfDataBase);
}//end if(!reNamedDBFileName) {

if(reNamedDBFileName) {
nameOfDataBase = renamedFileName;
//alertrnf("nameOfDataBase = " + nameOfDataBase);
//REMEMBER renamedFileName WAS STRIPPED OF .bs in backup code
dbTableName.value = renamedFileName;
//saveVariables();//added Nov24 TEST BEFORE LEAVING THIS LINE! Does not work because idb looks for objectStoreName which has been changed by rename db and this db has not been loaded into DougieBase yet so the objectStoreName is not found from saveVariables when it tries to load in the newly named db
//MAYBE SCROLL TO BOTTOM FILENAMES SHOULD BE HERE.??
mustTapRestore = true;//flag to force scroll to bottom of fileNamesWindow
}//end if(reNamedDBFileName) {


//CODE BELOW IS NOT USED FOR CREATE NEW DATA BASE .. BUT IS USED FOR BACKUP AND RENAME FILENAMES	
if(!creationDONE) {
 //confirm choice window
	if (window.confirm("SHARE this database ( " + nameOfDataBase + " ) using the Share Sheet options" + " \n"  +  " ..tap OK \n\n" + "  CANCEL  will RETURN TO HOME SCREEN!")) {		
//CODE FOR SHARE SHEET
let variableText = "\n\nThe database data shown above needs to be copied and pasted into the text area window of the restore database section of DougieBase. You can install DougieBase by tapping on the link below. vv\n\n";

// const shareBtn = document.querySelector('#shareBtn');

//shareBtn.textContent = "SHARE database: " + dataBaseName;
shareBtn.setAttribute('class','borderBlink');
shareBtn.textContent = "SHARE database: " + nameOfDataBase;
//shareBtn.style.display = "unset";

//backingUpDBWin.setAttribute('class','showing');
//backingUpDBWin.appendChild(shareBtn);

const resultPara = document.querySelector('#resultPara');
//resultPara.style.display = "unset";
//const finishedShareBtn = document.querySelector('#finishedShare');

//backingUpDBWin.appendChild(resultPara);
//changed const shareData = { to JUST SHAREDATA  so shareData will change with each db shared!
shareData = {
    title: 'DougieBase database',
    text: 'If restoring from EMAIL: Copy and then Paste the '+ nameOfDataBase + ' database data  below into the textArea in the restore database section of DougieBase : \n\n\n' + string + variableText,
    url: 'https://trainee45.github.io/'
  }//shareData
  //alertx("In share this database: string = " + string + " dataBaseName = " + dataBaseName);
  //resultPara.textContent = 'Tap above to share Database: ' + dataBaseName ;
  resultPara.textContent = 'Tap above to share Database: ' + nameOfDataBase;
  // Share must be triggered by "user activation"why does variable nameOfDataBase change?
  
//  if (getFileNamesSwitch &!newDBflag) {
//getFileNames();

//	}//end if getFileNamesSwitch

  shareBtn.addEventListener('click', async () => {
  shareBtn.setAttribute('class','tdEdit');
  dataNotBackedUp = false;//added Mar 2 2023
  changeMonth = false;//in case comingfrom change month routine in new budget sheet
  //make sure bkup btns don't appear now because we are now backing up Mar11 2023
  backupBtn1.style.display = "none";
backupBtn2.style.display = "none";
  
    try {
      await navigator.share(shareData)
      resultPara.textContent = 'Last Database shared: ' + nameOfDataBase + ' shared successfully'
    } catch(err) {
      resultPara.textContent = 'Current status:' + err + ' OR DataBase was SAVED to FILES or other SHARE option was selected.'
    }
 
//shareBtn.style.display = "none";
//resultPara.style.display = "none";
//CODE TO SET RESTOREBTN FLASHING
if(reNamedDBFileName){
restoreDataBaseBtn.setAttribute('class','borderBlink');
restoreDataBaseBtn.textContent = "RESTORE " + renamedFileName;
mustTapRestore = true;//flag to force scroll to bottom of fileNamesWindow
}//end 
//backingUpDBWin.removeChild(shareBtn);
//backingUpDBWin.removeChild(resultPara);
  });//end shareBtn.addEventListener
  
  

//CODE FOR SHARE SHEET ^

} else {
//if not sharing and just storing new budget sheet in clipboard for pasting to some external storage, show msg re restoring new budget sheet and reset loadSampleBudget to false..Date: Dec 17 2023

if(loadSampleBudget) {//should this be repeated above?
	alert("After returning to the file names list window you may tap the RESTORE DATABASE button to load in and use your new BUDGET SHEET. DELETE the ‘Monthly Expenses TEMPLATE' file anytime after the browser has released its LOCK on it. The TEMPLATE is embedded in DougieBase and can be used to create a new Budget Sheet for any month, any time you need it by tapping 'Load Budget Sheet TEMPLATE' from the 'New/Change DB' (filenames) window.");
	loadSampleBudget = false;//added Dec15 to reset flashing TABLE  tn etc 
	dataNotBackedUp = true;//added Mar 2 2023
}//end if(loadSampleBudget)
		
	changeMonth = false;//reset in case coming from changeMonth routine of new budget sheet	backingUpDBWin.setAttribute('class','hidden');
		backupFilesWin.setAttribute('class','hidden');
		resultPara.textContent = "";
		
//CODE TO SET RESTOREBTN FLASHING
	if(reNamedDBFileName){
	restoreDataBaseBtn.setAttribute('class','borderBlink');
	restoreDataBaseBtn.textContent = "RESTORE " + renamedFileName;
	mustTapRestore = true;//flag to force scroll to bottom of fileNamesWindow
	}//end if(reNamedDBFileName)
		
		}//end prompt choice of using sharesheet END PROMPT
//PUT END if(!creationDONE)	 wrapper here?	
 }//end if(!creationDONE)MAYBE FINISHEDSHAREBTN.ONCLICK SHOULD BE REMOVED FROM THE EXCLUDEDCREATE NEW DATABASE WRAPPER AS A PRESS OF THIS BTN RUNS ITS FUNCTION CODE REGARDLESS?
//END IF(!creationDONE) 
//CODE ABOVE IS NOT USED FOR CREATE NEW DATA BASE .. BUT IS USED FOR BACKUP AND RENAME FILENAMES



if(!reNamedDBFileName) {
		//dbNameInfo.textContent = renamedFileName;
		alert('The database named..' + dataBaseName + ' has been copied to the clipboard! You can now PASTE it into your external BACKUP storage file. If on iOS: You can choose an option from the native share sheet. MAIL allows you to send your database via email to whomever. If you have the DougieBase extension DougieBase SAVE to FILES installed in your shortcuts, this will save your database directly to an iCloud folder labelled DougieBaseBKUPS. (Create a folder named DougieBaseBKUPS in iCloud first).');
	}//end if !reNamedDBFileName
	else if(reNamedDBFileName && !creationDONE){
	//dbNameInfo.textContent = dataBaseName;
	//renamedFileName HAS BEEN STRIPPED OF .bs but .bs is saved in the json string. SEE manipulateString() function
	alert('The database renamed..' + renamedFileName + ' has been copied to the clipboard! You can now PASTE it into your external BACKUP storage file. If on iOS: You can choose an option from the native share sheet. MAIL allows you to send your database via email to whomever. If you have the DougieBase extension DougieBase SAVE to FILES installed in your shortcuts, this will save your database directly to an iCloud folder labelled DougieBaseBKUPS. (Create a folder named DougieBaseBKUPS in iCloud first).You can still RESTORE the database with its new filename even if not on wifi by simply PASTING it into the textarea element in the RESTORE section of DougieBase.');
	//CODE TO SET RESTOREBTN FLASHING
//if(reNamedDBFileName && !creationDONE){
restoreDataBaseBtn.setAttribute('class','borderBlink');
restoreDataBaseBtn.textContent = "RESTORE " + renamedFileName;
//}//end if(reNamedDBFileName)
	mustTapRestore = true;//flag to force scroll to bottom of fileNamesWindow
	}//end else if(reNamedDBFileName) {
	
			
	}//end function finishedCopyBtn.onclick DONE BTN
	// }//END FUNCTION copyToClipboard?
// 	finishedShareBtn.onclick = function () {
// //	 shareBtn.style.display = "none";
// //resultPara.style.display = "none";
// backingUpDBWin.setAttribute('class','hidden');
// backupFilesWin.setAttribute('class','hidden');
//  } //end function finishedShareBtn.onclick

// if(creationDONE) 
// 	finishedShareBtn.setAttribute('class','borderBlinkGrn');
// }//END if(creationDONE) {
if(creationDONE) {
finishedShareBtn.setAttribute('class','borderBlinkGrn');
} else {
finishedShareBtn.setAttribute('class','borderBlink');
}//end if(creationDONE) 

finishedShareBtn.onclick = function () {
finishedShareBtn.setAttribute('class','tdEdit');
if(loadSampleBudget) {
	alert("After returning to the file names list window you may tap the RESTORE DATABASE button to load in and use your new BUDGET SHEET. DELETE the ‘Monthly Expenses TEMPLATE' file anytime after the browser has released its LOCK on it. (DougieBase will automatically do this for you). The TEMPLATE is embedded in DougieBase and can be used to create a new Budget Sheet for any month, any time you need it by tapping 'Load Budget Sheet TEMPLATE' from the 'New/Change DB' (filenames) window.");
	loadSampleBudget = false;//added Dec15 to reset flashing TABLE  tn etc 
	
// //experimental CODE TO SCROLL TO BOTTOM OF FILENAMES WINDOW SO FLASHING RESTORE BTN COMES INTO VIEW	
// // Create an observer and pass it a callback.
// var observer = new MutationObserver(scrollToBottomDiv); 
// // Tell it to look for new children that will change the height.
// var config = {childList: true};
// observer.observe(fileNamesWindow,config);
//  function scrollToBottomDiv() {
//   fileNamesWindow.scrollTop = fileNamesWindow.scrollHeight;
// }	
// //end experimental code to scroll to bottom	
	
//dataNotBackedUp = false;//added Mar 2 2023
	//put code here to scroll to bottom of fileNamesList????
//REMOVE IF MESSES UP Mar2 2023
//scroll to bottom of element with id = 'id of element'
		
// 	const scrollToBottom = (id) => {
// 	 const element = document.getElementById(id);
//    element.scrollTop = element.scrollHeight;
// }	
// scrollToBottom('fileNamesWindow');//this is a function expression..element id is passed as a parameter to the scrollToBottom function expression.


}//end if(loadSampleBudget)
resultPara.textContent = "";

if(reNamedDBFileName && !creationDONE) {
alert("Now RESTORE the database with its new File Name (" + renamedFileName + ") from your external storage, or from the Clipboard, back to DougieBase. It will be listed using its new name. DougieBase will delete the original file with its old name (" + dataBaseName + ") as it has now been rendered dysfunctional. (Requires waiting for the browser to release its LOCK on the original file) ");	
}//end if(reNamedDBFileName)

if(creationDONE) {
creationDONE = false;
resultPara.textContent = "";
	alert("Now RESTORE the newly created database to DougieBase by tapping the Text-Area element when the RESTORE Window appears, and 'PASTE' the data into the text-area element of the RESTORE window. (REMEMBER NOT TO 'COPY' ANYTHING UNTIL THE PASTE PROCESS IS FINISHED!) Your new database will now be listed among the current database filenames.");
	backingUpDBWin.setAttribute('class','hidden');
backupFilesWin.setAttribute('class','hidden');
creationDONE = false;
restoreDataBase(restoredDBName);//remove if does not work and re-instate RESTOREBTN FLASHING JAN31 2023
}//end if(creationDONE)

//	 shareBtn.style.display = "none";
//resultPara.style.display = "none";
backingUpDBWin.setAttribute('class','hidden');
backupFilesWin.setAttribute('class','hidden');
 } //end function finishedShareBtn.onclick
 
//  }//end if(!creationDONE)MAYBE FINISHEDSHAREBTN.ONCLICK SHOULD BE REMOVED FROM THE EXCLUDEDCREATE NEW DATABASE WRAPPER AS A PRESS OF THIS BTN RUNS ITS FUNCTION CODE REGARDLESS?
// //END IF(!creationDONE) 
// //CODE ABOVE IS NOT USED FOR CREATE NEW DATA BASE .. BUT IS USED FOR BACKUP AND RENAME FILENAMES

//CODE BELOW APPLIES ONLY TO CREATE NEW DATABASE 
// if(creationDONE) {
// finishedShareBtn.setAttribute('class','borderBlinkGrn');
// finishedShareBtn.onclick = function () {
// finishedShareBtn.setAttribute('class','tdEdit');
// 	resultPara.textContent = "";
// 	// alert("Now RESTORE the newly created database to DougieBase by tapping the RESTORE btn below and 'PASTE' the data into the text-area element of the RESTORE window. (REMEMBER NOT TO 'COPY' ANYTHING UNTIL THE PASTE PROCESS IS FINISHED!) Your new database will now be listed among the current database filenames.");
// 	backingUpDBWin.setAttribute('class','hidden');
// backupFilesWin.setAttribute('class','hidden');
// // creationDONE = false;
// // restoreDataBase(restoredDBName);//remove if does not work and re-instate RESTOREBTN FLASHING JAN31 2023
// 	}//end finishedShareBtn.onclick = function ()
// 	//CODE TO SET RESTOREBTN FLASHING
// // if(reNamedDBFileName){
// // restoreDataBaseBtn.setAttribute('class','borderBlink');
// // restoreDataBaseBtn.textContent = "RESTORE " + renamedFileName;
// // }//end if(reNamedDBFileName)

// //CODE ABOVE APPLIES ONLY TO CREATE NEW DATABASE 
// }//END if(creationDONE) { 
 
// reNamedDBFileName = false;
}//end function backup database	

//start function restoreDataBase(dataBaseName)
function restoreDataBase(restoredDBName) {
cancelRestoreBtn.disabled = false;//in case disabled by CANCEL in restore from FILES window

//if creating a new db don't show this CANCEL btn be ause if tapped it messes up
//alert("At restoreDataBase function - dbTableName.value = " + dbTableName.value + " dataBaseName = " + dataBaseName);

if(dbTableName.value.includes("creatingDB")) {
	cancelRestoreBtn.style.display = "none";
} else {
	cancelRestoreBtn.style.display = "unset";
}//end if(dbTableName.value.includes("creatingDB")) 

//reset variables if restoring a previously deleted file that had been blocked
//if (blocked && blockedName === dataBaseName && !reNamedDBFileName)
//if (blocked && blockedName === dataBaseName ) {
//	alert(dataBaseName + " file is still blocked by browser. Wait for browser's Lock to time-out!");
//blocked = false;
//blockedName = "";	//no point in clearing blocked name it gets reset if another file is blocked..keep so that a new attempt to delete is reminded the file is blocked
	//getFileNames();
//}//end if (blocked && blockedName === dataBaseName) 
textarea.style.display = "unset";	restoreTextArea.setAttribute('style', 'border: 5px solid red; text-align: center');
	if(loadSampleDb || loadTutorialDb || loadSampleBudget) {
		alert("Remember to Tap the Text-Area box ONCE only to CONTINUE. This initiates loading of database sample.");
		//change html text to reflect SAMPLE
		restoreFromFileBtn.style.display = "none";
//ReferenceError: Cannot access uninitialized variable.
		nowDo.style.color = "black";
		nowDo.textContent = "TAP TextArea element box TO INITIATE LOADING OF DATABASE SAMPLE. \nTHEN TAP SUBMIT.";
		restoreTextArea.textContent = "TAP HERE TO INITIATE LOADING OF DATABASE SAMPLE. \nTHEN TAP SUBMIT.";
		
	//for condition of loading a budget sheet
	if(loadSampleBudget) { 
	nowDo.textContent = "TAP TextArea element box TO INITIATE LOADING OF THE BUDGET SHEET. \nTHEN TAP SUBMIT.";
		restoreTextArea.textContent = "TAP HERE TO INITIATE LOADING OF THE BUDGET SHEET. \nTHEN TAP SUBMIT.";
		}//end if (loadSampleBudget)
	
		//restoreTextArea.textContent = "TAP HERE TO LOAD DATABASE SAMPLE!";
	
	restoreTextArea.onclick = function() {
		//alert("Tapped restoreTextArea.onclick. copySampleDbData.value = " + copySampleDbData.value);
		restoreTextArea.setAttribute('style', 'border: 3px solid blue');
		nowDo.textContent = "THANK YOU!. \nNOW TAP SUBMIT to load SAMPLE DATABASE..";
		restoreTextArea.textContent = "THANK YOU!. \nNOW TAP SUBMIT to load SAMPLE DATABASE..";
		
	//for condition of loading a budget sheet
	if(loadSampleBudget) { 
	nowDo.textContent = "TAP TextArea element box TO INITIATE LOADING OF THE BUDGET SHEET. \nTHEN TAP SUBMIT.";
		restoreTextArea.textContent = "TAP HERE TO INITIATE LOADING OF THE BUDGET SHEET. \nTHEN TAP SUBMIT.";
		}//end if (loadSampleBudget)
		//restoreTextArea.textContent = "TAP HERE TO LOAD DATABASE SAMPLE!";
	getJsonBtn.setAttribute('class','borderBlinkGrn');
			}//end restoreTextArea.onclick
	
	 } else { 
		 alert("Remember IF RESTORING FROM CLIPBOARD to FIRST TAP Text-Area box ONCE. SUBMIT btn turns green, then PASTE backup text");
		 restoreTextArea.setAttribute('style', 'border: 5px solid blue');
		 nowDo.textContent = "IF RESTORING FROM CLIPBOARD FIRST TAP Text-Area box ONCE. SUBMIT btn turns green, then PASTE backup text into text area...";
		 restoreTextArea.textContent = "FIRST TAP ONCE. SUBMIT btn turns green, then PASTE backup text here....";
		 restoreTextArea.onclick = function() {
		 //user chooses restore via clipboard so remove restore via FILES btn
		 restoreFromFileBtn.style.display = "none";
		 nowDo.setAttribute('class','borderBlinkGrn');
			//clear text area prior to paste
			nowDo.textContent = "Now PASTE data into TextArea box…THEN tap SUBMIT button!";
			 restoreTextArea.textContent = "";	getJsonBtn.setAttribute('class','borderBlinkGrn');
			}//end restoreTextArea.onclick
		 
	}//end if loadSampleDb || loadTutorialDb || loadSampleBudget else	
	 
	 
	 
	 
	console.log('In restoreDataBase(dataBaseName) function');
	//alert('restoreDataBase(dataBaseName ). ' + dataBaseName);
	
	//const restoreFromFileBtn = document.querySelector('#restoreFromFile');//made global
	
	//	const restoreFromClipboardBtn = document.querySelector('#restoreFromClipboard');//made global
fromRestore = true;	restoreDBWindow.setAttribute('class','showing');

//code for restoring from FILE
restoreFromFileBtn.onclick = function () {
cancelRestoreBtn.disabled = true;//this is the CANCEL BTN in the restore db window, because error if pressed in restore from FILES window

	restoreFromLocalFile = true;
	restoreFromFileBtn.style.display = "none";
	restoreTextArea.style.display = "none";
	//nowDo.style.display = "none";
	nowDo.textContent = "RESTORING FROM FILES! After selecting the file tap the Submit button."
	restoreInfo2P.textContent = "RESTORING DATABASE FROM FILES"
	selectStorageFile(selectedFileData);
	json = selectedFileData;
	
}//end function restoreFromFileBtn.onclick
//code for restoring from FILE

//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	restoreDBWindow.style.backgroundColor = "black";
	restoreDBWindow.style.color = "white";
	restoreInfo2P.style.color = "black";
	restoreInfoP.style.color = "white";
	restoreInfo1P.style.color="white";
	nowDo.style.color = "black";
} else {
	restoreDBWindow.style.backgroundColor = "#eee";
	restoreDBWindow.style.color = "black";
}//end if else screenDark

if (loadSampleDb || loadTutorialDb || loadSampleBudget) {
	//change heading title of window for SAMPLE
	restoreDBWinTitle.textContent = "….LOADING A SAMPLE DATABASE DEMONSTRATION";
	
	restoreInstructionsP.textContent = "Tap the Text-Area input window to CONTINUE! Then tap 'SUBMIT Sample DB data' to Load the sample database. Tap RESTORE your database. Tap FINISHED. Tap on restored file name in database list to view file.";
	restoreInfoP.textContent = "After tapping on the Text-Area element, the Submit button turns green indicating DougieBase is ready to continue creating the SAMPLE database.";
	
	//added id to html p 1
	restoreInfo1P.textContent = "First! Tap the RED text-area input element ONCE to initialize. The Submit button will turn green. Tap the SUBMIT button, tap RESTORE DATABASE button, the CONFIRMATION window appears. ";
	restoreInfo2P.textContent ="Summary to create the database SAMPLE: Tap the Text-Area input window. Tap the SUBMIT button, tap RESTORE DATABASE button, tap FINISHED, then tap the name of the SAMPLE database in the database list of file names in the Change DB window."
	getJsonBtn.textContent = "SUBMIT Sample DB data";
	if(loadSampleBudget) {
		getJsonBtn.textContent = "SUBMIT Budget TEMPLATE ";
	} //end if(loadSampleBudget) 
	
	//if restore from local file
} else if (restoreFromLocalFile && formatFailed) {
//formatFailed = false;
	//restoreFromLocalFile = false;	//added Sept 26 not tested	
	restoreDBWinTitle.textContent = "Restoring a database from its Backup stored in a local or remote file.";
	restoreInstructionsP.textContent = "The data has been fetched from the selected file.. Tap 'Submit Backup data'. Tap RESTORE your database. Tap FINISHED. Tap on restored file name in database list in the Current File Names window to view file.";
	restoreInfo1P.textContent = "Select the desired file containing the database backup. The Submit button will turn green telling you DougieBase is ready to recieve the backup data.. Tap the SUBMIT button and your database will be restored.";
	restoreInfoP.textContent = "Dougiebase will create a new shell to structure the restored data from your external storage source."
	restoreInfo2P.textContent = "DATABASE (RESTORED FROM SELECTED FILE) has incorrect format! Try again."

	//if restore from local file
} else {
	restoreDBWinTitle.textContent = "Restore a database from its Backup via the Clipboard OR from FILES";
	restoreInstructionsP.textContent = "Paste Backup data from CLIPBOARD into the text area element. OR tap RESTORE FROM LOCAL FILE button. Tap 'Submit Backup data'. Tap RESTORE your database. Tap FINISHED. Tap on restored file name in database list in the Current File Names window to view file.";
	restoreInfo1P.textContent = "TO RESTORE FROM CLIPBOARD: FIRST! Tap the blue text input area to initialize the Paste area. The Submit button will turn green telling you DougieBase is ready for PASTE. After Pasting, Tap the SUBMIT button and your database will be restored.";
	restoreInfoP.textContent = "Dougiebase will create a new shell to structure the restored data. IF RESTORING FROM CLIPBOARD: Enter the previously saved backup data of the database to be restored into the text area window below using Copy/Paste from the clipboard or from your external storage source. IF RESTORING FROM FILES: Tap the \'RESTORE your DataBase from a local FILE\' button."
	restoreInfo2P.textContent = "RESTORING FROM CLIPBOARD: Copy backup data text from your storage source to the clipboard, and then Paste the Backup data for the database you are restoring, into the Text Area below vv"
	getJsonBtn.textContent = "SUBMIT Backup data";
}//end if else loadSampleDb || loadTutorialDb

	
	//dataBaseName = notes_dbx
	//console.log('dataBaseName = ' + dataBaseName)
	//restoreDBNameInput.textContent = dataBaseName;
	//console.log('restoreDBNameInput.value = ' + restoreDBNameInput.value );
	
	//restoreDBNameBtn.onclick = function (){
	// restoredDBName = restoreDBNameInput.value;
	// objectStoreName = restoredDBName + '_os';
		//restoredDB = restoredDBName;//??
	//	console.log('restoredDBName = ' + restoredDBName);
	// 	getFileNamesSwitch = false;//so getFileNames
	//}//end restoreDBNameBtn.onclick function
	
  // const restoreTextArea = document.querySelector('#restoreTextAreaClip');
  // const getJsonBtn =  document.querySelector('#getJson');
  //  getJsonBtn.onclick = function (){
	//   let json = restoreTextArea.value;
	  
	// // resetVariables();//NOT SURE IF THIS SHOULD BE HERE.?
	//  }//end getJsonBtn.onclick function
			//alert('end restoreDBNameBtn.onclick function');
	//MORE JAVASCRIPT FOR RESTORE DB OPTION IS AT BOTTOM OF HTML FILE		
	//const finishedRestoreBtn = document.createElement('button');//made global
	finishedRestoreBtn.disabled=true;
	
	//const cancelRestoreBtn = document.createElement('button');//made global
			
	// const restoreDBNameBtn = document.querySelector('#restoreDBNameBtn');
	// restoreDBNameBtn.onclick = function (json) {
	// json = restoreTextAreaClip.value;
	// //restoreDBWindow.removeChild(readyNotice);
	// //return json;
	// }//end restoreDBNameBtn.onclick
//console.log('json = ' + json);	
//SyntaxError: Unexpected identifier 'importFromJson'removed await	
//alert('STOP!');
// importFromJson(dataBaseName, json);

	//alert('Database ' + dataBaseName + ' RESTORED!');
	
	//TypeError: Argument 1 ('node') to Node.appendChild must be an instance of NodeLEFT OFF HERE APR22
	finishedRestoreBtn.textContent = 'FINISHED';	restoreDBWindow.appendChild(finishedRestoreBtn);
	cancelRestoreBtn.textContent = 'CANCEL';	restoreDBWindow.appendChild(cancelRestoreBtn);
	//added restoredDBName var to function finishedBtn.onclick so name is known to selectedDBInfoP May29 2021
	finishedRestoreBtn.onclick = function (restoredDBName) {
	restoreFromFileBtn.style.display = "unset";
	restoreTextArea.style.display = "unset";
	
	//to prevent a mess if CANCEL is tapped after template is created DATE: JAN22 2023	
	cancelRestoreBtn.style.display = "unset";
	//nowDo.style.display = "unset";
	
		dbRestored = true;//flag to allow notification of restore in getFileNames May12
	//clear textarea for next use
	// loadSampleDb = false;
	restoreFromLocalFile = false;	//added Sept 26 not tested	
	nowDo.setAttribute('class','attentionBtn');
	nowDo.textContent = "FIRST TAP Text-Area box ONCE. SUBMIT btn turns green, then PASTE backup text into text area...";
	restoreTextArea.textContent = "FIRST TAP ONCE. SUBMIT btn turns green, then PASTE backup text here...."
	restoreTextArea.value = "";//May8
	console.log('finishedRestoreBtn has been tapped.');
	//clearDatabase(dataBaseName);
	//ReferenceError: Can't find variable: getJsonBtn
getJsonBtn.setAttribute('class','normalBtn');
console.log("loadSampleDb === " + loadSampleDb + "loadTutorialDb = " + loadTutorialDb);
//if (loadSampleDb) {
//	getJsonBtn.textContent = "SUBMIT SAMPLE data";
//}//end if (loadSampleDb)
getJsonBtn.textContent = "SUBMIT Backup data";
restoreFromClipboardBtn.setAttribute('class','normalBtn');
// if (loadSampleDb) {
// 	restoreFromClipboardBtn.textContent = "Click here to LOAD the DataBase Sample.";
// }//end if(loadSampleDb)
restoreFromClipboardBtn.textContent = "Click here to RESTORE your DataBase.";
finishedRestoreBtn.setAttribute('class','normalBtn');
		restoreDBWindow.removeChild(finishedRestoreBtn);
	restoreDBWindow.removeChild(cancelRestoreBtn);
	restoreDBWindow.setAttribute('class','hidden');
	console.log('restoredDBName = ' + restoredDBName);
	dataBaseName = defaultDBName;
//IF A RECENTLY DELETED DB HAS JUST BEEN RESTORED RESET THE DBDELETEDName variable
//I DON'T THINK THIS CODE IS USED????Date:Dec28 2022
if(dbDeletedName[1] === defaultDBName) {dbDeletedName[1] = ""; dbDeleted[1] = false;}//end if(dbDeletedName1 === defaultDBName)
if(dbDeletedName[2] === defaultDBName) {dbDeletedName[2] = ""; dbDeleted[2] = false;}//end if(dbDeletedName1 === defaultDBName)
if(dbDeletedName[3] === defaultDBName) {dbDeletedName[3] = ""; dbDeleted[3] = false;}//end if(dbDeletedName1 === defaultDBName)
if(dbDeletedName[4] === defaultDBName) {dbDeletedName[4] = ""; dbDeleted[4] = false;}//end if(dbDeletedName1 === defaultDBName)
if(dbDeletedName[5] === defaultDBName) {dbDeletedName[5] = ""; dbDeleted[5] = false;}//end if(dbDeletedName1 === defaultDBName)
if(dbDeletedName[6] === defaultDBName) {dbDeletedName[6] = ""; dbDeleted[6] = false;}//end if(dbDeletedName1 === defaultDBName)
if(dbDeletedName[7] === defaultDBName) {dbDeletedName[7] = ""; dbDeleted[7] = false;}//end if(dbDeletedName1 === defaultDBName)
if(dbDeletedName[8] === defaultDBName) {dbDeletedName[8] = ""; dbDeleted[8] = false;}//end if(dbDeletedName1 === defaultDBName)
if(dbDeletedName[9] === defaultDBName) {dbDeletedName[9] = ""; dbDeleted[9] = false;}//end if(dbDeletedName1 === defaultDBName)
if(dbDeletedName[10] === defaultDBName) {dbDeletedName10 = ""; dbDeleted[10] = false;}//end if(dbDeletedName1 === defaultDBName)



	
	if (loadSampleDb || loadTutorialDb || loadSampleBudget) {
		selectedDBinfoP.textContent =  " successfully LOADED SAMPLE .." + dataBaseName +"!";
		fileChosenP.textContent = "Successfully LOADED SAMPLE .." + dataBaseName +"!";
// 		loadSampleDb = false;
// 			if(dbListExists) {
// 		while (dataBaseList.firstChild) {
//    dataBaseList.removeChild(dataBaseList.firstChild);
// };//end while
// };//end if dbListExists
//???should loadSampleDb = false here???Aug20

//CODE TO SCROLL TO FLASHING RESTORE DATABASE NAME BTN added Mar7 does not work!!
// document.getElementById("restoreDataBaseBtn").scrollIntoView();
 
// 		alert("scrolling to RESTORE btn");	document.getElementById("restoreDataBaseBtn").scrollIntoView();
		
// const scrollToBottom = (id) => {
// 	 const element = document.getElementById(id);
//    element.scrollTop = element.scrollHeight;
// }	
// scrollToBottom('fileNamesWindow');//this is a function expression..element id is passed as a parameter to the scrollToBottom function expression.

		getFileNames();//remove ;to return to notes?
if(loadSampleBudget) { 	
fileChosenP.setAttribute('class','borderBlink');
//SHOULD I ADD CODE TO SCROLL TO BOTTOM? Date:Dec17 2023

// //code below added Dec18 2022 to scroll to bottom of element with id = 'id of element'
		
// 	const scrollToBottom = (id) => {
// 	 const element = document.getElementById(id);
//    element.scrollTop = element.scrollHeight;
// }	
// scrollToBottom('fileChosenP');//this is a function expression..element id is passed as a parameter to the scrollToBottom function expression.
	
	
	
selectedDBinfoP.textContent = "NOW TAP "+ dataBaseName + " TO LOAD IN AND THEN RENAME FILE. (Follow flashing prompts)"
selectedDBinfoP.setAttribute('class','borderBlink');
}//end if(loadSampleBudget) 
		return//Aapdded Aug 12 should REMOVE!,
	} else {//end if (loadSampleDb)
	
	selectedDBinfoP.textContent =  " successfully RESTORED .." + dataBaseName +"!";
	fileChosenP.textContent = "Successfully RESTORED .." + dataBaseName +"!";
	}//end if(loadSampleDb) else
	
		getFileNames();//remove to return to notes?
		
	// alert("scrolling to RESTORE btn");	document.getElementById("restoreDataBaseBtn").scrollIntoView();
	
	}//end finishedRestoreBtn.onclick
		
cancelRestoreBtn.onclick = function () {
mustTapRestore = false;//flag to force scroll to bottom of fileNamesWindow
restoreFromFileBtn.style.display = "unset";
nowDo.setAttribute('class','attentionBtn');
	loadSampleDb = false;
	loadTutorialDb = false;
	loadSampleBudget = false;
	formatFailed = false;
	reNamedDBFileName = false;//this flag prevents backup routine from going to manipulateString Mar9 Mar 11 2023	
	//clear textarea for next use
	restoreTextArea.textContent = "Paste Backup data here"
	restoreTextArea.value = "";//May8
	console.log('cancelRestoreBtn has been tapped.');
	//clearDatabase(dataBaseName);
	getJsonBtn.textContent = "SUBMIT Backup data";
	getJsonBtn.setAttribute('class','normalBtn');
//getJsonBtn.setAttribute('class','attentionBtn');
restoreFromClipboardBtn.setAttribute('class','normalBtn');	
finishedRestoreBtn.setAttribute('class','normalBtn');
restoreFromLocalFile = false;	//added Sept 26 not tested	

selectedDBinfoP.textContent = "Choose the file from list above. Tap to SELECT the DataBase:";
selectedDBinfoP.setAttribute('class','simulator');

	restoreDBWindow.removeChild(finishedRestoreBtn);
	restoreDBWindow.removeChild(cancelRestoreBtn);
	restoreDBWindow.setAttribute('class','hidden');
		//getFileNames();//remove to return to notes? RETURN TO NOTES WINDOW
	}//end cancelRestoreBtn.onclick

	//
	getJsonBtn.onclick = function (){
		if (loadSampleDb) {
			json = copySampleDbData.value;
			string = json;
		} else if (loadTutorialDb) {
			json = tutorialSampleDbData.value;
		} else if (loadSampleBudget) {
			json = sampleBudgetDbData.value;
		} else if (restoreFromLocalFile) {
			json = selectedFileData;
			//restoreFromLocalFile = false;
		} else {
			json = restoreTextArea.value;
		}//end if else loadSampleDb || loadTutorialDb
	
    console.log('restoreTextArea.value = ' + restoreTextArea.value + "json = " + json);
	  checkFormat(json);
	  defaultDBName = getRestoredDBName(json);
	 //removed reset variables May7 ?makes setup = 0 so that diables viewSettings btn in aboutDB..NOT GOOD, Its removal fixed the messed up field headers in table after first view of table from a restoreDB.AND FIXED THE DISABLED VIEWSETTINGS BTN
	//resetVariables();//NOT SURE IF THIS SHOULD BE HERE.?
	getJsonBtn.setAttribute('class','colorBtn');
	getJsonBtn.textContent = "SUBMITTED!";
	nowDo.setAttribute('class','attentionBtn');
	restoreFromClipboardBtn.setAttribute('class','borderBlinkGrn');
if(formatFailed) {
			formatFailed = false;
			getJsonBtn.textContent = "SUBMIT Backup data";
		getJsonBtn.setAttribute('class','attentionBtn');	
		restoreFromClipboardBtn.setAttribute('class','attentionBtn');	
			
		}//end if formatFailed
	
	
}//end getJsonBtn.onclick function
	
restoreFromClipboardBtn.onclick = function (json,restoredDBName,objectStoreName) {
	// const getJsonBtn =  document.querySelector('#getJson');
//    getJsonBtn.onclick = function (){
// 	  let json = restoreTextArea.value;
// 	  console.log('restoreTextArea.value = ' + restoreTextArea.value);
// 	resetVariables();//NOT SURE IF THIS SHOULD BE HERE.?May9 commented out fixes view settings being disabled in About DataBase section.
// 	getJsonBtn.setAttribute('class','colorBtn');
	

// 	restoreFromClipboardBtn.setAttribute('class','attentionBtn');
	
// }//end getJsonBtn.onclick function
finishedRestoreBtn.disabled=false;
	console.log('In function restoreFromClipboardBtn.onclick. restoredDBName = ' + restoredDBName);
	//let restoredDB; //global variables
	//let data = jsonString;
	//will removing var statement make restoredDBName act as global var?nope did not work
	restoredDBName = prompt("Confirming the name of the database to restore?",defaultDBName)
	//var restoredDBName = prompt("What's the name of the database to restore?")
	if(restoredDBName === null) {
		restoreTextArea.textContent = "Paste Backup data here"
		restoreTextArea.value = "";//May8
	console.log('cancelRestoreBtn has been tapped.');
	//clearDatabase(dataBaseName);
	// restoreTextArea.onclick = function() {
	// 	getJsonBtn.setAttribute('class','attentionBtn');
	// }//end restoreTextArea.onclick
getJsonBtn.setAttribute('class','normalBtn');
getJsonBtn.textContent = "SUBMIT Backup data";
restoreFromFileBtn.style.display = "unset";//in case it had been set to display none added Feb22 2023
restoreFromLocalFile = false;	//added Sept26 not tested
restoreFromClipboardBtn.setAttribute('class','normalBtn');	
finishedRestoreBtn.setAttribute('class','normalBtn');
		restoreDBWindow.removeChild(finishedRestoreBtn);
	restoreDBWindow.removeChild(cancelRestoreBtn);
	restoreDBWindow.setAttribute('class','hidden');
	getFileNames();//remove to return to notes? RETURN TO NOTES WINDOW
	//produces error SyntaxError: JSON Parse error: Unexpected EOF at line 6722 then this will cause a null db to be created. Can you add some sort of break here??
	//break//SyntaxError: 'break' is only valid inside a switch or loop statement.
	return//this works no error no null db in list db list appears
	}//end if restoredDBName = null
	
	var objectStoreName = restoredDBName + '_os';
	
	let ver = 1;
	let request = window.indexedDB.open(restoredDBName, ver);
	let def = "whoops!"
	//dataBaseName = restoredDBName;//added May13 so restore notification in getFileNames woks. dataBaseName IS global?
	dataBaseName = defaultDBName;//added
	
	restoreFromClipboardBtn.textContent = "Your Database has been RESTORED!";
	restoreFromClipboardBtn.setAttribute('class','colorBtn');	
	finishedRestoreBtn.setAttribute('class','borderBlinkGrn');

//Should CANCEL btn here be display "none "	until finished btn is tapped at which point CANCELbtn is unset

cancelRestoreBtn.style.display = "none";	
	
//NOTE IF DOUGIEBASE DELETED THE DB FILE AND LOCKS IT, THE LOAD IF THE FILE IS TAPPED IN GETFILENAMES..(SHOULD BE GREYED OUT?) the program can't find the file and assumes does not exist and goes to onupgrade needed thus thinking we are creating a new db so now in createnewdb code flow		
request.onupgradeneeded = function(e) {
	let restoredDB = e.target.result;
	objectStoreName = restoredDBName + '_os';
		let objectStore = restoredDB.createObjectStore(objectStoreName, { keyPath: 'id', autoIncrement:true });
objectStore.createIndex('title', 'title', { unique: false });
  
  //addind date of note creation
  objectStore.createIndex('created', 'created', { unique: false });
  //end code for adding date created
  objectStore.createIndex('body', 'body', { unique: false });
  //CODE FOR xtraField basically substituting xtraField for body
  
	  objectStore.createIndex('xtraField', 'xtraField', { unique: false });
  objectStore.createIndex('variable1', 'variable1', { unique: false });
  objectStore.createIndex('variable2', 'variable2', { unique: false });
  objectStore.createIndex('dataV', 'dataV', { unique: false });	
  
  console.log('In onupgradeneeded. This means db_name not found and a new database is being created. Database setup complete. Now returning to .onsuccess handler of open database event? upgraded variable about to be set to 1. ');
 let upgraded = 1;
   
};//end request.onupgradeneeded
//changed passes var restoredDB To restoredDBName May12
request.onsuccess = function importFromJson(e,restoredDBName, json) {
	console.log('In request.onsuccess function');
	//COMMENTED OUT LINE BELOW NOT SURE IT IS NEEDED AND ITS PRESENCE MESSES UP JSON!!!! Aug 16 json = something has to be here otherwise undefined error!
	if (loadSampleDb) {
			json = copySampleDbData.value;
		} else if (loadTutorialDb) {
			json = tutorialSampleDbData.value;
		} else if (loadSampleBudget) {
			json = sampleBudgetDbData.value;
		} else if (restoreFromLocalFile) {
			json = selectedFileData;
			//restoreFromLocalFile = false;	
		} else {
			json = restoreTextArea.value;
		}//end if else loadSampleDb || loadTutorialDb
   // json = restoreTextArea.value;
 
	//SyntaxError: Cannot declare a let variable twice: 'db'.
	restoredDB = e.target.result;
//  return new Promise((resolve, reject,json) => 
//NotFoundError: Failed to execute 'transaction' on 'IDBDatabase': One of the specified object stores was not found.{
    const transaction = restoredDB.transaction(
      restoredDB.objectStoreNames,
      'readwrite'
    )
    //transaction.addEventListener('error', reject)
console.log('json = ' + json);

    var importObject = JSON.parse(json);
	//SyntaxError: JSON Parse error: Unterminated string
	//SyntaxError: JSON Parse error: Unexpected identifier "undefined"
	console.log('After JSON.parse(json) importObject = ' + importObject);
    for (const storeName of restoredDB.objectStoreNames) {
		console.log('storeName = ' + storeName);
      let count = 0
      for (const toAdd of importObject[storeName]) {
        const request = transaction.objectStore(storeName).add(toAdd)
        request.addEventListener('success', () => {
          count++
          if (count === importObject[storeName].length) {
            // Added all objects for this store
            delete importObject[storeName]
            if (Object.keys(importObject).length === 0) {
              // Added all object stores
              console.log('Added all objectStores');
			  //ReferenceError: Can't find variable: resolveresolve()
            }
          }
        })
      }
    }
 // })//end promise
};//end request.onsuccess

	request.onerror = function() {
  console.log('Database failed to open');
};//end request.onerror

};//END FUNCTION RESTORE FROM CLIPBOARDBtn.onclick

//start function checkRestore
//function check fileFormat
function checkFormat (json) {
//alertx("Verifying format of json: " + json);
	var verify = json.slice(0,2);
	var verifyEnd = json.slice(-3);
	
	console.log('verify = ' + verify);
	console.log('verifyEnd = ' + verifyEnd);
	if(verify !== "{\"" || verifyEnd !== "}]}") {
		
		alert('Improper file format? Re-submit the backup data');
		//clear textarea for next use
	restoreTextArea.textContent = "Paste Backup data here";
	restoreTextArea.value = "";//May8
	json = "";//added May29 2021
	console.log('fileFormat check failed.. cancel code initiated. Going back to restoreDataBase()');
	formatFailed = true;
	//clearDatabase(dataBaseName);
restoreFromFileBtn.style.display = "unset";
getJsonBtn.setAttribute('class','normalBtn');
getJsonBtn.textContent = "SUBMIT Backup data";
restoreFromClipboardBtn.setAttribute('class','normalBtn');	
finishedRestoreBtn.setAttribute('class','normalBtn');

		restoreDBWindow.removeChild(finishedRestoreBtn);
	restoreDBWindow.removeChild(cancelRestoreBtn);
	restoreDBWindow.setAttribute('class','hidden');
	//go back to start of restoreDB
	restoreDataBase(restoredDBName);
	}//end if verify !=
	
}//end function checkFormat this function put inside restoreDatabase function so references to btns are recognized May29 2021

//end function check fileFormat
	
}//end function restoreDataBase(dataBaseName)
	
//END FUNCTION RESTORE DATABASE

/**
 * Clear a database
 *
 * @param {IDBDatabase} idbDatabase The database to delete all data from
 * @return {Promise<void>}
 */
 function clearDatabase(idbDatabase) {
	 console.log('In clearDatabase function. File to clear is idbDatabase - ' + idbDatabase);
  return new Promise((resolve, reject) => {
    const transaction = idbDatabase.transaction(
      idbDatabase.objectStoreNames,
      'readwrite'
    )
    transaction.addEventListener('error', reject)

    let count = 0
    for (const storeName of idbDatabase.objectStoreNames) {
      transaction
        .objectStore(storeName)
        .clear()
        .addEventListener('success', () => {
          count++
          if (count === idbDatabase.objectStoreNames.length) {
            // Cleared all object stores
            resolve()
          }
        })
    }
  })
}

//FUNCTION TO IMPORT DATA ABOVE

function clearDataBase (dataBaseName,objectStoreName) {
	console.log('In clearDataBase function. File to clear is dataBaseName - ' + dataBaseName + '. objectStoreName is  ' + objectStoreName);
	// Let us open our database
var DBOpenRequest = window.indexedDB.open(dataBaseName, 1);

DBOpenRequest.onsuccess = function(event) {
	
	console.log('DataBase opened successfully!');
 // note.innerHTML += '<li>Database initialised.</li>';
    
  // store the result of opening the database in the db variable.
  // This is used a lot below
  db = DBOpenRequest.result;
    
  // Clear all the data form the object store
  clearData();
};

function clearData() {
  // open a read/write db transaction, ready for clearing the data
  var transaction = db.transaction([objectStoreName], "readwrite");

  // report on the success of the transaction completing, when everything is done
  transaction.oncomplete = function(event) {
	console.log('DataBase function completed successfully!');  
   // note.innerHTML += '<li>Transaction completed.</li>';
  };

  transaction.onerror = function(event) {
	  console.log('DataBase  error!');
   // note.innerHTML += '<li>Transaction not opened due to error: ' + transaction.error + '</%li>';
  };

  // create an object store on the transaction
  var objectStore = transaction.objectStore(objectStoreName);

  // Make a request to clear all the data out of the object store
  var objectStoreRequest = objectStore.clear();

  objectStoreRequest.onsuccess = function(event) {
	  
	  console.log('DataBase opened successfully! Request successful.');
    // report the success of our request
   // note.innerHTML += '<li>Request successful.</li>';
  };
};
	
	
}//end function clearDataBase

//start function getRestoredDBName
function getRestoredDBName(json) {
	console.log('In getRestoredDBName function')
  console.log('json = ' +json)
//  var startChr = json.indexOf("{")+1;
  var startChr = 2;
  var endChr = json.indexOf("_");
  console.log('start position = '+ startChr);
  console.log('end position = '+ endChr);
  //var n = str.indexOf("welcome");
  var getRestoredDBName = json.slice(startChr,endChr);
  return getRestoredDBName;
 // document.getElementById("demo").innerHTML = dbName;
}//end function getRestoredDBName
//end function getRestoredDBName

//start function isolateLink called by displayTable

function isolateLink(textContainingLink) {
	console.log('in isolateLink function');
	console.log('textContainingLink = ' + textContainingLink)
	let linkInfo;
	let startLink = textContainingLink.indexOf('http');
console.log('startLink = ' + startLink);
//correct startLink
	//LEFT OFF HERE MAY31
	preLinkInfo = textContainingLink.slice(0,startLink);
	preLinkInfo = filterColon(preLinkInfo);
	console.log('preLinkInfo = ' + preLinkInfo);
	let endLink = 0;
	let occurences = 0;
	let position = 0;
	if(textContainingLink.indexOf('.pdf') !== -1) {
		let position = textContainingLink.indexOf('.pdf');
		endLink = position + 3;//should this be 2? 1 is added to endLink below
	}else if(textContainingLink.indexOf('.html') !== -1) {
		let position = textContainingLink.indexOf('.html');
		endLink = position + 4;//should this be 3?
	} else {
		let position = textContainingLink.indexOf('/');
		while (position !== -1) {
  occurences++
  position = textContainingLink.indexOf('/', position + 1);
  if (position >1) {endLink = position}//end if position>1
}//end while position !== -1
	}//end of if textContainingLink.indexOf
//let position = textContainingLink.indexOf('/');

// while (position !== -1) {
//   occurences++
//   position = textContainingLink.indexOf('/', position + 1);
//   if (position >1) {endLink = position}//end if position>1
// }//end while position !== -1

postLinkInfo = textContainingLink.slice(endLink+2);//why 2? Trial and error if .html should this be 3?
postLinkInfo = filterColon(postLinkInfo);

console.log('count of occurences = ' + occurences);  
console.log('position = ' + position);
console.log('endLink = ' + endLink);
//position will =-1 because of while condition
// The method slice() takes two arguments: the start index where you will start copying and the end index where the copying ends. The second argument is not included, which means when you copy an array from index 1 to index 5, it will only copy from index 1 to index 4.

let link = textContainingLink.slice(startLink,endLink+1);
console.log('link = ' + link);
console.log('postLinkInfo = ' + postLinkInfo);
//textBeforeLink and textAfterLink commented out because not used inTableNotes. (From isolateLink.html Jun4)
// textBeforeLink.textContent = preLinkInfo;
// textAfterLink.textContent = postLinkInfo;
//alert('link = ' + link + 'preLinkInfo = ' + preLinkInfo + ' postLinkInfo = ' + postLinkInfo);
return link;

}//end function isolateLink()   

//trim after colon
function filterColon (linkInfo) {
	//alert('linkInfo = ' + linkInfo);
	let linkColonPos = linkInfo.indexOf(':');
	if (linkColonPos === -1) {
		linkInfo = linkInfo;
	}else {
		linkInfo = linkInfo.slice(0,linkColonPos);
	}
	return linkInfo;
	
}//end function filterColon

//begin function checkScreenMode
function checkScreenMode() {
var usingDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
//alert("At checkScreenMode function..usingDarkMode = " + usingDarkMode);
console.log("At checkScreenMode function - usingDarkMode = " + usingDarkMode);
		if (usingDarkMode) {bodyImage.style.backgroundColor= "black";
		viewDark.textContent = "Reset/Dark Mode clear Background Image";}//end if usingDarkMode
		screenDark = true;
		if (!usingDarkMode) {bodyImage.style.backgroundColor= "white";
		viewDark.textContent = "Reset/Dark-Light Mode";
		screenDark = false;
	}//end if !usingDarkMode
}//end function checkScreenMode

//beginning email code Dec15 2021
async function getEmail (selectedContact) {
	const supported = ('contacts' in navigator && 'ContactsManager' in window);
	if (supported) {
		alert("ContactsAPI is supported!");
		
	const props = ['name','email'];
const opts = {multiple: true};

//async function getContacts() {
	try {
       var contacts = await navigator.contacts.select(props, opts);
	 // alert("contacts = " + contacts);
	   selectedContact = contacts.email;
	  //selectedContacts = contacts.value; 
   stringify(selectedContact);
	  return contacts;
	  
     // handleResults(contacts);
  } catch (ex) {
	  alert("error = " + ex);
      // Handle any errors here.
  }
//}	
		
	function stringify (selectedContact) {
    alert("stringified " + Object.prototype.toString.call(selectedContact));
	selectedContact = Object.prototype.toString.call(contacts.name);	
	 }//end function stringify
	 
	 
	 
// 		const props = ['name', 'email'];
// const opts = {multiple: false};
// async function getContacts() {
// try {
	
// //  const contacts = async () => {
// // 	 await navigator.contacts.select(props, opts);
// // 	alert("contacts = " + contacts.email);
// // }//end curly of async function


// 	const contacts = await navigator.contacts.select('name','email' );
//   alert("contacts = " + contacts.email);
  
  
  
//   //contacts = [object Promise]
//   //contacts = [object HTMLButtonElement]
//   //handleResults(contacts);
// } catch (ex) {
// 	alert("error = " +ex);
//   // Handle any errors here.
// }

// }//end async function get contacts
// alert("contacts = " + contacts);
// // var selectedContact = 
// // navigator.contacts.select(
// //     ['name', 'email'], {multiple: false}
// //   ).then( contacts => console.log(contacts) )
// //  // .catch( error => console.log(error) )
  
// //   alert('email selected is ' + contacts);

alert("contacts = " + contacts)


} else {
	alert("If you are using Safari 14.5 set Advanced/Experimental/ContactsAPI to enabled in Safari settings. Otherwise Your browser does not support ContactsAPI yet!");
}//if else supported
}//end function getEmail
//end email code
async function getContacts (selectedContact) {
	if ("contacts" in navigator && "select" in navigator.contacts) {
 try {
   const contacts = await navigator
    .contacts
    .select(
     ['name', 'tel'],
     {multiple: true}
    );
  alert("Number of contacts selected = " + contacts.length);
  for (i=0;i<contacts.length;i++) {
	 selectedContact[i] = contacts[i].name + " " + contacts[i].tel ;
  }//end for loop
  
  alert("Use COPY/PASTE to insert data into table cell. You have selected these contacts: " + contacts[0].name + " " + contacts[0].tel + "\n" + contacts[1].name + " " + contacts[1].tel + selectedContact);
 // selectedContact[][] = contacts;
  return selectedContact;
 } catch {
   console.log("Unexpected error happened in Contact Picker API");
 }
} else {
 alert("Your browser doesn't support Contact Picker API");
}
}//end function getContacts

async function allContactInfo (selectedContact) {
	//(contactsTable) {
	if ("contacts" in navigator && 
    "select" in navigator.contacts && 
    "getProperties" in navigator.contacts) {
 try {
   const availableProperties = await navigator.contacts.getProperties();
     alert('⚠️ Available properties = ' + availableProperties);
	 //Available properties = email,name,tel
     if (availableProperties.includes("address")) {
       const contactProperties = ['name', 'tel','email','address'];
   
       const contacts = await navigator
        .contacts
        .select(
         contactProperties,
         {multiple: true}
        );
		//put contact info in selectedContact array
	alert("Number of contacts selected = " + contacts.length);	
	
	for (i=0;i<contacts.length;i++) {
		selectedContact[i] = contacts[i].name + " " + contacts[i].tel + " " + contacts[i].address;
	// for(c=0;c<4;c++) {
	// 	if(c===0){
	//  selectedContact[i][0] = contacts[i].name;}//end if =0
	//  if(c===1){selectedContact[i][1] = contacts[i].tel;}//end if c=1
	//  if(c===2){selectedContact[i][2] = contacts[i].email;}//end if c=2
	//   if(c===3){selectedContact[i][3] = contacts[i].address;}//end if c=3 
  // }//end for c = loop	
  
 }//end for i loop
		//end of put contact info in selectedContact array
  //console.log changed to alert 
 /*      alert("Your first contact: " + contacts[0].name + " " + contacts[0].tel + " " + contacts[0].address);
	   */
	   
	   test=true;
	  // selectedContact = contacts.slice();
	   return selectedContact;
     } else {
       alert("⚠️ Contact Picker API on your device doesn't support the (street) address property");
	   const contactProperties = ['name','email', 'tel'];
   
       const contacts = await navigator
        .contacts
        .select(
         contactProperties,
         {multiple: true}
        );
		//put contact info in selectedContact array
	alert("Number of contacts selected = " + contacts.length);	

	for (i=0;i<contacts.length;i++) {
		/*if(contacts[i].tel===""||contacts[i].tel===" "||contacts[i].tel===null||contacts[i].tel===undefined) {contacts[i].tel="EDIT"}*/
	 selectedContact[i] = "\n" + contacts[i].name + " " + "_"+contacts[i].tel + " " + "_"+contacts[i].email;
 }//end for i loop
 //end of put contact info in selectedContact array
 //NOTE: "_"+ added to front of each component except first one, so selectedContact array is ready for fine tuning in emailBtn?onclick. "_"+ is used as the separator!
 
 /*
 //THIS CODE BELOW CREATES contactsTable array
var contactsTable = new Array(contacts.length);


//for (var i = 0; i < recordCounter; i++) {
	
for (var i = 0; i < selectedContact.length; i++) {

contactsTable[i] = new Array(4);

}//number of fields means all fields

//if(makeContactsTable) {
	alert("in makeContacts table. selectedContact.length = " + selectedContact.length);

for(i=0;i<contacts.length;i++) {
  for (c=0;c<4;c++) {
     if (c==0) {
		 console.log("selectedContact[i].name = " + selectedContact[i].name);
		 console.log("contactsTable[i][0] = " + contactsTable[i][0]);
      contactsTable[i][0] = contacts[i].name;
	  
	  alert("contactsTable["+i+"][0] = " + contactsTable[i][0]);
	  //contactsTable[i][0] = Steve Ansell
           }//end if c=0
      if(c==1) {
         contactsTable[i][1] = todayString;//date funtion wrong!
		console.log("contactsTable[i][1] = " + contactsTable[i][1]); 
          }//end if c=1
       if (c==2) {
           contactsTable[i][2] = contacts[i].tel;
          }//end c=2
        if (c==3) {
           contactsTable[i][3] = contacts[i].email;
          }//end c=3
    }//end for c=0 loop   
  }//end for i =0 loop
//}//end if makeContactsTable
//}//END if (!test)
//CODE ABOVE CREATES contactsTable array
 */
 
 
 /*
 //  //console.log changed to alert 
       alert("Your first contact: " + contacts[0].name + " " + contacts[0].email + " " + contacts[0].tel);
	 */  
	
	   test=true;
	  // selectedContact = contacts.slice();
	   
/*  
//THIS CODE BELOW CREATES contactsTable array
var contactsTable = new Array(contacts.length);

//for (var i = 0; i < recordCounter; i++) {
	
for (var i = 0; i < contacts.length; i++) {

contactsTable[i] = new Array(4);

}//end for loop 

if(makeContactsTable) {
	alert("in makeContacts table. contacts.length = " + contacts.length);

for(i=0;i<contacts.length;i++) {
  for (c=0;c<4;c++) {
     if (c==0) {
		 console.log("contacts[i].name = " + contacts[i].name);
		// console.log("contactsTable[i][0] = " + contactsTable[i][0]);
      contactsTable[i][0] = contacts[i].name;
	  alert("contacts[i].name = " + contacts[i].name);
	  alert("contactsTable[i][0] = " + contactsTable[i][0]);
	  //contactsTable[i][0] = Steve Ansell
           }//end if c=0
      if(c==1) {
         contactsTable[i][1] = todayString;//date funtion wrong!
		console.log("contactsTable[i][1] = " + contactsTable[i][1]); 
          }//end if c=1
       if (c==2) {
           contactsTable[i][2] = contacts[i].tel;
          }//end c=2
        if (c==3) {
           contactsTable[i][3] = contacts[i].email;
          }//end c=3
    }//end for c=0 loop   
  }//end for i =0 loop
}//end if makeContactsTable

//CODE ABOVE CREATES contactsTable array (contactsTable)
*/
//make sure selectedContact array is clean
//selectedContact = selectedContact.slice(0,contacts.length);
//alert('In allContactInfo function and returning to emailBtn.onclick ..selectedContact before return =    ' + selectedContact);
	//selectedContact = contacts.slice();
	//alert("About to return selectedContact = " + selectedContact);
	//alert("contactsTable array as created in allContactInfo function = " + contactsTable);
	
	
/*	async function getData() {
  myArray = await myFunction();
  console.log(myArray);
  return myArray; */
  

return selectedContact;
//return contactsTable;
	  // return selectedContact;//contactsTable;
     }//end if else includes address
 } catch (ex) {
	// alert("selectedContact[0][0] = " + selectedContact[0][0]);
   alert("Unexpected error happened in Contact Picker API");
   test=false;
 }
} else {
 alert("⚠️ Your browser doesn't support Contact Picker API. If you are using Safari >iOS 14.5 set Advanced/Experimental/ContactsAPI to enabled in Safari settings. Otherwise your browser does not yet support ContactsPickerAPI! DougieBase is creating a sample of contacts for demonstration!");
 	test=true;
	
	//manuallyCreateContacts();//function crahes browser
	let objectContact = [{
	name: "Name of first contact",
	email: "username@gmail.com",
	tel: "Enter phone number"
	},
	{
		name:"Contact Name",
		email: "username@shaw.ca",
		tel: ""
	},
	{
		name:"Contact3 Name",
		email: "username3@telus.net",
		tel: ""
	}];
	for (i=0;i<objectContact.length;i++) {
		/*if(contacts[i].tel===""||contacts[i].tel===" "||contacts[i].tel===null||contacts[i].tel===undefined) {contacts[i].tel="EDIT"}*/
	 selectedContact[i] = "\n" + objectContact[i].name + " " + "_"+objectContact[i].tel + " " + "_"+objectContact[i].email;
 }//end for i loop
	//alert("About to return selectedContact = " + selectedContact);
	return selectedContact;
}//end else
}//end allContactInfo function

//reset table variables after making contacts table restores all main db variable values so that save does not mess up main db after having been in newTable mode
//called from homescrnBtn.onclick and saveBtn and newDBBtn.onclick if makeContactsTable OR loadFromTableOptions..?good enough?
function resetFromContacts () {
	//savedOriginal = false;//flag that prevents repeatedContactsTables from overwriting original. Set back to false here (to allow for changing databases, but not returned to false in CONTACTSbtn in display table which allows for repeated contacts tables but not overwriting original table)
	tableTitle = saveTableTitle.slice();
	//tableArray.length=0;//reset tableArray data clear of contacts before restoring original
	tableArray.length = 0;//empty the array before resetting it ..in edit table may have got messed up?

console.log("mainDBArray = " + mainDBArray);
console.log("mainDBArray[0][0] = " + mainDBArray[0][0]);
console.log("saveTableArray = " + saveTableArray);
console.log("saveTableArray[0][0] = " + saveTableArray[0][0] );

//alertx("mainDBArray = " + mainDBArray);
//alertx("mainDBArray[0][0] = " + mainDBArray[0][0]);
//alertx("saveTableArray = " + saveTableArray);
//alertx("saveTableArray[0][0] = " + saveTableArray[0][0] );


	if(mainDBArray[0][0]!==saveTableArray[0][0]) {
	alert("ERROR! MainDBArray contaminated!!mainDBArray = " +mainDBArray + " saveTableArray = " + saveTableArray);
	}//end if(mainDBArray!=saveTableArray)
tableArray = saveTableArray.slice();
copyOfTableArray = saveCopyOfTableArray.slice(); 
//alert("copyOfTableArray SHOULD BE OIGINAL..NOT CONTACTS! = " + copyOfTableArray);
copyOfTableTitle= saveCopyOfTableTitle.slice();
fieldNamesArray = saveFieldNamesArray.slice();
dbName = saveDbName;
//numberOfDynamicFields=saveNumberOfAdditionalFields;
//numberOfFields=saveNumberOfOriginalFields;
numberOfFields = fieldNamesArray.length;
numberOfDynamicFields = saveNumberOfAdditionalFields;

headName.textContent=saveheadNameTextContent;
//alertx("saveOriginaltableTitleLength = " + saveOriginaltableTitleLength + " otherVariablesArray[1] = " + otherVariablesArray[1]);

console.log("saveOriginaltableTitleLength = " + saveOriginaltableTitleLength + " otherVariablesArray[1] = " + otherVariablesArray[1]);

tableTitle.length = otherVariablesArray[1];

//tableTitle.length=saveOriginaltableTitleLength;//might not need this line because tableTitle is copied and tableTitle.length is calculated
originalNumberRecords = saveOriginalNumberRecords;//restoring back from contacts ..in aid of avoiding refresh request
editCurrentTable = 0;
displayedTable = 0;
tableConstructed = 0;
makeContactsTable = false;
loadFromTableOptions = false;
saveTableBtn.disabled = false;
saveTableBtn.textContent = "SAVE";
saveTableBtn2.disabled = false;
saveTableBtn2.textContent = "SAVE";
//main menu SAVE btn
saveBtn.style.backgroundColor = "rgb(240, 248, 255)";
saveBtn.disabled = false;
homeScreenBtn.textContent = "RETURN to Home Screen";
homeScreenBtn2.textContent = "RETURN to Home Screen";
returnToNotesBtn.setAttribute('class','tdEdit');//added Mar28//to keep homescreen btn on tableScreenOptions from flashing after a rename table session April 17 2022

flipMenu.textContent = "Click - Tap to show / hide TABLE MENU";
		
//alert("in resetFromContacts. tableTitle.length = " + tableTitle.length);
//IF KEEPING DATA MAY NOT WANT NEXT LINES???Date Jan9
//NCJan10..If messed up go back to fallBackJan10
selectedContact.length = 0;//clear selectedContact array and contactsTable array
contactsTable.length = 0;//SHOULD THIS BE contactsArray. Did not change now because what if user wants to go back to contactsTable???
//contactsArray.length = 0;

console.log("in resetFromContacts: tableArray is now back to original db = " + tableArray + " numberOfFields:should be 12! = " + numberOfFields + "  numberOfDynamicFields(8) = "+numberOfDynamicFields + "  numberOfDynamicFields = saveNumberOfAdditionalFields;(savedNumberOfAdditionalFields = " + saveNumberOfAdditionalFields + ". tableID = " + tableID + ". tableIndex = " + tableIndex + ". loadTableIndex = " + loadTableIndex);

//alertx("in resetFromContacts: tableArray is now back to original db = " + tableArray + " numberOfFields:should be 12! = " + numberOfFields + "  numberOfDynamicFields(8) = "+numberOfDynamicFields + "  numberOfDynamicFields = saveNumberOfAdditionalFields;(savedNumberOfAdditionalFields = " + saveNumberOfAdditionalFields + ". tableID = " + tableID + ". tableIndex = " + tableIndex + ". loadTableIndex = " + loadTableIndex);

//ADDED THIS CODE MAY5 2022 to avoid a highlight persisting from a previous search

searchedHitsTableArray.length = 0;
fromSearchRecord = false;
manualContactsEntered = false;
addContactsBtnTapped = false;
fromEditFieldLabels = false;
console.log("in resetFromContacts: tableArray is now back to original db = " + tableArray + " numberOfFields:should be 12! = " + numberOfFields + "  numberOfDynamicFields(8) = "+numberOfDynamicFields + "  numberOfDynamicFields = saveNumberOfAdditionalFields;(savedNumberOfAdditionalFields = " + saveNumberOfAdditionalFields + ". tableID = " + tableID + ". tableIndex = " + tableIndex + ". loadTableIndex = " + loadTableIndex);

newTableEdit = false;//done with this flag now that edited newTable will be saved ? Need to move this line to savevariables???? Date: Febe
	}//end resetFromContacts function THIS IS DIFFERENT THAN CONTACTSARRAY..PROBABLY DON'T NEED SEE ALLCONTACTSINFO FUNCTION
	
//function saveNewTable called by saveTableBtn.onclick with loadFromTableOptions false and makeContactsTable true saving a newTable after its creation
function saveNewTable () {
	console.log("In saveNewTable");
	//NCJan10..If messed up go back to fallBackJan10 below
	
// //code to correct TypeError: undefined is not an object (evaluating 'newTableSpecificVariables[tableIndex][0] = tableIndex').     Current table index = 10 Name of current table = Is this table > 10
// //Reset array vv
// //tableIndex starts at 0 and savedTablesArray indexes will be 0-9 when .length is 10
// if(tableIndex > savedTablesArray.length-1) {
// savedTablesArray.length = savedTablesArray.length + 10;
// newTableSpecificVariables.length = newTableSpecificVariables.length + 10;
	
// }//end if(tableIndex > savedTablesArray.length) 
// //Reset array ^^


	saveTableBtn.textContent = "SAVE";
			// saveTableBtn2.disabled = true;
			saveTableBtn2.textContent = "SAVE";
	//alert("Working on Saving new tables…	Not yet implemented .. is tableArray seen here? .. " + tableArray);
	//return
	//console.log("variablePassed = " + variablePassed);
	//let savedTablesArray = [];
	//redefineSavedTablesArray(savedTablesArray);
	//NCJan10..If messed up go back to fallBackJan10
	
	console.log("Current table index = " + tableIndex + " Name of current table = "+ newTableNames[tableIndex]);
	let savedTableArrayName =  newTableNames[tableIndex];

	console.log("In saveNewTable…. contactsArray = " + contactsArray);//is blank!
	//alert("savedTablesArray[0] = " + savedTablesArray[0]);

	//Assign current contactsArray to name of table
	//create savedTablesArray and ..just push current contactsArray to the index position of tableIndex
	//savedTableArrayName=contactsArray;
	//savedTablesArray =  [];//decalared globally
	
/*	//************************************* */
/*
savedTablesArray[tableIndex+1] = savedTablesArray[tableIndex+1].push(contactsArray);
//savedTablesArray.push(contactsArray);
//TypeError: undefined is not an object (evaluating 'savedTablesArray.push')

/* ************************************* */
/*
//add items to first array index
for (i=0;i<contactsArray.length;i++) {
	
	for (c= 0;c<4;c++) {
savedTablesArray[tableIndex] = contactsArray[i][c];
//TypeError: undefined is not an object (evaluating 'savedTablesArray[tableIndex] = contactsArray.slice()')
	}//end for c =0
//TypeError: undefined is not an object (evaluating 'savedTablesArray[tableIndex]')	
}//end for i = 0
*/
/********************************** */
/*
var savedTablesArray= [];//does this erase savedTablesArray[0]????
//TRY 2 THINGS..REMOVE LINE var savedTablesArray= []; . #2 use a return statement to send savedTablesArray back to saveBtn.onclick

//assume 10 tables?

var savedTablesArray = new Array(10);

//for (var i = 0; i < recordCounter; i++) {
	
for (var i = 0; i < 10; i++) {

savedTablesArray[i] = new Array(4);

}//number of fields means all fields for savedTablesArray there are 4 fields maybe should change back to numberOfFields????
*/



// savedTablesArray[tableIndex] = Array.prototype.push.apply(savedTablesArray, contactsArray);
// savedTablesArray[tableIndex] = Array.prototype.push.apply(contactsArray)
//console.log("savedTablesArray[0] at this point in saveNewTable function should be name DATE tel email IF passed from global! savedTablesArray[0] = " + savedTablesArray[0]);
//TypeError: undefined is not an object (evaluating 'savedTablesArray[0]')
console.log("savedTablesArray = " + Array.isArray(savedTablesArray));
//false after removing var savedTablesArray above…so the savedTablesArray is not being made global? Lets declare it all in this function
//NEXT TRY CONCAT

if(makeHitsTable) {

	savedTablesArray[tableIndex] = searchedHitsTableArray.slice();
//should searchedHitsTableArray.length = 0 be here??May3
searchedHitsTableArray.length = 0;
} else {
	savedTablesArray[tableIndex] = contactsArray.slice();
}//end if else makeHitsTable

//TRY CONCAT nope did not work!
//children = arr1.concat(arr2);
//savedTablesArray[tableIndex] = savedTablesArray[tableIndex].concat(contactsArray);
//alert("After stocking savedTablesArray: " + savedTablesArray); // printed out in first
//TypeError: undefined is not an object (evaluating 'Array.prototype.push.apply(savedTablesArray, contactsArray)')

/********************************** */
console.log("savedTablesArray =  " + savedTablesArray);//should only be 1 array element in this array at this point
/*
AFTER SECOND RUN !!!WHY DID I LOSE savedTablesArray[0] ?
savedTablesArray =  ,
Name of first contact , Jan 14 2022 01:46,Enter phone number ,username@gmail.com,
Contact Name , Jan 14 2022 01:46, ,username@shaw.ca,
Contact3 Name , Jan 14 2022 01:46, ,username3@telus.net
*/
//savedTablesArray =  
/*Name of first contact , Jan 11 2022 01:34,Enter phone number ,username@gmail.com,
Contact Name , Jan 11 2022 01:34, ,username@shaw.ca,
Contact3 Name , Jan 11 2022 01:34, ,username3@telus.net. */

/*savedTablesArray[0] = 
Name of first contact , Jan 11 2022 01:34,Enter phone number ,username@gmail.com,
Contact Name , Jan 11 2022 01:34, ,username@shaw.ca,
Contact3 Name , Jan 11 2022 01:34, ,username3@telus.net*/

console.log("savedTablesArray[0] = " + savedTablesArray[0]);
//savedTablesArray[0] = 
/*
Name of first contact , Jan 14 2022 01:46,Enter phone number ,username@gmail.com,
Contact Name , Jan 14 2022 01:46, ,username@shaw.ca,
Contact3 Name , Jan 14 2022 01:46, ,username3@telus.net 

AFTER SECOND RUN …
savedTablesArray[0] = undefined*/
console.log("savedTablesArray[1] = " + savedTablesArray[1]);
// savedTablesArray[1] = name2,DATE,tel2,email2

/*AFTER FIRST RUN savedTablesArray[1] = 
savedTablesArray[1] = name2,DATE,tel2,email2
savedTablesArray[0] = 
Name of first contact , Jan 16 2022 01:19,Enter phone number ,username@gmail.com,
Contact Name , Jan 16 2022 01:19, ,username@shaw.ca,
Contact3 Name , Jan 16 2022 01:19, ,username3@telus.net*/
//to retrieve get savedTablesArray[tableIndex], assign name from newTableNames array and set tableArray to it in the setup(tableNamed) function 
	//newTableVariablesArray declared globally above
	tableListExists = true;
	newTableVariablesArray = [tableIndex,newTableNames,tableListExists];
	console.log("newTableVariablesArray = " + newTableVariablesArray);
//	TypeError: undefined is not an object (evaluating 'newTableSpecificVariables[tableIndex][0] = tableIndex')
	newTableSpecificVariables[tableIndex][0] = tableIndex;
//TypeError: undefined is not an object (evaluating 'newTableSpecificVariables[tableIndex][0] = tableIndex')…because tableIndex is -1	tableIndex is a load table variable and doesn't get set until loading in a table…so NOT the variable to use on setting up create newTable!!
//ALSO GET SAME ERROR IF TABLE INDEX > newTableSpecificVariables.length as the array is only defined for 10..same with savedTablesArray..so try new code to increase array if tableIndex > savedTablesArray??? See setupNewTable or saveNewTable ?? for this code

//if newTable being created no extra fields at this point! Unless ADDED CONTACTS from menu .. so lets just leave out !!! Mar 21 2022 !!!!
//numberOfNewTableAddedFields = 0;
newTableSpecificVariables[tableIndex][2] = numberOfNewTableAddedFields;
	newTableSpecificVariables[tableIndex][1] = newTableFieldsArray;
	
	
	//newTableVariablesArray = 0,Contacts0,true
	//newTableVariablesArray = 0,Contacts0,false
	//newTableVariablesArray = 0,Contacts0,false
	//after second run ..newTableVariablesArray = 1,Contacts0,Contacts1,false
	//three new variables to be saved to objectStore similar to preferences variable..savedTablesArray,newTableVariablesArray. (tableIndex, newTableNames and tableListExists) variables are used in tableScreenOptions on startup
	//alert("About to save " + savedTableArrayName + " savedTablesArray " + savedTablesArray +" ! stop here");
	
	//ReferenceError: Can't find variable: savedTableArrayName
	//any additional prep before saveVariables function is called goes here..below
	//NEED TO RESTORE ORIGINAL DB VALUES OF TABLEARRAY BEFORE GOING TO SAVEVARIABLES!!
	resetFromContacts();
	//now tableArray etc restored, contactsArray cleared. HAVE TO RESET makeTable flag because it was set to false in resetFromContacts which is also used by returnToNotes btn.
	makeContactsTable = true;//when to make false again? Might be that leaving false in resetFromContacts is correct? Check!!!!
	console.log("In saveNewTable, on the way back to saveBtn.onclick then saveVariables… to …after retrieving dataVobj…….tableIndex = " + tableIndex + " tableListExists = " + tableListExists + " newTableNames = " + newTableNames);
	console.log('In saveNewTable function: makeContactsTable should now be true .It was set to false in restoreFromContacts in preparation for savingVariables, and just now reset to true…. = '+makeContactsTable); 

	//alert("In saveNewTable.. tableListExists = " + tableListExists);
	//return savedTablesArray;
	//any additional prep before saveVariables function is called goes here..above
	//variables to be added to objectStore:
	//savedTablesArray
	//newTableVariablesArray
}//end function saveNewTable
//NCJan10..If messed up go back to fallBackJan10..above

function clearFoundRecordListFunc () {
		//code below clears any pre-existing records in foundRecordList of search to prevent glitch that happens if a pre-existing foundRecord is tapped on after searched Contacts
			
			foundRecordsList = false;//flag to clear a prexisting foundRecordsList so that a fresh loaded db does not use an old foundRecordList June 18 2021
	while (resultList.firstChild) {
    resultList.removeChild(resultList.firstChild);
}//end while
console.log('Clearing the record list after clearRecordListBtn.onclick..foundRecordsList = ' + foundRecordsList);

liMatchedRecord.textContent = "If record found it will appear below: Tap record title to view its notes";
//these lines added Jan3
selectedContact.length = 0;//clear selectedContact array and contactsTable array
contactsTable.length = 0;
//SHOULD THIS BE contactsArray.length = 0;

//code ABOVE clears any pre-existing records in foundRecordList of search to prevent glitch that happens if a pre-existing foundRecord is tapped on after searched Contacts
}//end clearFoundRecordListFunc

//cutname function is used in emailBtn.onclick
function cutName(namestr) {
  var newArray = namestr.split('_');
  return newArray;
}//end function cutname


//this function does not work.causes an endless loop that crashes the browser
//called from addContactsBtn.onclick
//manualContacts and contactsArray set to 0 from addContactsBtn.onclick
//also called from PlusContacts
async function manuallyCreateContacts
() {
/*alert("In manually createContacts: contactsFieldNames[5] =  " + contactsFieldNames[5]);
*/

//allow for only 4 fields
if(newTableFieldsArray.length === 4 || contactsFieldNames.length === 4) {
fifthFieldLabel.style.display = "none";
contactsAddress.style.display = "none";
} else if(newTableFieldsArray.length > 4 || contactsFieldNames.length > 4) {
fifthFieldLabel.style.display = "unset";
contactsAddress.style.display = "unset";
}//end if(newTableFieldsArray.length === 4)

//code to change text of field labels prompt
//added conditional plusContacts
if(contactsFieldNames.length !== 0 || plusContacts) {
firstFieldLabel.textContent = contactsFieldNames[0];
thirdFieldLabel.textContent = contactsFieldNames[2];
fourthFieldLabel.textContent = contactsFieldNames[3];
//alert("newTableSpecificVariables[tableIndex][1].length = " +newTableSpecificVariables[tableIndex][1].length);

//May 12 REMOVED LINE: || newTableSpecificVariables[tableIndex][1].length > 4) because if you startba virgin table as an addContacts, tableIndex = -1 and this stops program execution!!

	if(newTableFieldsArray.length > 4 || contactsFieldNames.length > 4){
fifthFieldLabel.textContent = contactsFieldNames[4];}//end if(contactsFieldNames.length > 4) 
} else {
firstFieldLabel.textContent = "Name of Contact: ";
thirdFieldLabel.textContent = "Telephone number: ";
fourthFieldLabel.textContent = "Email Address: ";
fifthFieldLabel.textContent = "Address: ";
}//end if else (contactsFieldNames.length !== 0)
//code to change text of field labels prompt
/*if(addFromContacts) {
tableNameText.textContent = "";
} else {*/
if(plusContacts) {
tableNameText.textContent = newTableNames[loadTableIndex];//added May9 not tested
} else {
	tableNameText.textContent = "";
}//end if(fromPlusContacts)

/*if(newTableFieldNames.length > 5) {
alert("For the remaining" + contactsFieldNames.length-5 + "dynamic fields, enter data directly into the table data cells from the table chart.");	
}//end if(contactsFieldNames.length > 5)
*/
manualContactsEntered = true;
console.log("at manuallyCreateContacts function");
showTable.setAttribute('class','hidden');
manualContactsWindow.setAttribute('class', 'showing');

	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	manualContactsWindow.style.backgroundColor = "black";
	manualContactsWindow.style.color = "white";
	//showNewTableNameP.style.color = "white";
} else {
	manualContactsWindow.style.backgroundColor = "#eee";
	manualContactsWindow.style.color = "black";
	//showNewTableNameP.style.color = "black";
}//end if else screenDark#

 getManualContacts(contactsArray);


console.log("Back from getManualContacts. ");
//alertx("Back from getManualContacts. ");
 
	
 // }//end function enterContactBtn.onclick
 
 
 clearContactEntryBtn.onclick = function() {
contactsNameInput.value = "";
	telephoneInput.value = "";
	contactsEmailInput.value = "";
	contactsAddress.value ="";
	statusContactEntryP.textContent = "";	 
	 
 }//end clearContactEntryBtn.onclick
 
 
//NC Date:Jan9
cancelAllBtn.onclick = function () {
//alert("CANCEL BTN TAPPED");
manualContactsEntered = false;
	//selectedContact.length = 0;
	//TypeError: undefined is not an object (evaluating 'selectedContact.length = 0')
	contactsNameInput.value = "";
	telephoneInput.value = "";
	contactsEmailInput.value = "";
	contactsAddress.value ="";
	statusContactEntryP.textContent = "";
//trying to prevent keyboard pop up on cancel..does not work!!
	contactsNameInput.value = "\n";
	//manualContactsForm.blur();
	contactsNameInput.blur();
	document.activeElement.blur();//remove focus from inputs so keyboard does not pop up on cancel .. does not work
statusContactEntryP.setAttribute('class','normalBtn');//stop flashing but bckgrnd reset to black below
statusContactEntryP.style.backgroundColor = "black";
manualContactsWindow.setAttribute('class', 'hidden');
//more reset variables in aid of stability?   Vv
loadFromTableOptions = false;
resetFields = true;//trying to correct messed up field headers if addContacts/Records CANCELLED May12 2022
resetFromContacts();
//more reset variables in aid of stability?   ^^
//showTable.setAttribute('class', 'showing');//commented out so that an empty table screen can not be shown which would eventually lock up prgm
 //added Mar27….check manual contacts still cancels ok..added to cancel addingMoreContactsManually	
	}//end cancelAllBtn.onclick
//NC
	
 }//end function manuallyCreateContacts
 
 //saveOriginal function retains the main database variable values to restore after viewing newTables
 function saveOriginal () {
	console.log("In saveOriginal function");
	savedOriginal = true;
saveTableTitle= tableTitle.slice();
saveTableArray = tableArray.slice();
saveOriginaltableTitleLength = tableTitle.length;
saveCopyOfTableArray = copyOfTableArray.slice();
saveCopyOfTableTitle= copyOfTableTitle.slice();//this is the original tableTitle. Have not created a new tableTitle aray for contacts. Do I need to? Copy of arrays used in sort to restore original order

//Troubleshoot
saveFieldNamesArray = fieldNamesArray.slice();
saveNumberOfOriginalFields= numberOfFields;//otherVariablesArray[3]
saveNumberOfAdditionalFields=numberOfDynamicFields;//otherVariablesArray[4]
saveOriginalNumberRecords = originalNumberRecords;//otherVariablesArray[1] ////this was equated to contacts originalNumberRecods to prevent refresh request in tableScreenOptions

//Troubleshoot
saveDbName = dbName;
}//end function saveOriginal if !savedOriginal

//function to redefine savedTablesArray if a database does not yet have it ..backwards compatable!

function redefineSavedTablesArray () {
	console.log("In redefineSavedTablesArray functio…did I make it?");
	let savedTablesArray = [];
//for (var i = 0; i < recordCounter; i++) {

for (var i = 0; i < 10; i++) {

savedTablesArray[i] = new Array(4);

}//number of fields means all fields for savedTablesArray there are 4 fields maybe should change back to numberOfFields????

savedTablesArray[0] = ["name","DATE","tel","email"];
savedTablesArray[1] = ["name2","DATE","tel2","email2"];

for (var i = 0; i < 10; i++) {
//these lines added Mar 21 v
newTableFieldsArray.length = 0;
numberOfNewTableAddedFields = 0;
tableIndex = -1;
//these lines added Mar 21 ^
newTableSpecificVariables[i] = [tableIndex, newTableFieldsArray, numberOfNewTableAddedFields];

}//number of fields means all fields for savedTablesArray there are 4 fields maybe should change back to numberOfFields????

	

	return savedTablesArray;
//return savedTablesArray,newTableSpecificVariables;
}//end function redefineSavedTablesArray
//test i = 20 was 10
function redefinenewTableSpecificVariables () {
	for (var i = 0; i < 10; i++) {
	
//these lines added Mar 21 v (its a new database!)
newTableFieldsArray.length = 0;
numberOfNewTableAddedFields = 0;
tableIndex = -1;
//these lines added Mar 21 ^

newTableSpecificVariables[i] = [tableIndex, newTableFieldsArray, numberOfNewTableAddedFields];

	}//end for i loop
//alertx("newTableSpecificVariables =  " + newTableSpecificVariables);
console.log("newTableSpecificVariables =  " + newTableSpecificVariables);

	return newTableSpecificVariables;
}//end function redefinenewTableSpecificVariables()

//create setupNewTable(tableNamed) function called from create contacts..emaiBtn.onclick NOTE savedTableArray NOT created until saveBtn.onclick if makeContactsTable = true! So at point of saveBtn.onclick prior to first save savedTavpbkesArray is empty!
//APRIL 7 removed async..
 function setupNewTable() {
 
 //code to correct TypeError: undefined is not an object (evaluating 'newTableSpecificVariables[tableIndex][0] = tableIndex').     Current table index = 10 Name of current table = Is this table > 10
//Reset array vv
//tableIndex starts at 0 and savedTablesArray indexes will be 0-9 when .length is 10
// if(tableIndex > savedTablesArray.length-1) {
// savedTablesArray.length = savedTablesArray.length + 10;
// newTableSpecificVariables.length = newTableSpecificVariables.length + 10;
	
// }//end if(tableIndex > savedTablesArray.length) 
//Reset array ^^


if(makeContactsTable && contactsFieldNames.length === 0) { 
contactsFieldNames[0]="CONTACT NAME";
contactsFieldNames[1]="DATE";
contactsFieldNames[2]="TELEPHONE";
contactsFieldNames[3]="EMAIL";

//alertx("in setUpNewTable contactsFieldNames0 and fromEditFieldLabels = " +fromEditFieldLabels);
console.log("in setUpNewTable contactsFieldNames0 and fromEditFieldLabels = " +fromEditFieldLabels);


if(manualContactsEntered || addContactsBtnTapped || fromEditFieldLabels) {
contactsFieldNames[4]="ADDRESS";
// //not tested Mar26 to prevent extra field being added if preceding new table had an extra field
contactsFieldNames.length = 5;	
addContactsBtnTapped = false;//May5 2022
}//end if manualContactsEntered

//alertx("The new table Field Names (contactsFieldNames) are set to: " + contactsFieldNames);
console.log("The new table Field Names (contactsFieldNames) are set to: " + contactsFieldNames);

}//end if(makeContactsTable && contactsFieldNames[0]= "" ||)


//TypeError: undefined is not an object (evaluating 'newTableFieldsArray.slice')

// if(newTableSpecificVariables[tableIndex][1] === undefined) {
// 	newTableFieldsArray = contactsFieldNames.slice();
// } else {
// contactsFieldNames = newTableSpecificVariables[tableIndex][1].slice();
// }//end if(newTableSpecificVariables[tableIndex][1] === undefined) 


// if(newTableFieldsArray === undefined) {
// 	newTableFieldsArray = contactsFieldNames.slice();
// } else {
// contactsFieldNames = newTableFieldsArray.slice();
// }//end if(newTableFieldsArray === undefined) 

// if(newTableSpecificVariables[tableIndex][2] === undefined) {
// 	numberOfNewTableAddedFields = 0;
// } else {
//  numberOfNewTableAddedFields = newTableSpecificVariables[tableIndex][2];
// }//end if(newTableSpecificVariables[tableIndex][2] === undefined)

//numberOfNewTableAddedFields = newTableVariablesArray[4];

//save the original tableArray and fieldNamesArray IF savedOriginal = false!. This is so original is not changed to past instances of contactsTables;
//make a function out of saving original tableArray values..but test immediately to be sure we can transfer array  values from a function!
//alertx("savedOriginal = " + savedOriginal);
if(!savedOriginal) {saveOriginal();}//works
console.log("Back from/ or past  saveOriginal function");

//saveNumberOfAdditionalFields=numberOfDynamicFields;//don't need if in savedOriginal?

//alert("In function setupNewTable.. The saved original tableArray = " + saveTableArray);//the original database..not the new table!
//alert("savedTablesArray[0] = " + savedTablesArray[0]);
//MAKE CODE BELOW INTO THE 
if(makeContactsTable || loadFromTableOptions) {
	//for pupose of displaying contacts in table set tableArray used in displayTable to the contacts values, then after done with creating contactsTable restore to saved values so we get the original database table back
	

	if (makeContactsTable) {
//NOTE TABLE INDEX STARTS AT -1 creating array of new tables. Saved in newTableVariables array[0]
tableIndex = tableIndex +1;//add to title of table starts at -1

tableID = tableIndex;//for purpose of identifying correct newTableSpecificVaiable to save fieldNamesArray to
//*#####################this code did not work!
//alertx("In setUpNewTable function - contactsFieldNames " + contactsFieldNames);
//CODE TO EDIT FIELD NAMES OF NEW TABLE v
//when coming from addContacts tableArray at this point is still main db so this code won't run..not what we want
//if(!tableArray[0][0].includes(">")) {
//exclude searched table from main db

//await editNewTableFieldNames(contactsFieldNames);

/*


 //confirm choice window
		 if (window.confirm("Do you want to re-label field names for this new Table ? : \n" + "  CANCEL will retain default field names for a CONTACTS table.")) {
	
 editNewTableFieldNames(contactsFieldNames);
//!!!!!!!!!?,!L
// alert("at editNewTableFieldNames");

// //Check if screenDark mode
// checkScreenMode();
// if(screenDark) {
// alert("screen dark");	editNewTableFieldNamesWindow.style.backgroundColor = "black";
// 	editNewTableFieldNamesWindow.style.color = "white";
// 	showNewTableNameP.style.color = "white";
// } else {
// 	editNewTableFieldNamesWindow.style.backgroundColor = "#eee";
// 	editNewTableFieldNamesWindow.style.color = "black";
// 	showNewTableNameP.style.color = "black";
// }//end if else screenDark
// alert("should now show editNewTableFieldNames");
// console.log("should now show editNewTableFieldNames");
// showTable.setAttribute('class','hidden');
// newTableNameWin.setAttribute('class', 'hidden');//added Apr7
// editNewTableFieldNamesWindow.setAttribute('class', 'showing');	

// enterNewFieldNameBtn.setAttribute('class','borderBlinkGrn');

// alert("editNewTableFieldNamesWindow should open");
// clearFieldNameEntryBtn.onclick = function() {
// firstFieldNameNTInput.value = "";
// 	secondFieldNameNTInput.value = "";
// 	thirdFieldNameNTInput.value = "";
// 	fourthFieldNameNTInput.value ="";
// 	statusFieldNamesEntryP.textContent = "";	 
	 
//  }//end clearFieldNameEntryBtn.onclick

// cancelAllFieldNamesBtn.onclick = function () {
// //alert("CANCEL BTN TAPPED");
// enterNewFieldNameBtn.setAttribute('class','attentionBtn');
// manualContactsEntered = false;
// 	//selectedContact.length = 0;
// 	//TypeError: undefined is not an object (evaluating 'selectedContact.length = 0')
// 	firstFieldNameNTInput.value = "";
// 	secondFieldNameNTInput.value = "";
// 	thirdFieldNameNTInput.value = "";
// 	fourthFieldNameNTInput.value ="";
// 	statusFieldNamesEntryP.textContent = "";	 

// statusContactEntryP.setAttribute('class','normalBtn');
// manualContactsWindow.setAttribute('class', 'hidden');
// //showTable.setAttribute('class', 'showing');
//  //added Mar27….check manual contacts still cancels ok..added to cancel addingMoreContactsManually	
// 	}//end cancelAllFieldNamesBtn

// finishedFieldNamesEntryBtn.disabled = true;
//  enterNewFieldNameBtn.onclick = function() {
//  finishedFieldNamesEntryBtn.disabled = false;
//  /*
// i++
// 	selectedContact[i] = "\n" + contactsNameInput.value + " " + "_"+telephoneInput.value + " " + "_"+contactsEmailInput.value + " " +
// 		"_"+contactsAddress.value;
	
// 	statusContactEntryP.textContent = selectedContact[i] +  " has been submitted. Tap DONE after all contacts entered.After tapping DONE,  Tap HERE to register edited entries.";
// */



// contactsFieldNames[0]=firstFieldNameNTInput.value;
// contactsFieldNames[1]="DATE";
// contactsFieldNames[2]=secondFieldNameNTInput.value;
// contactsFieldNames[3]=thirdFieldNameNTInput.value;

// if(manualContactsEntered) {
// contactsFieldNames[4]=fourthFieldNameNTInput.value;
// //not tested Mar26 to prevent extra field being added if preceding new table had an extra field
// contactsFieldNames.length = 5;	
// }//end if manualContactsEntered 

// statusFieldNamesEntryP.textContent =  contactsFieldNames +  " The above Field Names have been entered! Tap DONE after all contacts entered.After tapping DONE,  Tap HERE to register edited entries.";
// //return contactsFieldNames;
// }//end enterNewFieldNameBtn.onclick

//!!!!!!?,!!??,!!
	
/*	
		 } else {
	//if(makeContactsTable) {
contactsFieldNames[0]="CONTACT NAME";
contactsFieldNames[1]="DATE";
contactsFieldNames[2]="TELEPHONE";
contactsFieldNames[3]="EMAIL";

if(manualContactsEntered) {
contactsFieldNames[4]="ADDRESS";
//not tested Mar26 to prevent extra field being added if preceding new table had an extra field
contactsFieldNames.length = 5;	
}//end if manualContactsEntered 
		 }//end choice window
*/		 
//}//end if(!tableArray[0][0].includes(">")) {
//CODE TO EDIT FIELD NAMES OF NEW TABLE ^

/*
if(newTableSpecificVariables[tableIndex][1] === undefined || newTableSpecificVariables[tableIndex][1] === "" || newTableSpecificVariables[tableIndex][1] === " " || newTableSpecificVariables[tableIndex][1] === null) {
	newTableFieldsArray = contactsFieldNames.slice();
} else {
contactsFieldNames = newTableSpecificVariables[tableIndex][1].slice();//this statement won't run because table is just being created..not even saved yet!
}//end if(newTableSpecificVariables[tableIndex][1] === undefined) 

//*#####################this code did not work!
*/
//IF CREATING A NEWTABLE FOR THE FIRST TIME THERE WILL BE NO NEWFIELDS ADDED YET!

//TypeError: undefined is not an object (evaluating 'newTableSpecificVariables[tableIndex][1] = contactsFieldNames.slice()')//MAR14
//I THINK WHAT IS HAPPENING HERE IS THAT AS i have deleted tables the array keeps shrinking and now newTableSpecificVariables[tableIndex] does not exist….SO HAVE TO UPDATE ARRAY LENGTH AS I DELETE TABLES.???yep because running in a new table with 10 intact slots for newTableSpecificVariables does work!SO IF YOU DELETE A TABLE YOU HAVE TO ADD A SLOT!
//if creating a new table from a new table loadFromTableOptions and makeContactsTable are both true!
if(makeHitsTable && !loadFromTableOptions) {  
//searched a main database table
//alertx('in makeHitsTable and setUpNewTable - fieldNamesArray = ' + fieldNamesArray);
console.log('in makeHitsTable and setUpNewTable - fieldNamesArray = ' + fieldNamesArray);

newTableFieldsArray = fieldNamesArray.slice();
newTableSpecificVariables[tableIndex][1] = fieldNamesArray.slice();
//alertx('newTableSpecificVariables[tableIndex][1] = ' + newTableSpecificVariables[tableIndex]);
console.log('newTableSpecificVariables[tableIndex][1] = ' + newTableSpecificVariables[tableIndex]);
//-1 and 0 at end
//will save a flag that indicates if new table derived from a searchmain db in aid of preventing + - icons appearing in such a table..aadding a record herevwould crash! USED A CONDITIONAL INSTEAD..DETECTING A > IN TABLEARRAY[0][0] indicates new table is from a searched main db table so want to prevent apoearancr of + - icons ..if used would crash

//at this poinr fieldNamesArray should still = main db data ^ but now if both loadFromTableOptions and makeContactsTable are true, newFieldsArray should be that of the new table we are creating this new table from!
} else if (makeHitsTable && loadFromTableOptions) {
//searched a new table (CONTACTS)
newTableFieldsArray = newTableFieldsArray.slice();
newTableSpecificVariables[tableIndex][1] = newTableFieldsArray.slice();
//alert indicated newTableFieldsArray was correct, but newTableSpecificVariables did not reflect 5 fields last one address until alerts in the save section of code…not sure why but still seems to work!!! Mar26 2022
////not tested Mar26 to prevent extra field being added if preceding new table had an extra field
} else if (manualContactsEntered) {
//alert("In else if manualContactsEntered — manualContactsEntered = " + manualContactsEntered);//date Mar19 2023

newTableFieldsArray = contactsFieldNames.slice();
//should this line be here.
//newTableSpecificVariables[tableIndex][1] = contactsFieldNames.slice();
} else {
newTableFieldsArray = contactsFieldNames.slice();
newTableSpecificVariables[tableIndex][1] = contactsFieldNames.slice();
}//end if else makeHitsTable
//should newTableSpecificVariables[tableIndex][1] = newTableFieldsArray.(slice); ??

if(manualContactsEntered) {
	numberOfNewTableAddedFields = 1;
	numberOfDynamicFields = 1;
	} else if(makeHitsTable) {
	numberOfNewTableAddedFields = numberOfDynamicFields;//numberOfDynamicFields should = main db data at this point
	numberOfDynamicFields = numberOfDynamicFields;
	
	} else {
numberOfNewTableAddedFields = contactsFieldNames.length-4;
numberOfDynamicFields = numberOfNewTableAddedFields;
//numberOfNewTableAddedFields = 0;
//numberOfDynamicFields = 0;
	}//end if else manualContactsEntered

newTableSpecificVariables[tableIndex][2] = numberOfNewTableAddedFields;

//newTableSpecificVariables[tableID][0] = newTableEdit;//not using this variable as of Feb13

//alertx("In makeContactsTable: tableIndex = " +tableIndex + "  newTableFieldsArray = " + newTableFieldsArray + " newTableSpecificVariables[" + tableIndex +"][1] = " + newTableSpecificVariables[tableIndex][1]+ ".  savedTablesArray.length = " + savedTablesArray.length + ". newTableSpecificVariables.length = " + newTableSpecificVariables.length);

console.log("In makeContactsTable: tableIndex = " +tableIndex + "  newTableFieldsArray = " + newTableFieldsArray + "  newTableSpecificVariables[" + tableIndex +"][1] = " + newTableSpecificVariables[tableIndex][1]+ ".  savedTablesArray.length = " + savedTablesArray.length + ". newTableSpecificVariables.length = " + newTableSpecificVariables.length);
//newTableSpecificVariables[0][1]= undefined..so is [0][2]…created by createNewDB so I think I have messed up the initialization of the newTableSpecificVariables[tableIndex][1] array. Put []around it in saveVariables
//*#####################this code below did not work!
/*
if(newTableSpecificVariables[tableIndex][2] === undefined) {
	numberOfNewTableAddedFields = 0;
} else {
 numberOfNewTableAddedFields = newTableSpecificVariables[tableIndex][2];
}//end if(newTableSpecificVariables[tableIndex][2] === undefined)
*/
//*#####################this code above did not work!


//alertx("At setupNewTable: creating a newTable! In makeContactsTable: (newTableFieldsArray)..this is the field names of the newTable .. tableIndex variable now =  " + tableIndex + ".  tableID = " +tableID + "   newTableSpecificVariables[tableIndex][1] = " + newTableSpecificVariables[tableIndex][1] + " (number of dynamic fields in new table should be 0 at time of creating the new table…— numberOfNewTableAddedFields - newTableSpecificVariables[tableIndex][2] = "  + newTableSpecificVariables[tableIndex][2]);

console.log("At setupNewTable: creating a newTable! In makeContactsTable: (newTableFieldsArray)..this is the field names of the newTable .. tableIndex variable now =  " + tableIndex + ".  tableID = " +tableID + "   newTableSpecificVariables[tableIndex][1] = " + newTableSpecificVariables[tableIndex][1] + " (number of dynamic fields in new table should be 0 at time of creating the new table…— numberOfNewTableAddedFields - newTableSpecificVariables[tableIndex][2] = "  + newTableSpecificVariables[tableIndex][2]);

//enter newTableName
// newTableNameWin.setAttribute('class','showing');
// 	newTableNameSubmitBtn.onclick = function () {
// 		newTableName = newTableNameInput.value;
// 		newTableNameWin.setAttribute('class','hidden');
// 		//return newTableName;
// 	}//end of submitBtn.onclick
	
	//newTableNameInput.value = "";

	
//x-xxxxx—xxxx 	
//newTableName = 	getNewTableName();
//getNewTableName();	
//-x—-x—-xxxxx-
//enter newTableName
 //await getNewTableName ();
 //SyntaxError: Unexpected identifier 'getNewTableName'
 //newTableNameWin.setAttribute('class','showing');
//getNewTableName();//this function will use html window
// if(newTableName==="") {
// await getNewTableName();//await does not work!!!
// 	//newTableName="Contacts";
// }//end if newTableName === ""
if(newTableName==="") {
	newTableName="Contacts";
}//end if newTableName === ""
//alert("newTableName = " + newTableName);
flipMenu.textContent = " ✅ New Table Name: " + newTableName;//have to repeat this for second run to get it to work.not sure why?????Date: Jan2
//return false;
dbName = newTableName+tableIndex;
newTableNames[tableIndex]= dbName;//make an array variable to keep track of all new tables
//setup tableArray for displayTable function to reflect contacts or newTable data
//alertx("testing contactsArray after manual get contacts. " + contactsArray);
console.log("testing contactsArray after manual get contacts. " + contactsArray);
tableArray = tableArray.slice(0,tableTitle.length);//clear tableArray from main db data
//tableArray.length = 0;makesberror?stops runnuing
//tableArray= contactsTable.slice();

if(makeHitsTable) {

//alertx("At setupNewTable: creating a newTable!. makeHitsTable is true..searchedHitsTableArray = " + searchedHitsTableArray);
console.log("At setupNewTable: creating a newTable!. makeHitsTable is true..searchedHitsTableArray = " + searchedHitsTableArray);


	tableArray = searchedHitsTableArray.slice();
	//should searchedHits be cleared here??NO BECAUSE YOU NEED THIS CURRENT FOR SAVING DATA?

} else {
	tableArray = contactsArray.slice();

}//end if else makeHitsTable

//TO SET UP SORTING OF CONTACTS TABLE —

//RETEST SORT. CHANGE VARIABLE ???? copyOfTableTitle NAME TO copyforSortTableTitle and use makeContactsTable variable true to use it

copyOfTableTitle=tableTitle.slice();//these are for sorting of contacts table. NOTE copyOfTableTitle is same as original ..this is NOT the contacts! So do I need it in sort? Should just need tableTitle.length which will be selectedContact.length
copyOfTableArray = tableArray.slice();
//copyOfTableArray only changes IF makeContactsTable is true so maybe don't need to change variable name?
//above puts the contactTable data into the copyTableArray variable to be used if sorting and restoring order. Of contacts table MAYBE SHOULD USE copy Of for SortTableArray?

//IF LOADING A SPECIFIC NEWTABLE tableIndex variable should be replaced with loadTableIndex as tableIndex increases by one for every new table created but loadTableIndex is static for its own specific table!!!!..this change is made Feb5 after all initial newTables have been previously created
//newTableSpecificVariables[tableIndex][1].slice();

//fieldNamesArray = contactsFieldNames.slice();
fieldNamesArray = newTableFieldsArray.slice();



console.log('tableArray = ' +tableArray+ ' fieldNamesArray = '+ fieldNamesArray + '. tableIndex = '+ tableIndex)


//datem:Feb2 commented out numbrtOfAdditionalFields now that edit contacts table is allowed not needed in makeContactsTable?
numberOfDynamicFields = numberOfNewTableAddedFields;
console.log('numberOfDynamicFields = ' +numberOfDynamicFields);
// saveNumberOfFields= numberOfFields;
//numberOfFields=4;

if(makeHitsTable) {
	numberOfFields = newTableFieldsArray.length;

} else {
	numberOfFields = contactsFieldNames.length;
}//end if else makeHitsTable


saveheadNameTextContent =headName.textContent 
console.log('In makeContactsTable: numberOfFields = ' +numberOfFields);
headName.textContent ="CONTACT";
//savetableTitleLength= tableTitle.length;//original tableTitle length
//tableTitleLength = selectedContact.length;i.e. the number of selected contacts

if(manualContactsEntered) {
	tableTitle.length = contactsArray.length;
	newTableContactsTitleLength = contactsArray.length;	
	manualContactsEntered = false;
	// plusContactsEntered = true;////using this flag to prevent home btn from flashing after creating a + contact ..made false in saveTableBtn.onclick Date-Mar21 2023
} else if (makeHitsTable) {
	tableTitle.length = searchedHitsTableArray.length;
	newTableContactsTitleLength = searchedHitsTableArray.length;

} else {
	tableTitle.length = selectedContact.length;
	newTableContactsTitleLength = selectedContact.length;//a global variable so that sort can use it
}//end if(manualContactsEntered)

originalNumberRecords = tableTitle.length;//the contacts length! ADDED THIS Jan18 ..not tested. In aid of preventing request for table refresh! This will be returned to original in the resetFromContacts function..not actually The originakNumberRecords of db main but the number to use in the contacts table formulation and neceesary to prevent trigger of table refresh.

//alertx("testing from manual contacts. tableTitle.length =  " + tableTitle.length);
console.log("testing from manual contacts. tableTitle.length =  " + tableTitle.length);
//saveOriginalNumberRecords = originalNumberRecords;
// originalNumberRecords = tableTitle.length;//the contacts length! ADDED THIS Jan18 ..not tested. In aid of preventing request for table refresh! This will be returned to original in the resetFromContacts function
blockEdit = true//flag to prevent a dblclick td edit until newtable is saved and initialized by return to home screen
//homeScreenBtn.setAttribute('class','borderBlink');
//homeScreenBtn2.setAttribute('class','borderBlink');
}//end if makeContactsTable

if(loadFromTableOptions && !makeHitsTable) {
	console.log("In setupNewTable…loadFromTableOptions….loadTableIndex = " + loadTableIndex + "  makeContactsTable = " +makeContactsTable);
	//loadTableIndex comes from addEventListener of tableScreenOptions
if(!savedTablesArray[loadTableIndex]) {
	alert("ERROR! YOU DID NOT SAVE THIS NEW TABLE SO IT DOES NOT EXIST!");
	tableScreen.setAttribute('class','hidden');
}

/*
//code below will block all table loads because data is not yet loaded!
if(savedTablesArray[loadTableIndex][0] = null || undefined || "" || " ") {
	alert("ERROR! An error occurred loading this table. It may not have been saved after creation or an illegal entry made? Suggest deleting this table and re-creating?");
	
tableScreen.setAttribute('class','showing');	

//tableScreen.setAttribute('class','showing');
return;
}
*/

	//In setupNewTable…loadFromTableOptions….loadTableIndex = 3makeContactsTable = false
	//NOTE! NewTableVariablesArray needs two parts..the fieldNamesArray and numberOfDynamicFields needs to be saved for each newTable!
	console.log(" In setupNewTable, loadFromTableOptions: savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex] + ".  tableArray and tableTitle.length reflect this for newTable mode code!");
	// In setupNewTable, loadFromTableOptions: savedTablesArray[loadTableIndex] = ,,,.  tableArray and tableTitle.length reflect this for newTable mode code!
	tableArray= savedTablesArray[loadTableIndex].slice();
	//I BET YOU HAVE TO SAVE BEFORE YOU CAN RETRIEVE. WHAT IS SAVEDTABLESARRAY AT THIS POINT?????
	console.log("In setup newTable: savedTablesArray["+loadTableIndex+"] = " + savedTablesArray[loadTableIndex])
	//In setup newTable: savedTablesArray[2] = ,,,
	//TypeError: undefined is not an object (evaluating 'savedTablesArray[loadTableIndex].slice')
	//originalNumberRecords = tableTitle.length;//the contacts length! ADDED THIS Jan18 ..not tested. In aid of preventing request for table refresh! This will be returned to original in the resetFromContacts function
	originalNumberRecords = savedTablesArray[loadTableIndex].length;//the contacts length! ADDED THIS Jan18 ..not tested. In aid of preventing request for table refresh! This will be returned to original in the resetFromContacts function
	
	//for maintenance of sort restore order of contacts table
	copyOfTableTitle=tableTitle.slice();//these are for sorting of contacts table. NOTE copyOfTableTitle is same as original ..this is NOT the contacts! So do I need it in sort? Should just need tableTitle.length which will be selectedContact.length
copyOfTableArray = tableArray.slice();
//copyOfTableArray only changes IF makeContactsTable is true so maybe don't need to change variable name?
//above puts the contactTable data into the copyTableArray variable to be used if sorting and restoring order. Of contacts table MAYBE SHOULD USE copy Of for SortTableArray?

//IF LOADING A SPECIFIC NEWTABLE tableIndex variable should be replaced with loadTableIndex as tableIndex increases by one for every new table created but loadTableIndex is static for its own specific table!!!!..this change is made Feb5 after all initial newTables have been previously created
//TypeError: undefined is not an object (evaluating 'newTableSpecificVariables[loadTableIndex][1].slice')
//alertx("In setUpnewTable: loadFromTableOptions..  newTableSpecificVariables[" +loadTableIndex +"][1]  = " +newTableSpecificVariables[loadTableIndex][1]);
console.log("In setUpnewTable: loadFromTableOptions..  newTableSpecificVariables[" +loadTableIndex +"][1]  = " +newTableSpecificVariables[loadTableIndex][1]);
//TypeError: undefined is not an object (evaluating 'newTableSpecificVariables[1][1]')
//alert("In setUpnewTable:  newTableSpecificVariables[1][1]  = " +newTableSpecificVariables[1][1]);
tableID = loadTableIndex;

//REMOVE THIS LINE AFTER RESTORING FIELDS! Mar3 Cause of newTableFieldsArray issue because I had not made newTableSpecificVariables[tableID][1] = newTableFieldsArray.slice(); instead of just = newFieldsArray;

//newTableSpecificVariables[loadTableIndex][1] = ["CONTACT NAME","DATE","TELEPHONE","EMAIL","ADDRESS","POSITION"];
//newTableFieldsArray = ["CONTACT NAME","DATE","TELEPHONE","EMAIL","ADDRESS","POSITION"];
//newTableSpecificVariables[loadTableIndex][2] = 2;

//REMOVE ABOVE AFTER SAVE TO RESTORE MISTAKE

fieldNamesArray = newTableSpecificVariables[loadTableIndex][1].slice();

newTableFieldsArray = newTableSpecificVariables[loadTableIndex][1].slice();// so each tables field names array is kept current! Mar5 2022

//ATTENTION FOR SEARCHEDNEWTABLE!!!!?,?,?,
//	fieldNamesArray = contactsFieldNames.slice();
//ATTENTION FOR SEARCHEDNEWTABLE!!!!?,?,?,

	tableTitle.length = savedTablesArray[loadTableIndex].length;

console.log('tableArray = ' +tableArray+ ' fieldNamesArray = '+ fieldNamesArray + 'tableIndex = '+ tableIndex + ' tableTitle.length = ' + tableTitle.length);
//tableArray = ,,, fieldNamesArray = CONTACT NAME,DATE,TELEPHONE,EMAILtableIndex = 2 tableTitle.length = 4

// ERROR LOG
// tableArray = Doug Dyer,
// Contact Name , Feb 06 2022 00:20, ,username@shaw.ca,(250) 658-5645,addyer@telus.net fieldNamesArray = CONTACT NAME,DATE,TELEPHONE,EMAILtableIndex = 0 tableTitle.length = 4 SHOULD BE 3?this is because savedTablesArray.length = 4
// ERROR LOG
//now set originalNumberRecords to that of new table! And restore after.
originalNumberRecords = tableTitle.length;//the contacts length! ADDED THIS Jan18 ..not tested. In aid of preventing request for table refresh! This will be returned to original in the resetFromContacts function
console.log("originalNumberRecords set to that of new table (contacts table) …" + originalNumberRecords);

//tableArray = ,,, fieldNamesArray = CONTACT NAME,DATE,TELEPHONE,EMAILtableIndex = 3
//datem:Feb2 commented out numbrtOfAdditionalFields now that edit contacts table is allowed
//numberOfDynamicFields=0;
//numberOfNewTableAddedFields = newTableVariablesArray[4];

//LINE ADDED FEB5 not tested!!?,?,?
numberOfNewTableAddedFields = newTableSpecificVariables[loadTableIndex][2];
//LINE ADDED FEB5 not tested!!?,?,?
newTableEdit = newTableSpecificVariables[loadTableIndex][0];//this variable not used anymore?
numberOfDynamicFields = numberOfNewTableAddedFields;
console.log('numberOfDynamicFields = ' +numberOfDynamicFields);
// saveNumberOfFields= numberOfFields;
//numberOfFields=4;
//numberOfFields = contactsFieldNames.length;
numberOfFields = fieldNamesArray.length;

//alertx("loadTableIndex = " + loadTableIndex + ".  numberOfNewTableAddedFields = " + newTableSpecificVariables[loadTableIndex][2] + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  numberOfDynamicFields = " + numberOfDynamicFields + ". newTableSpecificVariables = " + newTableSpecificVariables+ ".  savedTablesArray.length = " + savedTablesArray.length + ". newTableSpecificVariables.length = " + newTableSpecificVariables.length);




saveheadNameTextContent =headName.textContent 
console.log('numberOfFields = ' +numberOfFields);
headName.textContent ="CONTACT";
newTableContactsTitleLength = savedTablesArray[loadTableIndex].length;//a global variable so that sort can use it NOT SURE I USE THIS VARIABLE?
	
}//end if loadFromTableOptions

//removeFieldHeaders();
setUpFieldHeaders();//IMPORTANT KEEP
editCurrentTable = 1;//so dynamic field headers are created ..but this does not add them to STRows!


/*
//set variables so that displayTable sees a start from fresh
while (rows.firstChild) {
   rows.removeChild(rows.firstChild);
}//end while
clearTableRows();//added Jan1 for STRows
// saveNumberOfAdditionalFields=numberOfDynamicFields;
//redoFields();//clear field headings for fresh start

displayedTable = 0;
editCurrentTable=1;
//above code sets variables so displayTable sees a start from fresh
*/
//alertx("at end of setupNewTable. makeHitsTable = " + makeHitsTable);
console.log("at end of setupNewTable. makeHitsTable = " + makeHitsTable);
if(makeHitsTable) {
saveTableBtn.textContent = "Must SAVE Table!";
saveTableBtn2.textContent = "Must SAVE Table!";

} else {
saveTableBtn.textContent = "Save CONTACTS";//DOES NOT WORK! Why? Jan1
//saveTableBtn.textContent = "Save CONTACTS";
			// saveTableBtn2.disabled = true;
saveTableBtn2.textContent = "Save CONTACTS";
}//end if else makeHitsTable

if(makeContactsTable) {
flipMenu.textContent = " ✅ New Table Name: " + newTableNames[tableIndex] + ". " + newTableName;
}//end if makeContactsTable
flipMenu.textContent = " ✅ New Table Name: " + tableNamed;//THIS PUTS PROPER TABLE NAME ON TOP GREY INSTRUCTION BAR FOR LOADING A NEW TABLE!
changeDBtable();
//FIELD HAEDERS RESTORED TO STHEADER BUT NOT YET ADDED TO STRows!
displayTable();
//alert("I returned here from displayContactsTable");

//alertx("At end of setUpNewTable function...tableID = "+ tableID + ".  loadFromTableOptions = " + loadFromTableOptions + ".  makeContactsTable = " + makeContactsTable + ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex]+ ".  savedTablesArray.length = " + savedTablesArray.length + ". newTableSpecificVariables.length = " + newTableSpecificVariables.length + ".  newTableSpecificVariables[tableIndex][1] = " + newTableSpecificVariables[tableIndex][1]);

console.log("At end of setUpNewTable function...tableID = "+ tableID + ".  loadFromTableOptions = " + loadFromTableOptions + ".  makeContactsTable = " + makeContactsTable + ".  loadTableIndex = " + loadTableIndex + ".  newTableSpecificVariables[loadTableIndex][1] = " + newTableSpecificVariables[loadTableIndex][1] + ".  savedTablesArray[loadTableIndex] = " + savedTablesArray[loadTableIndex]+ ".  savedTablesArray.length = " + savedTablesArray.length + ". newTableSpecificVariables.length = " + newTableSpecificVariables.length + ".  newTableSpecificVariables[tableIndex][1] = " + newTableSpecificVariables[tableIndex][1]);

  }//end if makeContactTable || loadFromTableOptions
fromEditFieldLabels = false;//not sure where this line should go test ..to reset fromFieldLabels condition May13 2022
}//end setupNewTable(tableNamed) function

//deleteNewTable function
function deleteNewTable() {
	
		//put name of database in global variable dataBaseName
		//let tableName = "";//made global variable
tableChosenP.removeEventListener;
//tableNameLi[i].removeEventListener;
//this works but must be used in a named function..not anonymous..called by addEventListener
	//tableNameLi[i].removeEventListener;
		//tableNamed = newTableNames[deleteTableIndex];
		//deleteTableIndex index of array to delete
	//alert("savedTablesArray prior to delete: " + savedTablesArray);	
	//code to clear head row so table is not messed up when switching between db	 

	alert("⚠️ You now have the option to delete  " + tableNamed);
		 tableChosenP.textContent = ' Table Selected to DELETE: '+ newTableNames[deleteTableIndex];
		 tableChosenP.textContent = ' Table Selected to DELETE: '+ tableNamed;
		 console.log('tableName = ' + newTableNames[deleteTableIndex]);
	 //confirm choice window
	if (window.confirm("⚠️ Table to DELETE : " + " \n" + tableNamed +  " \n" + "  CANCEL will UNDO")) {
		
			deleteFromTableOptions = true;//flag indicates deletion of new table
//		let removedArray = savedTablesArray.splice(deleteTableIndex,1);
		let	removedNewTableName = newTableNames.splice(deleteTableIndex,1);
//	let removedTableSpecific = newTableSpecificVariables.splice(deleteTableIndex,1);		
			
	//NOTE THERE ARE 10 slots for new tables as initialized when declaring the arrays..when creating new tables old savedTables don't need to be removed from the array?? Same applies to newTableSpecificVariables!
	
//start testing here! Left off Mar10 use Fun with Dick and Jane

removedSavedTablesArray = savedTablesArray.splice(deleteTableIndex,1);
removedNewTableSpecificVariables = newTableSpecificVariables.splice(deleteTableIndex,1);


//savedTablesArray[deleteTableIndex].length = 0;
//newTableSpecificVariables[deleteTableIndex].length = 0;
	
	//alertx("removedSavedTablesArray = "  + removedSavedTablesArray + ".  savedTablesArray now = " + savedTablesArray + "removedNewTableSpecificVariables = " + removedNewTableSpecificVariables + ".  newTableSpecificVariables= " + newTableSpecificVariables + ".  savedTablesArray.length = " + savedTablesArray.length + ". newTableSpecificVariables.length = " + newTableSpecificVariables.length);	
	
	
//now restore array length
//[-1,[],0]
removedNewTableSpecificVariables.length = 0;
newTableSpecificVariables.push(removedNewTableSpecificVariables);
removedSavedTablesArray.length = 0;
savedTablesArray.push(removedSavedTablesArray);

//alertx("After restoring array lengths: removedSavedTablesArray = "  + removedSavedTablesArray + ".  savedTablesArray now = " + savedTablesArray + "removedNewTableSpecificVariables = " + removedNewTableSpecificVariables + ".  newTableSpecificVariables= " + newTableSpecificVariables + ".  savedTablesArray.length = " + savedTablesArray.length + ". newTableSpecificVariables.length = " + newTableSpecificVariables.length);	
//newTableSpecificVariables[10] = newTableSpecificVariables[1].splice();

		
			 dbName = dataBaseName;
			// alert("savedTablesArray after delete: " + savedTablesArray + "… table names after delete: " + newTableNames);
			 newTableList.removeChild(tableNameLi[deleteTableIndex]);
	//NotFoundError: The object can not be found here.
	console.log('Table deleted is ' + tableNamed);
	//deleteFromTableOptions = false;flag made false after saveVariables
	//return false;
	tableIndex = tableIndex-1//TEST IF THIS WORKS?!!!!Date: Jan23
	
	
	//tableID = tableID - 1;// ???remove???
	
	//tableScreen.removeChild(renameNewTableBtn);
	
	
	saveVariables();//does not work variables are not saved
	deleteFromTableOptions = false;//flag indicates deletion of new table
	
	//alertx("newTableVariablesArray after deletion = " + newTableVariablesArray + ". tableIndex after deletion = " + tableIndex + ". newTableNames after deletion = " +newTableNames + ". newTableNames.length after deletion = " + newTableNames.length + ". savedTablesArray after deletion = " + savedTablesArray);
	//alertx("newTableSpecificVariables after deletion = " + newTableSpecificVariables);
	console.log("newTableVariablesArray after deletion = " + newTableVariablesArray + ". tableIndex after deletion = " + tableIndex + ". newTableNames after deletion = " +newTableNames + ". newTableNames.length after deletion = " + newTableNames.length + ". savedTablesArray after deletion = " + savedTablesArray);
	console.log("newTableSpecificVariables after deletion = " + newTableSpecificVariables);
	
//after deletion newTableSpecificVariables.length = 9 instead of 10. Should I add another empty element…newTableSpecificVariables.length = 10? = Feb28	
			} else {
				//return to fileNames screen. Need to remove the previous fileNames?
			tableChosenP.textContent = ' DELETION of '+ newTableNames[deleteTableIndex] + " CANCELLED!";
			
		deleteFromTableOptions = false;//flag indicates deletion of new table	
	//tableScreen.removeChild(renameNewTableBtn);

	
			//tableScreen.setAttribute('class','hidden');
			//fileNamesWindow.setAttribute('class','hidden');	
			//getFileNames();//changed to just hide the window otherwise database list keeps growing
				}//end if window.confirm else
				
			//return;
				//confirm choice window
		 
			}//end function deleteNewTable called by addEventListener
			
function renameNewTable (newTableName) {
renameNewTableFlag = true;

//tableScreen.removeChild(renameNewTableBtn);

//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	newTableNameWin.style.backgroundColor = "black";
	newTableNameWin.style.color = "white";
	showNewTableNameP.style.color = "white";
} else {
	newTableNameWin.style.backgroundColor = "#eee";
	newTableNameWin.style.color = "black";
	showNewTableNameP.style.color = "black";
}//end if else screenDark

newTableNameWin.setAttribute('class', 'showing');
//showNewTableNameP.textContent = "⚠️ After entering new title, follow the flashing button prompts to register the new table title!"
//newTableTitle.textContent = dbName;
newTableTitle.textContent = "RENAME THE TABLE TITLED:  \n" + newTableNames[loadTableIndex];

	getNewTableName(newTableName);	
//returnToNotesBtn.setAttribute('class','borderBlinkGrn');
				
	//renameNewTableFlag = false;	
	// newTableNames[loadTableIndex].textContent = newTableName;
	// alert("This table has been renamed: " + newTableName);
	// console.log("newTableName = " + newTableName + " newTableNames[" + loadTableIndex +"] = " + newTableNames[loadTableIndex] +".  newTableVariablesArray = " + newTableVariablesArray + "newTableVariablesArray[1] = " + newTableVariablesArray[1]);
	// //saveVariables();
	// saveTableBtn.setAttribute('class','borderBlink');
	// saveTableBtn2.setAttribute('class','borderBlink');
	
	// tableScreenOptions();
	tableScreen.setAttribute('class','showing');//necessary in this version to show flashing returnToHomeScreenBtn for rename table sequence

}//end function renameNewTable
			
			

			
//get newTableName function called from create contacts table prompt in emailBtn.onclick
function getNewTableName(newTableName) {
//this function also used to name a newly created table

//alertx("In getNewTableName function: tableIndex = " + tableIndex);
console.log("In getNewTableName function: tableIndex = " + tableIndex);

if(!renameNewTableFlag) {
	newTableTitle.textContent = dbName;
	}//end if !renameNewTableFlag
if(renameNewTableFlag) {
	newTableNameInput.value = newTableNames[loadTableIndex];
	showNewTableNameP.style.color = "black";
	
	

	showNewTableNameP.textContent = "⚠️ After entering new title, follow the flashing button prompts to register the new table title!"
}//end if renameNewTableFlag

if(makeHitsTable) {
	newTableNameInput.value = query;
}//end if makeHitsTable

	//newTableTitle.textContent = dbName;
	//const newTableNameWin = document.querySelector('#newTableNameWin');
	//const newTableNameInput = document.querySelector('#newName');
	
	// newTableNameWin.setAttribute('class','showing');
	newTableNameSubmitBtn.onclick = function() {
		newTableName = newTableNameInput.value;
		
	//alertx("New Table Name = "+ newTableName);
	console.log("New Table Name = "+ newTableName);
	
	showNewTableNameP.textContent = "Last Action: " + newTableName;
returnToNotesBtn.setAttribute('class','borderBlinkGrn');
// displayTableBtn.setAttribute('class','attentionBtn');//because if main db table not initiated this btn will be flashing.table will get initialized in process of rename	
if(renameNewTableFlag) {
newTableNames[loadTableIndex] = newTableName;
	}//end if renameNewTableFlag
if(!renameNewTableFlag)	{
newTableNames[tableIndex] = newTableName;
	}// end if !renameNewTableFlag .. creating a new table!	

//newTableNames[tableIndex] = newTableName;
	newTableNameWin.setAttribute('class','hidden');
newTableNameInput.value = "";
	//SyntaxError: Left side of assignment is not a reference.
		//return newTableName;
	}//end of submitBtn.onclick
	
//newTableNameCancelBtn
newTableNameCancelBtn.onclick = function () {

//tableScreen.removeChild(renameNewTableBtn);//will this produvpce a object not found here error?

	newTableNameInput.value = "";
tableScreen.setAttribute('class','showing');
	newTableNameWin.setAttribute('class', 'hidden');	
	saveTableBtn.setAttribute('class','tdEdit');
	//don't want to save if cancelling
	saveTableBtn.disabled = true;
	saveTableBtn2.disabled = true;
	
	saveTableBtn2.setAttribute('class','tdEdit');
	homeScreenBtn.setAttribute('class','borderBlink');
	homeScreenBtn2.setAttribute('class','borderBlink');
	homeScreenBtn.disabled = false;
	homeScreenBtn2.disabled = false;//may have been disabled to help force SAVE May1
	returnToNotesBtn.setAttribute('class','tdEdit');//added Mar28
	tableScreenBtn.setAttribute('class','tdEdit');//added Mar28
	displayTableBtn.setAttribute('class','tdEdit');//added Mar28
	flipMenu.textContent = " ✅ New Table Name: CANCELLED!";
	showNewTableNameP.textContent = "CANCELLED";//what is this?
if(!renameNewTableFlag) {
	let cancelledSavedTablesArray = savedTablesArray.pop();
	newTableNames.pop();
let cancelledNewTableSpecificVariables = newTableSpecificVariables.pop();
//now have to restore savedTablesArray.length as in a delete
//now restore array length
//[-1,[],0]
cancelledNewTableSpecificVariables.length = 0;
newTableSpecificVariables.push(cancelledNewTableSpecificVariables);
cancelledSavedTablesArray.length = 0;
savedTablesArray.push(cancelledSavedTablesArray);

//alertx("savedTablesArray.length = " + savedTablesArray.length);
//should I subtract one from tableIndex?
//alertx("In cancel newTableNameCancelBtn.onclick function: tableIndex = " + tableIndex + "Will now subtract 1");

console.log("savedTablesArray.length = " + savedTablesArray.length);
//should I subtract one from tableIndex?
console.log("In cancel newTableNameCancelBtn.onclick function: tableIndex = " + tableIndex + "Will now subtract 1");

tableIndex = tableIndex - 1;//table not created..CANCELLED to avert a save of incorrect tableIndex if SAVE an edit tdcell
	}//end !renameNewTableFlag .. naming a newly created table
renameNewTableFlag = false;
loadFromTableOptions = false;
return;	
}//end function newTableNameCancelBtn.onclick

	// alert("in getNewTableName newTableName = "+ newTableName);
	
if(renameNewTableFlag) {
flipMenu.textContent = " ✅ New Table Name: " + newTableNames[loadTableIndex] + ". " + newTableName;
	}//end if renameTableFlag
	
if(!renameNewTableFlag) {	
	flipMenu.textContent = " ✅ New Table Name: " + newTableNames[tableIndex] + ". " + newTableName;
	}//end if !renameTableFlag	
	
	
	//showNewTableNameP.textContent = "";//what is this?
	return newTableName;
	//newTableNameInput.value = "";
	
}//end function getNewTableName

function redoFields () {
//resetTable
			refreshed = 1;//so added field name headings are not generated twice
			editCurrentTable = 0; //Nov 22 so added field name headings are not generated twice
			while (STrows.firstChild) {
    STrows.removeChild(STrows.firstChild);
}//end while
//to maintain header after refresh
STtableHeader.textContent = dbTableName.value;
STtableHeader.setAttribute('class','attentionBtn');
STrows.appendChild(STtableHeader);
STrows.appendChild(STheadRow);
		displayTable();
		refreshed = 0;	
		//return false;
}//end function redoFields

function setUpFieldHeaders () {
	//clearHeadRow();
	//removeFieldHeaders();
	//trimHeadRow();
	//deleteFirstRow();
/*	if(!cleared) {
		clearHeadRow(cleared);
		cleared = false;
	}//end if!cleared
	*/
	//clearHeadRow();
	if(!mainDBedit) {
	removeHeadRow();
	}//end if!mainDBedit
	
clearTableRows();

tableConstructed = 0;
	displayedTable = 0;
	refreshed = 0;
	renewed = 0;
	changeDB = false;
	
	//deleteFirstRow(1);
	//clearHeadRow();//to reset STHeadRow for change to other db
console.log('In setUpFieldHeaders function calledby load new table and displayTable (main db) btn. SetUpNewTable: in changeDB. Removed dynamic fields! ' + STheadRow);
STheadRow.appendChild(STheadName);
STheadRow.appendChild(secondFieldName);
STheadRow.appendChild(STfirstDataNameTd);
STheadRow.appendChild(STsecondDataNameTd);
}//end function setUpFieldHeaders

//************************************
function changeDBtable () {
	tableConstructed = 0;
	displayedTable = 0;
	refreshed = 0;
	renewed = 0;
	changeDB = false;
	//clearHeadRow();//to reset STHeadRow for change to other db
		//trimHeadRow();
		if(!mainDBedit) {
	removeHeadRow();
}//end if!mainDBedit
	//removeHeadRow();//VERY IMPORTANT LINE..MAKES IT WORK!!!Date: Feb12 2022..new function
	//clearHeadRow();//to reset STHeadRow for change to other db
	//removeFieldHeaders();
	
console.log('in changeDB. Removed dynamic fields! ' + STheadRow);
STheadRow.appendChild(STheadName);
STheadRow.appendChild(secondFieldName);
STheadRow.appendChild(STfirstDataNameTd);
STheadRow.appendChild(STsecondDataNameTd);
//NOW ADDING THE FIELD LABELS TO STRows… in aid of correcting absence of field headers after an edit to main db and then loading in a new table date: Feb 16 2022 this function called by setUpNewTable after loading a newTable NOPE DID NOT CORRECT!

//STrows.appendChild(STtableHeader);
//STrows.appendChild(STheadRow);
//field labels of static fields now restored! BUT NOT ADDED TO STRows!!
	//clearHeadRow();
	//STrows.appendChild(STheadRow);
	//removeFieldHeaders();
	//trimHeadRow();
	//displayTable();
}//end function changeDBtable
//************************************

//start of addingMoreContacts function
//called by plusContactsBtn.onclick loadFromTableOptions is true
async function addingMoreContacts (selectedContact) {

//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	manualContactsWindow.style.backgroundColor = "black";
	manualContactsWindow.style.color = "white";
	showNewTableNameP.style.color = "white";
} else {
	manualContactsWindow.style.backgroundColor = "#eee";
	manualContactsWindow.style.color = "black";
	showNewTableNameP.style.color = "black";
}//end if else screenDark

//let plusContactsArray = [];
	alert("in addingMoreContacts. selectedContact = " + selectedContact);
plusContacts = true;
fromAddingMoreContacts = true;//forcing a resetFields when displayTableBtn is tapped
resetFields = true;
showTable.setAttribute('class','hidden');
manualContactsWindow.setAttribute('class', 'showing');	
await getManualContacts();
alert("Returned from getManualContacts - contactsArray = "+ contactsArray);
// savedTablesArray[loadTableIndex] = savedTablesArray[loadTableIndex].concat(contactsArray);
// alert("savedTablesArray["+ loadTableIndex +"] = " +savedTablesArray[loadTableIndex]);
// tableArray = savedTablesArray[loadTableIndex].slice();
// tableTitle.length = savedTablesArray[loadTableIndex].length;
// 	displayTable();
}//end of function addingMoreContacts



//START function getManualContacts
//called by manuallyCreateContacts or addingMoreContacts OR 
//loadFromTableOptions and plusContacts are true
async function getManualContacts () {
const delay = ms => new Promise(res => setTimeout(res, ms));
// clear arrays from any prior entries
selectedContact.length = 0;
manualContacts.length = 0;
enterContactBtn.setAttribute('class','borderBlinkGrn');
let next = true;
	let i= -1;//this might have to be var i; in function enterContactBtn.onclick??
// let manualContacts = [];
//for(let i = 0;i<100;i++)	{//do {
//code to disable clearContactEntryBtn until after new entry submitted
contactsNameInput.addEventListener('touchstart', function() {
clearContactEntryBtn.style.display = "unset";
  console.log('Input tapped!');
});


//repeating cancelAll function here ? Might not be allowed?
//NC Date:Jan9

clearContactEntryBtn.onclick = function() {
contactsNameInput.value = "";
	telephoneInput.value = "";
	contactsEmailInput.value = "";
	contactsAddress.value ="";
	statusContactEntryP.textContent = "";	 
	 
 }//end clearContactEntryBtn.onclick
 
cancelAllBtn.onclick = function () {
//alert("CANCEL BTN TAPPED");
enterContactBtn.setAttribute('class','attentionBtn');
manualContactsEntered = false;
	//selectedContact.length = 0;
	//TypeError: undefined is not an object (evaluating 'selectedContact.length = 0')
	contactsNameInput.value = "";
	telephoneInput.value = "";
	contactsEmailInput.value = "";
	contactsAddress.value ="";
	statusContactEntryP.textContent = "";
//trying to prevent keyboard pop up on cancel..does not work!!
	contactsNameInput.value = "\n";
	//manualContactsForm.blur();
	contactsNameInput.blur();
	document.activeElement.blur();//remove focus from inputs so keyboard does not pop up on cancel
statusContactEntryP.setAttribute('class','normalBtn');
statusContactEntryP.style.backgroundColor = "black";//because after a Cancel so etimes the text would be white on grey background
manualContactsWindow.setAttribute('class', 'hidden');
//showTable.setAttribute('class', 'showing');
 //added Mar27….check manual contacts still cancels ok..added to cancel addingMoreContactsManually	
	}//end cancelAllBtn.onclick
//NC
//REPEATED cancelAllBtn.onclick function here ..might not be allowed?
finishedContactsEntryBtn.disabled = true;
 enterContactBtn.onclick = function(selectedContact) {
 
 //code to disable clearContactEntryBtn until new entry made Date- Mar 24 2023
 clearContactEntryBtn.style.display = "none";
  //code to disable clearContactEntryBtn until new entry made Date- Mar 24 2023
  
 finishedContactsEntryBtn.disabled = false;
i++
	selectedContact[i] = "\n" + contactsNameInput.value + " " + "_"+telephoneInput.value + " " + "_"+contactsEmailInput.value + " " +
		"_"+contactsAddress.value;
	
	statusContactEntryP.textContent = selectedContact[i] +  " has been submitted. Tap DONE after all contacts/records entered. After tapping DONE,  Tap HERE to register edited entries.";
manualContacts = manualContacts.concat(selectedContact[i]);
	// statusContactEntryP.setAttribute('class','borderBlink');

	contactsNameInput.value = "";
	telephoneInput.value = "";
	contactsEmailInput.value = "";
	contactsAddress.value ="";
	 // }//end function enterContactBtn.onclick
	// }//end for i;i++ 
	
	finishedContactsEntryBtn.onclick = function () {
	statusContactEntryP.setAttribute('class','borderBlink');
	enterContactBtn.setAttribute('class','attentionBtn');
		next = false;;
		//alert("Selected Contacts List = " + manualContacts);
		statusContactEntryP.value = manualContacts;
		//return selectedContact;
		}//end function finishedContactsEntryBtn.onclick
	// } 
	// while (next);
	
	statusContactEntryP.onclick= function()	{
	statusContactEntryP.textContent = "";
statusContactEntryP.setAttribute('class','normalBtn');
statusContactEntryP.style.backgroundColor = "black";
manualContactsWindow.setAttribute('class', 'hidden');
	//return selectedContact;	
	// }//end statusContactEntryP.onclick	
for(i=0;i<manualContacts.length;i++) {

	contactsArray[i] = manualContacts[i].split('_');
}	//end for i
	
//contactsArray = manualContacts.slice();	//}//end for i;i++ 
	
homeScreenBtn.textContent = "Clear CONTACTS Table";
			homeScreenBtn2.textContent = "Clear CONTACTS Table";
		//	clearFoundRecordListFunc();
//cutname function is used in emailBtn.onclick
//alert("contactsArray = " + contactsArray);
// function cutName(namestr) {
//   var newArray = namestr.split('_');
//   return newArray;
// }//end function cutname			
//for(j=0;j<manualContacts.length;j++) {
//contactsArray = manualContacts[j].split(' ');
// console.log(Array.isArray(contactsArray[j]));
// //alert(arr);
//}//end for j	

//use this for the copy paste notice
//alert("Use COPY/PASTE to insert desired information into record or table data cell: \n selected Contacts: \n" + contactsArray);
//need to update todayString!!
 today = new Date();
 todayS = today.toString();
 todayString = todayS.slice(3, 21);
 //alert('todayString = ' + todayString);
alert("The ADDED records = " + contactsArray);
for(k=0;k<manualContacts.length;k++) {
contactsArray[k].splice(1, 0,todayString);
	}//end for k

//alert("now contactsArray = " + contactsArray);
//Date: Nov22 2022 - A BUG OCCURRED HERE WHERE ALERT APPEARED BUT PROGRAM STOPPED RUNNIG RETURNING TO TEXTASTIC EDITOR .. BUT COULD NOT REPRODUCE ? Aftre clearing out some databases??

//code to send add more contacts back to addingMoreContacts
if(plusContacts) {
plusContacts = false;
savedTablesArray[loadTableIndex] = savedTablesArray[loadTableIndex].concat(contactsArray);

console.log("savedTablesArray["+ loadTableIndex +"] = " +savedTablesArray[loadTableIndex]);
//alertx("savedTablesArray["+ loadTableIndex +"] = " +savedTablesArray[loadTableIndex]);

tableArray = savedTablesArray[loadTableIndex].slice();
tableTitle.length = tableArray.length;
saveTableBtn.setAttribute('class','borderBlink');
saveTableBtn2.setAttribute('class','borderBlink');
homeScreenBtn.disabled = true;//to help force Save..now reset after flashing SAVE
			 homeScreenBtn2.disabled = true;
moreTablesBtn.disabled = true;
	displayTable();	
	delay(5000);
	return;//removed Nov28 and replaced otherwise you run into make contacts table!
}//end if(plusContacts)
//code to send add more contacts back to addingMoreContacts


//confirm choice window
		 if (window.confirm("Create Contacts Table ? : \n" + "  CANCEL will Return to Table")) {
			 makeContactsTable= true;
	//-xxxxxxxxxxx		 
			//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	newTableNameWin.style.backgroundColor = "black";
	newTableNameWin.style.color = "white";
	showNewTableNameP.style.color = "white";
} else {
	newTableNameWin.style.backgroundColor = "#eee";
	newTableNameWin.style.color = "black";
	showNewTableNameP.style.color = "black";
}//end if else screenDark

newTableNameWin.setAttribute('class', 'showing');
newTableTitle.textContent = dbName;

			getNewTableName();
		
	//-xxxxxxxxxxx	
			saveTableBtn.setAttribute('class','borderBlink');
			 saveTableBtn2.setAttribute('class','borderBlink');
			 
			 homeScreenBtn.disabled = true;//to help force Save
			 homeScreenBtn2.disabled = true;//to help force Save
			 moreTablesBtn.disabled = true;
			 
			 newTableFieldsBtn.disabled = true;//to prevent an inadvertant tap of Field Labels btn at this stage creating crashing
			// saveTableBtn.disabled = true;
			//  saveTableBtn.textContent = "Save CONTACTS";
			// // saveTableBtn2.disabled = true;
			//  saveTableBtn2.textContent = "Save CONTACTS";
			//getNewTableName();
			} else {
				makeContactsTable=false;
				contactsArray.length = 0;
				manualContacts.length = 0;//this statement IS necessary to clear as the API must clear it on rerun? 
//make clear contacts btn flash if cancel from add contacts date: April29
if(fromAddContacts) {
emailBtn.setAttribute('class','borderBlink');
fromAddContacts = false;
}
//added from cancelAllBtn
manualContactsEntered = false;
	//selectedContact.length = 0;
	//TypeError: undefined is not an object (evaluating 'selectedContact.length = 0')
	contactsNameInput.value = "";
	telephoneInput.value = "";
	contactsEmailInput.value = "";
	contactsAddress.value ="";
	statusContactEntryP.textContent = "";
//trying to prevent keyboard pop up on cancel..does not work!!
	contactsNameInput.value = "\n";
	//manualContactsForm.blur();
	contactsNameInput.blur();
	document.activeElement.blur();//remove focus from inputs so keyboard does not pop up on cancel
statusContactEntryP.setAttribute('class','normalBtn');
statusContactEntryP.style.backgroundColor = "black";
manualContactsWindow.setAttribute('class', 'hidden');
showTable.setAttribute('class', 'showing');

//added from cancelAllBtn…not checked
	return; //to prevent run-away into setupNewTable from a cancel
		}//end if window.confirm else
//end prompt
	setupNewTable();
	//return false;//to stop run away? Reloading of DougieBase after making new table?or is the error causing this ? Feb24	
	
}//end statusContactEntryP.onclick	

 }//end function enterContactBtn.onclick
// alert("in do while loop next = " + next);
//} //do while loop
//	while (next);
	//return contactsArray;
}//end function getManualContacts


//called from newTableFieldsBtn.onclick—EDIT CURRENT FIELDS btn
async function editNewTableFieldNames () {
//alertx("at editNewTableFieldNames");
console.log("at editNewTableFieldNames");

//alertx("At editNewTableFieldNames function: contactsFieldNames = " + contactsFieldNames);
console.log("At editNewTableFieldNames function: contactsFieldNames = " + contactsFieldNames);

if(contactsFieldNames.length === 4) {
//fifthFieldLabel.style.display = "none";////name of fifth field manual contacts data entry
fieldFiveNameLabel.style.display = "none";//statement instruction identifier of fifth field name in editNewTableFieldNamesWin-the other fields labels are not referenced because they are always shown
fithFieldNameNTInput.style.display = "none";//identifier of fifth field name input in editNewTableFieldNamesWin
//contactsAddress.style.display = "none";//data entry input of fifth field in manualContacts entry
} else {
//fifthFieldLabel.style.display = "unset";
fithFieldNameNTInput.style.display = "unset";
fieldFiveNameLabel.style.display = "unset";
//contactsAddress.style.display = "unset";		
}//end if(contactsFieldNames.length = 4)

//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	editNewTableFieldNamesWindow.style.backgroundColor = "black";
	editNewTableFieldNamesWindow.style.color = "white";
	showNewTableNameP.style.color = "white";
} else {
	editNewTableFieldNamesWindow.style.backgroundColor = "#eee";
	editNewTableFieldNamesWindow.style.color = "black";
	showNewTableNameP.style.color = "black";
}//end if else screenDark

showTable.setAttribute('class','hidden');
editNewTableFieldNamesWindow.setAttribute('class', 'showing');	

enterNewFieldNameBtn.setAttribute('class','borderBlinkGrn');


clearFieldNameEntryBtn.onclick = function() {
firstFieldNameNTInput.value = "";
	secondFieldNameNTInput.value = "";
	thirdFieldNameNTInput.value = "";
	fourthFieldNameNTInput.value ="";
	fithFieldNameNTInput.value ="";
	statusFieldNamesEntryP.textContent = "";
enterNewFieldNameBtn.setAttribute('class','borderBlinkGrn');	//	May4 
	 
 }//end clearFieldNameEntryBtn.onclick

cancelAllFieldNamesBtn.onclick = function () {
//alert("CANCEL BTN TAPPED");
enterNewFieldNameBtn.setAttribute('class','attentionBtn');
manualContactsEntered = false;
	//selectedContact.length = 0;
	//TypeError: undefined is not an object (evaluating 'selectedContact.length = 0')
	firstFieldNameNTInput.value = "";
	secondFieldNameNTInput.value = "";
	thirdFieldNameNTInput.value = "";
	fourthFieldNameNTInput.value ="";
	fithFieldNameNTInput.value ="";
	statusFieldNamesEntryP.textContent = "";
	contactsFieldNames.length = 0;//so that field names of a new table are reset to default..i.e. if add contacts 	 
actionRenameBtn.setAttribute('class','tdEdit');//in case flashing from a cancelled edit field names

//actionLoadBtn.textContent = "EDIT FIELD NAMES";
//actionRenameBtn.textContent = "USE CURRENT FIELD NAMES";
//actionCancelBtn.textContent = "CANCEL";
//actionDeleteBtn.style.display = "none";
//actionRenameBtn.style.display = "unset";
actionLoadBtn.style.display = "unset";
actionLoadBtn.setAttribute('class','tdEdit');

statusContactEntryP.setAttribute('class','normalBtn');
statusContactEntryP.style.backgroundColor = "black";
manualContactsWindow.setAttribute('class', 'hidden');
editNewTableFieldNamesWindow.setAttribute('class', 'hidden');	
fromAddContacts = false;//flag to tell editNewTableFieldNames to flash and return to ADD CONTACTS added May7
//showTable.setAttribute('class', 'showing');
 //added Mar27….check manual contacts still cancels ok..added to cancel addingMoreContactsManually	
	}//end cancelAllFieldNamesBtn

finishedFieldNamesEntryBtn.disabled = true;
enterNewFieldNameBtn.onclick = function() {
 finishedFieldNamesEntryBtn.disabled = false;
 enterNewFieldNameBtn.setAttribute('class','attentionBtn');
 /*
i++
	selectedContact[i] = "\n" + contactsNameInput.value + " " + "_"+telephoneInput.value + " " + "_"+contactsEmailInput.value + " " +
		"_"+contactsAddress.value;
	
	statusContactEntryP.textContent = selectedContact[i] +  " has been submitted. Tap DONE after all contacts entered.After tapping DONE,  Tap HERE to register edited entries.";
*/

console.log("firstFieldNameNTInput = " + firstFieldNameNTInput.value);

//allow for only 4 fields
if(contactsFieldNames.length === 4 ) {
contactsFieldNames = "\n" +  firstFieldNameNTInput.value + " "+ "_"+secondFieldNameNTInput.value + " "+ "_" + thirdFieldNameNTInput.value + " "+ "_"+fourthFieldNameNTInput.value;
} else {

contactsFieldNames = "\n" +  firstFieldNameNTInput.value + " "+ "_"+secondFieldNameNTInput.value + " "+ "_" + thirdFieldNameNTInput.value + " "+ "_"+fourthFieldNameNTInput.value + " "+ "_" + fithFieldNameNTInput.value;

}//end if else contactsFieldNames===4


contactsFieldNames = cutName(contactsFieldNames);
console.log(Array.isArray(contactsFieldNames));



// contactsFieldNames[0]=firstFieldNameNTInput.value;
// contactsFieldNames[1]=secondFieldNameNTInput.value;
// contactsFieldNames[2]=thirdFieldNameNTInput.value;
// contactsFieldNames[3]=fourthFieldNameNTInput=.value;
// contactsFieldNames[0]=document. getElementById("firstFieldNameNT").value;
// contactsFieldNames[1]=document. getElementById("secondFieldNameNT").value;
// contactsFieldNames[2]=document. getElementById("thirdFieldNameNT").value;
// contactsFieldNames[3]=document. getElementById("fourthFieldNameNT").value;
// if(manualContactsEntered) {
// contactsFieldNames[4]=document. getElementById("fithFieldNameNT").value;
// //not tested Mar26 to prevent extra field being added if preceding new table had an extra field
// contactsFieldNames.length = 5;	
// }//end if manualContactsEntered 

statusFieldNamesEntryP.textContent =  contactsFieldNames +  " The above Field Names have been entered! Tap DONE after all field names entered. ";

//return contactsFieldNames;
}//end enterNewFieldNameBtn.onclick

finishedFieldNamesEntryBtn.onclick = function () {
alert("Field names submitted are: " +  contactsFieldNames);
editNewTableFieldNamesWindow.setAttribute('class', 'hidden');	
if(fromAddContacts) {
	fromAddContacts = false;
 addContactsBtn.setAttribute('class','borderBlink');
	showTable.setAttribute('class','hidden');
} else {
showTable.setAttribute('class','showing');
emailBtn.setAttribute('class','borderBlink');
}//end if else fromAddContacts

return contactsFieldNames;
	
}//end function finishedFieldNamesEntryBtn.onclick

}//end function editNewTableFieldNames


//check if more than 10 tables..notification to delete a table (allowedNumberOfTables)
function checkTableLimit () {
//alertx("In checkTableLimit function: tableIndex = " + tableIndex);
console.log("In checkTableLimit function: tableIndex = " + tableIndex);
//tableIndex won't increase to 10 until a contacts table is made so savedTablesArray - 1
//alertx("tableIndex= " + newTableVariablesArray[0] + "savedTablesArray.length = " + savedTablesArray.length);

tableIndex= newTableVariablesArray[0];

//alertx("tableIndex = " + tableIndex + "savedTablesArray.length = " + savedTablesArray.length);
console.log("tableIndex = " + tableIndex + "savedTablesArray.length = " + savedTablesArray.length);


//changed this line to fix tableLimit issue
//if (tableIndex !== -1 && tableIndex === savedTablesArray.length -1)
if (tableIndex !== -1 && tableIndex === 9) {
alert("⚠️You have exceeded the limit for number of allowed tables. Delete some first!");
tableScreenOptions();
tableLimit = true;	
//tableScreen.setAttribute('class','showing');
return tableLimit;
} else {
console.log("Still room for more tables!");
tableLimit = false;
return tableLimit;
}//end if else (tableIndex > savedTablesArray.length)
}//end function check table limit

//function for selecting storage file for database restore
//selectStorageFile
function selectStorageFile(selectedFileData) {
//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	restoreFromFilesWin.style.backgroundColor = "black";
	restoreFromFilesWin.style.color = "white";
	// restoreInfo2P.style.color = "black";
	// restoreInfoP.style.color = "white";
	// restoreInfo1P.style.color="white";
	// nowDo.style.color = "black";
} else {
	restoreFromFilesWin.style.backgroundColor = "#eee";
	restoreFromFilesWin.style.color = "black";
}//end if else screenDark
// const restoreFromFilesWin = document.querySelector('#restoreFromFilesWin');
// //references the file input selector if you need it?
// const fileSelector = document.querySelector('#fileSelector');
// const fileData = document.querySelector('#fileData');//the p on restoreFromFilesWin that shows the backup data
//fileSelector
restoreFromFilesWin.setAttribute('class','showing');
//const cancelFromFileSelectionBtn = document.createElement('button');//made global

restoreFromFilesWin.appendChild(cancelFromFileSelectionBtn);
cancelFromFileSelectionBtn.textContent = "CANCEL";
cancelFromFileSelectionBtn.onclick = function () {
restoreFromFilesWin.removeChild(cancelFromFileSelectionBtn);
// restoreFromFileBtn.style.display = "unset";
// nowDo.setAttribute('class','attentionBtn');
// 	loadSampleDb = false;
// 	loadTutorialDb = false;
// 	formatFailed = false;
// 	//clear textarea for next use
// 	restoreTextArea.textContent = "Paste Backup data here"
// 	restoreTextArea.value = "";//May8
// 	console.log('cancelFromFileSelectionBtn has been tapped.');
// 	//clearDatabase(dataBaseName);
// 	getJsonBtn.textContent = "SUBMIT Backup data";
// 	getJsonBtn.setAttribute('class','normalBtn');
// //getJsonBtn.setAttribute('class','attentionBtn');
// restoreFromClipboardBtn.setAttribute('class','normalBtn');	
// finishedRestoreBtn.setAttribute('class','normalBtn');
// restoreFromLocalFile = false;	//added Sept 26 not tested	
// restoreFromFilesWin.removeChild(cancelFromFileSelectionBtn);
// restoreFromFilesWin.removeChild(continueFromFileSelectionBtn);
// 	restoreDBWindow.removeChild(finishedRestoreBtn);
// 	restoreDBWindow.removeChild(cancelRestoreBtn);
	
restoreFromFilesWin.setAttribute('class','hidden');
	//restoreDBWindow.setAttribute('class','hidden');
	
		//getFileNames();//remove to return to notes? RETURN TO NOTES WINDOW
		
//Additional code to complete CANCEL

restoreFromFileBtn.style.display = "unset";
nowDo.setAttribute('class','attentionBtn');
	loadSampleDb = false;
	loadTutorialDb = false;
	formatFailed = false;
	//clear textarea for next use
	restoreTextArea.textContent = "Paste Backup data here"
	restoreTextArea.value = "";//May8
	console.log('cancelRestoreBtn has been tapped.');
	//clearDatabase(dataBaseName);
	getJsonBtn.textContent = "SUBMIT Backup data";
	getJsonBtn.setAttribute('class','normalBtn');
//getJsonBtn.setAttribute('class','attentionBtn');
restoreFromClipboardBtn.setAttribute('class','normalBtn');	
finishedRestoreBtn.setAttribute('class','normalBtn');
restoreFromLocalFile = false;	//added Sept 26 not tested	

	restoreDBWindow.removeChild(finishedRestoreBtn);
	restoreDBWindow.removeChild(cancelRestoreBtn);
	restoreDBWindow.setAttribute('class','hidden');
	
	//Additional code to complete CANCEL
	
		//getFileNames();//remove to return to notes? RETURN TO NOTES WINDOW
	}//end cancelFromFileSelectionBtn.onclick
// const cancelFromFileSelectionBtn = document.createElement('button');
//   cancelFromFileSelectionBtn.textContent = "CANCEL";
//   restoreFromFilesWin.appendChild(cancelFromFileSelectionBtn);
	// let file = fileSelector.files[0];

 //  let reader = new FileReader();

 //  reader.readAsText(file);

 //  reader.onload = function() {
 //    alert(reader.result);
 //    console.log(reader.result)
 //    selectedFileData = reader.result;
 // restoreFromFilesWin.setAttribute('class','hidden');
 //    return selectedFileData;
    
 //  };

 //  reader.onerror = function() {
 //    console.log(reader.error);
 //  };

}//end function selectStorageFile()

//summing function for TOTAL field if dblclicked

function Xsumming () {
//alertx("summing : tableTitle.length = " + tableTitle.length + " totalFieldNameIndex = " + totalFieldNameIndex);

	for (i =0;i <tableTitle.length;i++) {
	
	if ( isNaN( Number(tableArray[i][totalFieldNameIndex]) )) {
    
//  if ( isNaN( Number(tableArray[i][totalFieldNameIndex])) || Number(tableArray[i][totalFieldNameIndex]) === 0) {
	
    //Number(tableArray[i][totalFieldNameIndex] if = Edit will be made a number = 0 which is NaN so condition not met. Therefore added || Number(tableArray[i][totalFieldNameIndex]) === 0 to cover EDIT entries
	
	
		//i++;
		alert("is this the alert?Addition column in record " + (i+1) + " contains a non number!");
		i++;
		//break;
		}//end if ( isNaN( Number(tableArray[i][totalFieldNameIndex])) || Number(tableArray[i][totalFieldNameIndex]) === 0) {
		
	fieldSUM = fieldSUM + Number(tableArray[i][totalFieldNameIndex]);
	
	//alertx("i = " +i + " fieldSUM = " + fieldSUM);
	//totalFieldNameIndex replaced with k
//if (fieldSUM === NaN) {
//alert("The array contains a non number so unable to complete sum!");	
//}
//alert("fieldSUM = " + fieldSUM);
//alert("typeof fieldSUM = " + typeof(fieldSUM));
//fieldNamesArray[totalFieldNameIndex].textContent = " TOTAL = " + fieldSUM;
// fieldNamesArray[totalFieldNameIndex].textContent = " TOTAL = ";
	}//end for loop
	totalFieldNameListener = false;
	resetFields = true;//flag used in displayTable to keep fields being messed up
	return fieldSUM;
	//alert("fieldNamesArray[totalFieldNameIndex].textContent = " + fieldNamesArray[totalFieldNameIndex].textContent);
}//end function Xsumming

function summing (k) {
//alertxy("At function summing(): totalFieldNameIndex =  " + totalFieldNameIndex + " tableArray[0][totalFieldNameIndex] = " + tableArray[0][totalFieldNameIndex]);
//CHECK IF ROWS SUMMED date Nov13
//At point when summing() is called, the iteration through records is done so i is noi known. Therefotpre just use 0 first records data cell..which MAKES A NEW RULE! To initiate total of sumAcross records you must initialize the first record's last td cell (last column) so as to put sumRowTxt in this data cell, allowing rowSummed variable to be made true.!
//CHECK THAT FIRST RECORD'S LAST TD CELL (LAST COLUMN ENTRY) CONTAINS sumRowTxt. sumRowTxt will have been put there by a previous initialization of summing across first record's columns horizontally when this data cell is first initialized by using the keyword sumAcross as the entry for the input element in this data cell. This code line only checks the first record for sumRowTxt because tableArray[i][fieldNameI dex] must be a specific array element or you get TypeError: undefined is not an object (evaluating 'tableArray[i][totalFieldNameIndex].includes')!
//alertxy("totalFieldNameIndex = " + totalFieldNameIndex + " tableArray[0][totalFieldNameIndex] = " + tableArray[0][totalFieldNameIndex]);
//Date: Dec6 2022 TO AVOID ERROR:TypeError: undefined is not an object (evaluating 'tableArray[i][totalFieldNameIndex].includes')

if(tableArray[0][totalFieldNameIndex] === undefined) {
tableArray[0][totalFieldNameIndex] = "EDIT";
//tableArray[0][fieldNamesArray.length-1] === "EDIT";
}

	if(tableArray[0][totalFieldNameIndex].includes(sumRowTxt)	) {
				rowSummed = true;
				}//end if(tableArray[i][c].includes(sumRowTxt)	) {
//TypeError: undefined is not an object (evaluating 'tableArray[i][totalFieldNameIndex].includes')


//ALSO CHECKING LAST FIELD IN FIRST RECORD INDICATES SUMACROSS IS ACTIVE SO THAT A NUBER WITH A CHARACTER (PRESUMABLY ADDED TO EXCLUDE IT FROM A SUM ACROSS ADDITION) WILL BE INCLUDED IN A TOTAL OF THAT COLUMN. THIS WILL PRESERVE THE FUNCTIONALITY OF TOTAL IN ANY COLUMN EVEN IF A NUMBER  WAS MARKED TO BE EXCLUDED FROM SUM ACROSS.

//Date: Dec6 TO AVOID ERROR! TypeError: undefined is not an object (evaluating 'tableArray[0][fieldNamesArray.length-1].includes')

if(tableArray[0][fieldNamesArray.length-1] === undefined) {
tableArray[0][fieldNamesArray.length-1] = "EDIT";
//tableArray[0][fieldNamesArray.length-1] === "EDIT";
}

	if(tableArray[0][totalFieldNameIndex].includes(sumRowTxt) || tableArray[0][fieldNamesArray.length-1].includes(sumRowTxt)	) {
				rowSummed = true;
				}//end if(tableArray[i][c].includes(sumRowTxt)	) {

//let parseString = tableArray[i][totalFieldNameIndex];
//let parseString = tableArray[i][k];
//alertx("summing : tableTitle.length = " + tableTitle.length + " totalFieldNameIndex = " + totalFieldNameIndex);
//alertxy("rowSummed = " + rowSummed + " totalFieldNameIndex " + totalFieldNameIndex);

//if(rowSummed && totalFieldNameIndex===fieldNamesArray.length-1 && tableArray[0][totalFieldNameIndex].includes(sumRowTxt)	) {//might I need this extra conditional in some circumstaces??
//if rowSummed and we are tapping the last column header — we need to strip off the non-numerical charcters i.e. sumRowTxt before adding. Use isolateNumber() because this code uses parseString which includes the txt of sumRowTxt.
if(rowSummed && totalFieldNameIndex===fieldNamesArray.length-1) {

//COVER SCENARIO WHERE DBL-CLICK ON LAST COLUMN TOTAL BUT FIRST RECORD LAST COLUMN DATA CELL HAS NOT BEEN INITIALIZED WITH SUMACROSS .. YOU GET ERRORS!
if(!tableArray[0][fieldNamesArray.length-1].includes(sumRowTxt)	) {
alert("The last data cell in the first record has not been initialized for summing across rows. Returning to the table to allow initializing of summing across rows.")	
displayTable();
}

//alertxy("horizontal summing is initialized and we are tapping the field header of the last column so will strip off non-numerical characters prior to addition! TOTAL of vertical column.");

isolateNumber();//THIS FUNCTION WILL DEAL WITH rowSumTxt..includeAllNumbers() wil not
}//end if(rowSummed && totalFieldNameIndex===fieldNamesArray.length-1) {)

//if rowSummed variable is true BUT NOT dbl-click action was not in last column of table OR rowSummed = false do normal column summing without stripping off non-numerical characters of sumRowTxt  use justAddNumbers() function. However justAddNumbers() function forces use of juststraight numbers in orderto be included in the TOTAL. justAddNumbers() function will NOT INCLUDE numbers marked with a character(s) to exclude that number from being included in the sumAcross sum (if for example you do not want to include a column of the table in a sumAcross calculation…all the numbers in that column could be marked for exclusion in a sumAcross calculation by adding a character(s) i.e. 100% 100! 100mice  .. I think also 100 mice? etc.) But these marked numbers would be included in the vertical TOTALLING of the table column IF THE includeAllNumbers() function is used. At the moment I am going to just use the includeAllNumbers function. The justAddNumbers() function is probably redundant and not necessary.

 if(rowSummed && totalFieldNameIndex!==fieldNamesArray.length-1 || !rowSummed) {
 //alertxy("Either rowSummed is false - We are NOT tapping the LAST column field header, OR  the summing ACROSS columns function has not been initiated via keyword sumAcross…OR ..rowSummed is true (summing across is enabled) but we are not dbl-clicking the last column so we do not have to strip off non-numerical characters prior to addition. Currently using the includeAllNumbers function");
 
// justAddNumbers();
includeAllNumbers();//numbers that have a character added..100% or 100! For summing column vertically and the row summed stuff does not need stripping 
	
	}//end if(!rowSummed)
	
//DO I ALSO NEED A CONDITION WHERE rowSummed is false … horizontal sumAcross addition has not been initialized but we are dbl-clicking the last column .. so don't try stripping off non-numerical characters which might give an error???

// if(!rowSummed && totalFieldNameIndex===fieldNamesArray.length-1) {
// alert("Dbl-clicked last column field header BUT rowSummed = false..horizontal addition not enabled …Don't need to strip off non-numerical characters");
// justAddNumbers();
// }//end if(!rowSummed && totalFieldNameIndex===fieldNamesArray.length-1) {
	
	totalFieldNameListener = false;
	resetFields = true;//flag used in displayTable to keep fields being messed up

//if(budgetSheet) {
//ADDED JAN2 2023 to correct error where any TOTAL in any column added this info to the STtableHeader
if(totalFieldNameIndex===fieldNamesArray.length-1) {

if(fieldNamesArray[fieldNamesArray.length-1].includes("Cost") || fieldNamesArray[fieldNamesArray.length-1].includes("COST")|| fieldNamesArray[fieldNamesArray.length-1].includes("$")) {

	STtableHeader.textContent = dbTableName.value
	 + " \n " + fieldNamesArray[fieldNamesArray.length-1] +  " : $" + fieldSUM;
		}//end if(fieldNamesArray[fieldNamesArray.length-1].includes("Cost") ||
		else if(fieldNamesArray[fieldNamesArray.length-1].includes("Time") || fieldNamesArray[fieldNamesArray.length-1].includes("Hours") || fieldNamesArray[fieldNamesArray.length-1].includes("hours") || fieldNamesArray[fieldNamesArray.length-1].includes("hrs") || fieldNamesArray[fieldNamesArray.length-1].includes("time")) {
		STtableHeader.textContent = dbTableName.value
	 + " \n " + fieldNamesArray[fieldNamesArray.length-1] + " " + fieldSUM +  " hrs" ;
			
				}//end else if(fieldNamesArray[fieldNamesArray.length-1].includes("Time") ||
	else {
	STtableHeader.textContent = dbTableName.value
	 + " \n " + fieldNamesArray[fieldNamesArray.length-1] + " " + fieldSUM;
		
	}//end if else

	 }//end if(totalFieldNameIndex===fieldNamesArray.length-1) {
	
	//STtableHeader.textContent = dbTableName.value
	// + " \n  $" + fieldSUM;
	 
//} else {
// STtableHeader.textContent = dbTableName.value;
//}//end if else  budgetSheet
	return fieldSUM;
	//fieldSUM = fieldSUM.toFixed(2);
	//return fieldSUM = fieldSUM.toFixed(2);
//	TypeError: fieldSUM.toFixed is not a function. (In 'fieldSUM.toFixed(2)', 'fieldSUM.toFixed' is undefined)
	//alert("fieldNamesArray[totalFieldNameIndex].textContent = " + fieldNamesArray[totalFieldNameIndex].textContent);


}//end function summing


function averaging () {
//this function totals all entries containing a number .i.e 100%
//DATE:OCT30 This function WORKS!
//alertx("averaging : tableTitle.length = " + tableTitle.length + " totalFieldNameIndex = " + totalFieldNameIndex);

//MIGHT USE THIS CODE!!
function containsOnlyNumbers(str) {
  return /^\d+$/.test(str);
}

console.log(containsOnlyNumbers('hello123')); // false
console.log(containsOnlyNumbers('3453')); // true
console.log(containsOnlyNumbers('3 apples')); // false
console.log(containsOnlyNumbers('')); // false

function onlyLetters(str) {
  return /^[a-zA-Z]+$/.test(str);
}

console.log(onlyLetters('hello')); // 👉️ true
console.log(onlyLetters('hello123')); // 👉️ false
console.log(onlyLetters('one,two')); // 👉️ false
console.log(onlyLetters('')); // 👉️ false

//MIGHT USE THIS CODE!!


let nonNumberCount = 0;
fieldSUM = 0;
//let keepTDentry = [];
	for (i =0;i <tableTitle.length;i++) {
	
	if (tableArray[i][totalFieldNameIndex] === "" || tableArray[i][totalFieldNameIndex] === undefined || tableArray[i][totalFieldNameIndex] === "EDIT" || tableArray[i][totalFieldNameIndex] === " " || tableArray[i][totalFieldNameIndex] === 0) {
	if(calculationAlerts) {
	alert("Averaging column in record " + (i+1) + " contains a non number— null, EDIT or undefined! Averaging will ignore this record for the calculation. To turn off calculation alerts go to Preferences!");
	}//end if (calculationAlerts)
	
	//alertxy("i = " + i);
	
	nonNumberCount++;//increase the count number
		continue;
	}//end else if (onlyLetters(tableArray[i][totalFieldNameIndex])) {
	
	//scenario for straight number
else if ( !isNaN( Number(tableArray[i][totalFieldNameIndex]) )) {
	fieldSUM = fieldSUM + Number(tableArray[i][totalFieldNameIndex]);
	
	//alertxy("i = " + i);
	
	 continue;
	}//end if(!thenum.isNaN) {
	
		//scenario for EDIT where value in array = ""
	
	//scenario only letters i.e. Great
	else if (onlyLetters(tableArray[i][totalFieldNameIndex])) {
		nonNumberCount++;//increase the count number
		if(calculationAlerts) {
		alert("Averaging column in record " + (i+1) + " contains a non number! Averaging will ignore this record for the calculation.");
		}//end if(calculationAlerts
		
	//alertxy("i = " + i);
	
		continue;
		
	}//end if
	
	// //scenario for EDIT where value in array = f""
	// else if (tableArray[i][totalFieldNameIndex] === "" || tableArray[i][totalFieldNameIndex] === undefined || tableArray[i][totalFieldNameIndex] === "EDIT" || tableArray[i][totalFieldNameIndex] === " ") {
	// alert("Averaging column in record " + (i+1) + " contains a non number— null, EDIT or undefined! Averaging will ignore this record for the calculation.");
	// alert("i = " + i);
	// nonNumberCount++;//increase the count number
	// 	continue;
	// }//end else if (onlyLetters(tableArray[i][totalFieldNameIndex])) {
	else {
	
		//scenario words with spaces i.e. Great day ignore save
	 if (tableArray[i][totalFieldNameIndex].includes(" ")) {
		nonNumberCount++;//increase the count number
	if(calculationAlerts) {	
		alert("AVERAGING column in record " + (i+1) + " contains a non number or more than one number or more than one word! AVERAGING will ignore this record for the calculation. To turn off calculation alerts go to Preferences!");
		}//end if(calculationAlerts) {
		
	//alertxy("i = " + i);
	
		continue;
		
	}//end else if (tableArray[i][totalFieldNameIndex].includes(" ")) 
//above code handles scenario of words with spaces i.e. Great day ignore save

	
		//alertxy("now i = " + i);
		
//	let thenum = tableArray[i][totalFieldNameIndex].match(/\d+/)[0] // "3"
	//FROM BING April 22 2023
	//let thenum = tableArray[i][totalFieldNameIndex].match(/\d+\\.\d+/)[0];
	//let thenum = tableArray[i][totalFieldNameIndex].match(/\\d+(\\.\\d+)?/g)[0];
	let thenum = tableArray[i][totalFieldNameIndex].match(/\d+(\.\d+)?/g)[0];
	if(calculationAlerts) {
	alert("This entry in record " + (i+1) + " might not be a straight number! The number = " + thenum);
	}//end if(calculationAlerts) {
	
	//nonNumberCount++;//increase the count number
	//tableArray[i][totalFieldNameIndex]
	if(!isNaN(Number(thenum)) ){
	fieldSUM = fieldSUM + Number(thenum);
	
	//alertxy("i = " + i);
	
	 continue;
	}//end if(!isNaN(Number(thenum)) ){
	
	//alertxy("i = " + i);
	
	continue;
	} //end if else if else

}//end for loop

if (nonNumberCount>0) {
fieldSUM = fieldSUM/(tableTitle.length-nonNumberCount);	//make average only of records summed..a 0 will not increase the sum
if(calculationAlerts) {
alert("Number of data cells excluded from the calculation (non-numerical data) = " + nonNumberCount);//removed -  " fieldSUM = " + fieldSUM
}//end if(calculationAlerts) {

	nonNumberCount = 0;//reset count for next averaging
	
	//alertx("fieldSUM(average) should be : " + fieldSUM);
	//keepTDentry.length = 0;
	} else {
	fieldSUM = fieldSUM/tableTitle.length;
	}//end if else (nonNumberCount>0) {
	//`const result = num.toFixed(2)`
	return fieldSUM = fieldSUM.toFixed(2);//fieldSUM now represents average..not total

}//end function averaging

function includeAllNumbers () {
//this function totals all entries containing a number .i.e 100% called for toal vertically in columns not related to sum across ..i.e. rowSum enabled but not last column or sum across not enabled
//DATE:OCT30 This function WORKS!
//alertx("averaging : tableTitle.length = " + tableTitle.length + " totalFieldNameIndex = " + totalFieldNameIndex);

//MIGHT USE THIS CODE!!
function containsOnlyNumbers(str) {
  return /^\d+$/.test(str);
}

console.log(containsOnlyNumbers('hello123')); // false
console.log(containsOnlyNumbers('3453')); // true
console.log(containsOnlyNumbers('3 apples')); // false
console.log(containsOnlyNumbers('')); // false

function onlyLetters(str) {
  return /^[a-zA-Z]+$/.test(str);
}

console.log(onlyLetters('hello')); // 👉️ true
console.log(onlyLetters('hello123')); // 👉️ false
console.log(onlyLetters('one,two')); // 👉️ false
console.log(onlyLetters('')); // 👉️ false

//MIGHT USE THIS CODE!!


let nonNumberCount = 0;
fieldSUM = 0;
//let keepTDentry = [];
	for (i =0;i <tableTitle.length;i++) {
	
//scenario for === EDIT undefined
	if (tableArray[i][totalFieldNameIndex] === "" || tableArray[i][totalFieldNameIndex] === undefined || tableArray[i][totalFieldNameIndex] === "EDIT" || tableArray[i][totalFieldNameIndex] === " " || tableArray[i][totalFieldNameIndex] === 0) {
	if(calculationAlerts) {
	alert("Totaling column in record " + (i+1) + " contains a non number— null, EDIT or undefined! The sum will ignore this record for the calculation. To turn off calculation alerts go to Preferences!");
	}//end if(calculationAlerts) {
	
	//alertxy("i = " + i);
	
	nonNumberCount++;//increase the count number
	//alert("At === EDIT nonNumberCount = " + nonNumberCount + " i = " + i);
		continue;
	}//end if (tableArray[i][totalFieldNameIndex] === "" ||
	//END scenario for === EDIT undefined
	
	//scenario for straight number
else if ( !isNaN( Number(tableArray[i][totalFieldNameIndex]) )) {
	fieldSUM = fieldSUM + Number(tableArray[i][totalFieldNameIndex]);
	
	//alertxy("i = " + i);
	
	 continue;
	}//end if(!thenum.isNaN) {
	//END scenario for straight number
	
	
	//scenario only letters i.e. Great
	else if (onlyLetters(tableArray[i][totalFieldNameIndex])) {
	
		nonNumberCount++;//increase the count number
		//alert("At only letters: nonNumberCount = " + nonNumberCount + " i = " + i);
	if(calculationAlerts) {	
		alert("Totalling column in record " + (i+1) + " contains a non number! Summing will ignore this record for the calculation. To turn off calculation alerts go to Preferences!");
		}//end if(calculationAlerts) {
		
	//alertxy("i = " + i);
	
		continue;
		
	}//end if (onlyLetters(tableArray[i][totalFieldNameIndex]))
	//END scenario only letters i.e. Great
	
	//scenario words with spaces i.e. Great day ignore save
//SyntaxError: Unexpected keyword 'else'
	else if (tableArray[i][totalFieldNameIndex].includes(" ")) {
		nonNumberCount++;//increase the count number
		//alert("At words and spaces: nonNumberCount = " + nonNumberCount + " i = " + i);
	if(calculationAlerts) {	
		alert("Totalling column in record " + (i+1) + " contains a non number or more than one number or more than one word! Summing will ignore this record for the calculation. To turn off calculation alerts go to Preferences!");
		}//end if(calculationAlerts) {
		
	//alertxy("i = " + i);
	
		continue;
		
	}//end else if (tableArray[i][totalFieldNameIndex].includes(" ")) 
//END of above code handles scenario of words with spaces i.e. Great day ignore save

	
	//scenario where all the rest of entries must be a mixture number + character
	else {
	
		//alertxy("now i = " + i);
// if (tableArray[i][totalFieldNameIndex] == null) {
// alert("calc error Null not an object")
// tableArray[i][totalFieldNameIndex] = 0;
//}//end if tableArray[i][totalFieldNameIndex] === null DID NOT WORK! Trying to avoid error below. This error is avioded IF LAST COLUMN FIRST RECORD IS INITIALIZED WITH SUMACROSS!!!?,
//if (tableArray[i][totalFieldNameIndex] !== null) {

//if(isNaN( Number(tableArray[0][numberOfFields-1])) ) {
//FEB26 2023 - NOT SURE I NEED THIS CODE BELOW NOW THATSCENARIO WORDS WITH SPACES HAS BEEN ADDED ,????..leave in for now.
// if(!(tableArray[0][numberOfFields-1].includes(sumRowTxt)) ) {
// alert("⚠️ error! The first record's last column data cell has not been initialized for summing across rows. Current TOTAL result will be INVALID!  Return to the table and edit this cell with the keyword 'SumAcross'");
// return;
// //displayTable();	
// }



//TypeError: null is not an object (evaluating 'tableArray[i][totalFieldNameIndex].match(/\d+/)[0]')
	//let thenum = tableArray[i][totalFieldNameIndex].match(/\d+/)[0] // "3"
	
	//FROM BING April 22 2023
	//let thenum = tableArray[i][totalFieldNameIndex].match(/\d+\\.\d+/)[0];
	
	//FROM BING AGAIN-
	//If you want to keep decimal places while matching a regex in JavaScript, you can use the following regex pattern: /\\d+(\\.\\d+)?/g
	//let thenum = tableArray[i][totalFieldNameIndex].match(/\\d+(\\.\\d+)?/g)[0];
//TypeError: null is not an object (evaluating 'tableArray[i][totalFieldNameIndex].match(/\d+/)[0]')
//}//end tableArray[i][totalFieldNameIndex] !== null
let thenum = tableArray[i][totalFieldNameIndex].match(/\d+(\.\d+)?/g)[0];


	if(calculationAlerts) {
	alert("This entry in record " + (i+1) + "  might not be a straight number! The number = " + thenum);
	}//end if(calculationAlerts) {
	
	//nonNumberCount++;//increase the count number
	//tableArray[i][totalFieldNameIndex]
	if(!isNaN(Number(thenum)) ){
	fieldSUM = fieldSUM + Number(thenum);
	
	//alertxy("i = " + i);
	
	 continue;
	}//end if(!isNaN(Number(thenum)) ){
	
	//alertxy("i = " + i);
	
	continue;//this is an extra continue???
	} //end else if else

}//end for loop

//alertxy("nonNumberCount = " + nonNumberCount + " fieldSUM = " + fieldSUM);

if (nonNumberCount>0) {
//fieldSUM = fieldSUM/(tableTitle.length-nonNumberCount);	//make average only of records summed..a 0 will not increase the sum
if(calculationAlerts) {
alert(nonNumberCount + " record entries in this column were NOT INCLUDED in the SUM!");
	nonNumberCount = 0;//reset count for next averaging
	}//end if(calculationAlerts) {
	
	//alertx("fieldSUM(average) should be : " + fieldSUM);
	//keepTDentry.length = 0;
	//} else {
	//fieldSUM = fieldSUM/tableTitle.length;
	}//end if else (nonNumberCount>0) {
	//`const result = num.toFixed(2)`
	return fieldSUM = fieldSUM.toFixed(2);//fieldSUM now represents average..not total

}//end function includeAllNumbers


//alertx("tableArray[" +i + "][totalFieldNameIndex] = " + tableArray[i][totalFieldNameIndex] + " Number(tableArray[i][totalFieldNameIndex]) = " + Number(tableArray[i][totalFieldNameIndex]));

	//if ( isNaN( Number(tableArray[i][totalFieldNameIndex]) )) {
	//looks like the Number()function converts a non 0 null or "" to 0?
	//Number(tableArray[i][totalFieldNameIndex]) if TEXT is NaN, but if null,"" Number() converts it to 0 which is a number so isNaN is false!
	
//if ( isNaN( Number(tableArray[i][totalFieldNameIndex])) || Number(tableArray[i][totalFieldNameIndex]) === 0) {
	
 //IF EXTRACTED NUMBER
	//thenum = "foo3bar5".match(/\d+/)[0] // "3"
	
	//if thenum evaluates to null i.e. = great then do the code for a non number and add 1 to the non number count and then skip this iteration (continue) without adding to fieldSUM
	//SyntaxError: No identifiers allowed directly after numeric literal
// 	let analizeTxt = tableArray[i][totalFieldNameIndex] + Number(1);
// 	alert("analizeTxt.match(/\d+/)[0] = " + analizeTxt.match(/\d+/)[0]);
// 	//IF NON NUMBER LIKE GREAT
// 	//if(analizeTxt.match(/\d+/)[0]===Number(1)) {
// 	// if(isNaN(tableArray[i][totalFieldNameIndex]) && analizeTxt.match(/\d+/)[0] === Number(1)) {
// 	if(isNaN(tableArray[i][totalFieldNameIndex])) {
// 		nonNumberCount++;//increase the count number
// 		alert("Averaging column in record " + (i+1) + " contains a non number! Averaging will ignore this record for the calculation.");
// 	alert("i = " + i);
// 		continue;
		
// 	}//end if(tableArray[i][totalFieldNameIndex].match(/\d+/)[0]===1)
// 	//the scenario of 100%
// 	else if(analizeTxt.match(/\d+/)[0]) {
// 	alert("now i = " + i);
// 	thenum = tableArray[i][totalFieldNameIndex].match(/\d+/)[0] // "3"
// 	alert("This entry might not be a straight number! thenum = " + thenum);
// 	nonNumberCount++;//increase the count number
// 	//tableArray[i][totalFieldNameIndex]
// 	if(!isNaN(Number(thenum)) ){
// 	fieldSUM = fieldSUM + Number(thenum);
// 	 continue;
// 	}//end if(!thenum.isNaN) { else
// 	} else {//end if(isNaN(tableArray[i][totalFieldNameIndex])) {
//     //Number(tableArray[i][totalFieldNameIndex] if = Edit will be made a number = 0 which is NaN so condition not met. Therefore added || Number(tableArray[i][totalFieldNameIndex]) === 0 to cover EDIT entries
//    // keepTDentry[nonNumberCount] = tableArray[i][totalFieldNameIndex];//store the original entry to replace after calculation
//    // nonNumberCount++;//increase the count number
    
//   //  alertx("increment nonNumberCount = " + nonNumberCount);
//     //tableArray[i][totalFieldNameIndex] = 0;
//    // fieldSUM = fieldSUM + Number(tableArray[i][totalFieldNameIndex]);//probably don't need this line?
// 	//	alert("Averaging column in record " + (i+1) + " contains a non number! Averaging will ignore this record for the calculation.");
// 		//tableArray[i][totalFieldNameIndex] = keepTDentry[nonNumberCount];
// 	//if(i<tableTitle.length)	{
// 	//	i++;
// 	//	}//end if(i<tableTitle.length)	{
// 		//break;
// 		//continue;//breaking out of the for loop skipping this iteration
// 		//}//end if ( isNaN( Number(tableArray[i][totalFieldNameIndex]) )) {
		
// 	//alertx("before addition fieldSUM = "+ fieldSUM);
	
// 	//if(isNaN(Number(tableArray[i][totalFieldNameIndex])) ) {
// 	//	continue;
	
// //	} //MAYBE SHOULD NOT REMOVE ASSUME THIS IS END OF IF(IS NAN)
		
// 	fieldSUM = fieldSUM + Number(tableArray[i][totalFieldNameIndex]);
// 	}//end else if block
// //alertx("i = " + i + " fieldSUM =  " + fieldSUM);	








// 	}//end for loop
	
	
// 	fieldSUM = fieldSUM/(tableTitle.length-nonNumberCount);	//make average only of records summed..a 0 will not increase the sum
// 	nonNumberCount = 0;//reset count for next averaging
	
// 	//alertx("fieldSUM(average) should be : " + fieldSUM);
// 	//keepTDentry.length = 0;
// 	} else {
// 	fieldSUM = fieldSUM/tableTitle.length;
// 	}//end if else (nonNumberCount>0) {
	
// 	return fieldSUM;//fieldSUM now represents average..not total

// }//end function averaging

//function below is CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED
//function to reset active field headers
function resetActiveFieldHeaders () {
telephoneActive = false;//so now code in displayTableBtn won't run good!
eMailActive = false;
// 	//to reset attribute stHeadRow if telephone activated in dynamic fields return to displayTable with resetFields true BUT NOW CAN'T REINSTATE DBLCLICK ADDEVENTLISTENER!
//resetFields = true;
// 	//tableConstructed = false;
//displayTable();//NEED THIS TO RESET FIELD ATTRIBUTE TO NON BLINK so maybe just put setAttribute to stHeadRow in the resetField code? AND REMOVE displayTable because this will repeat records!
// }//end if(telephoneActive || eMailActive) {


//TO RESET BLINK IF EMAIL TELEPHONE ACTIVE
	clearHeadRow();
console.log('Removed dynamic fields! ' + STheadRow);

//TRY THIS,! Date: Feb17 2022
//addFieldHeaders();
//TRY THIS,! Date: Feb17 2022


//
STheadRow.appendChild(STheadName);
STheadRow.appendChild(secondFieldName);
STheadRow.appendChild(STfirstDataNameTd);
STheadRow.appendChild(STsecondDataNameTd);
//field labels of static fields now restored!
for (let k = 4; k < numberOfFields; k++) {
	const STnextFieldHeading = document.createElement('td');
	STnextFieldHeading.textContent = fieldNamesArray[k];	
	//to reset field header if blinking
	STnextFieldHeading.setAttribute('class','stHeadRow');//resets cancels blinking if previously applied by an addEventListener
	
	STheadRow.appendChild(STnextFieldHeading);
	
//code to set field heading light blue if = today's date
if (budgetSheet && fieldNamesArray[k].includes(currentDate)) {
STnextFieldHeading.style.backgroundColor = "lightblue";

}//end if (budgetSheet && fieldNamesArray[k].includes())

//code to set field heading light blue if = today's date

	
	//reapply eventListeners
if(fieldNamesArray[k].includes("TOTAL")|| fieldNamesArray[k].includes("AVERAGE")) {
	//alertx("adding event listener"); 
		STnextFieldHeading.addEventListener('dblclick', function (e) {
		e.target.style.color = "darkblue";
		e.target.style.backgroundColor = "lightblue";//added Nov27 2022
		
		//check if table initialized
		if(blockEdit) {
		alert("Before tapping this Field Title, Tap Return to Home Screen first to initialize the table layout you just edited or created!");
		homeScreenBtn.setAttribute('class','borderBlink');
	homeScreenBtn2.setAttribute('class','borderBlink');
		//blockEdit = false;
		resetFields = true;
		return false;
	}
	
			totalActive = true;
			totalFieldNameIndex = k;
			
if(fieldNamesArray[k].includes("TOTAL" || "AVERAGE") && calculationAlerts) {
	if (window.confirm("Do you want to turn off Calculation Alerts ? : \n" + "  CANCEL will Return to Table")) {
		calculationAlerts = false;
		alert("Calculation Alerts are turned OFF. Change in Preferences!");
	} else {
		alert("Calculation Alerts remain ON. This setting can be changed in Preferences. ")
	}//end if (window.confirm
}//end if(fieldNamesArray[k].includes("TOTAL" || AVERAGE && calculationAlerts)) {
	
			//summing();
			if(fieldNamesArray[k].includes("TOTAL")) {
			summing();
		} else if (fieldNamesArray[k].includes("AVERAGE")) {
			averaging();
		}//end if else if if(fieldNamesArray[k].includes("TOTAL")) {
			//STnextFieldHeading.textContent = " TOTAL = " + fieldSUM;
			
	if (fieldNamesArray[k].includes("COST")|| fieldNamesArray[k].includes("$")) {
		STnextFieldHeading.textContent = fieldNamesArray[k]+ " $" + fieldSUM;
		// } else if (fieldNamesArray[k].includes("AGE")) {
		// 	STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " yrs";
		} else {	
			
			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM;
			}//end if (fieldNamesArray[k].includes("COST")) {
			
if (fieldNamesArray[k].includes("UNITS")) {
		//alertx("fieldNamesArray[k] = " + fieldNamesArray[k] + " so why am I adding yrs? STnextFieldHeading.textContent = " + STnextFieldHeading.textContent );
		
			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " units";
			}//end if (fieldNamesArray[k].includes("AGE")) {
			
if (fieldNamesArray[k] === "AGE" + " (TOTAL)" || fieldNamesArray[k] === "AGE" + " (AVERAGE)") {
		//alertx("fieldNamesArray[k] = " + fieldNamesArray[k] + " so why am I adding yrs? STnextFieldHeading.textContent = " + STnextFieldHeading.textContent );
		
			STnextFieldHeading.textContent = fieldNamesArray[k]+ " " + fieldSUM + " yrs";
			}//end if (fieldNamesArray[k].includes("AGE")) {
				
			fieldSUM = 0;
			totalFieldNameIndex = 0;	STnextFieldHeading.removeEventListener;
			
			//fieldNamesArray[totalFieldNameIndex].textContent = " TOTAL = " + fieldSUM;
			});//end addEventListener
		
		}//end if (STnextFieldHeading.textContent === "TOTAL")
		
//ADDING CODE FOR TELEPHONE AND EMAIL IN //ADDING CODE FOR TELEPHONE AND EMAIL IN DYNAMIC HEADERS	vvv must includ in resetFields section!
if(fieldNamesArray[k].includes("TELEPHONE") || fieldNamesArray[k].includes("EMAIL")){

//alertx("at fieldNamesArray contains TELEPHONE..adding eventListener");
//STfirstDataNameTd.addEventListener('dblclick', STfirstDataNameTd.fn=function fn() {
	STnextFieldHeading.addEventListener('dblclick', STnextFieldHeading.fn=function fn() {
		//check table is initialized
		if(blockEdit) {
		alert("Before tapping this Field Title, Tap Return to Home Screen first to initialize the table layout you just edited or created!");
		homeScreenBtn.setAttribute('class','borderBlink');
	homeScreenBtn2.setAttribute('class','borderBlink');
		//blockEdit = false;
		resetFields = true;
		return false;
	}
			
STnextFieldHeading.setAttribute('class','borderBlink');
	if(fieldNamesArray[k].includes("TELEPHONE")) {
			telephoneActive = true;
			telephoneAlertFlag2 = false;
			eMailAlertFlag2 = true;
		} else if (fieldNamesArray[k].includes("EMAIL")) {
			eMailActive = true;
			eMailAlertFlag2 = false;
			telephoneAlertFlag2 = true;
		}//end if else if	
		
//STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
//k is 4 or > so this applies only to dynamic fields
if(!eMailAlertFlag2) {
	alert("eMail address now active! Double click on email address to SEND EMAIL!");
eMailAlertFlag2 = true;
	}//end if(!eMailAlertFlag) 
	
if(!telephoneAlertFlag2) {
	alert("Telephone number is now active! Double click on telephone number to PHONE!");
telephoneAlertFlag2 = true;
	}//end if(!eMailAlertFlag) 

STnextFieldHeading.removeEventListener('dblclick', STnextFieldHeading.fn, false);

//STnextFieldHeading.setAttribute('class','stHeadRow');
//STnextFieldHeading.setAttribute('class','borderBlink')

});//end STnextFieldHeading.addEventListener

}//end if(fieldNamesArray[k].includes("TELEPHONE") ||



//Date:Oct25 this works so now need more debugging!!
//ADDING CODE FOR TELEPHONE AND EMAIL IN DYNAMIC HEADERS	^^^
	}//end for loop	
}//end function resetActiveFieldHeaders ()

//FUNCTION TO RESET FIXED FIELD HEADERS ACTIVITY FOR TELEPHONE EMAIL
function resetFixedFieldActivity () {
//alertx("In resetFixedFieldActivity function!");

	totalInfoP.style.display = "none";
		fieldSUM = 0;//clear to 0 in case TOTAL function has been used
emailBtn.setAttribute('class','tdEdit');//if cancel CONTACTS or ignore flashing CONTACTS AND GO TO HOME SCRN CONTACTS BTN WILL STAY FLASHING!

if(STsecondDataNameTdListener) {
STsecondDataNameTd.removeEventListener('dblclick',STsecondDataNameTd.fn, false);
	//STsecondDataNameTd.removeEventListener;
	STsecondDataNameTdListener = false;
	eMailActive = false;
	STsecondDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STsecondDataNameTdListener)

if(STfirstDataNameTdListener) {
STfirstDataNameTd.removeEventListener('dblclick',STfirstDataNameTd.fn, false);
	//STfirstDataNameTd.removeEventListener;
	STfirstDataNameTdListener = false;
	telephoneActive = false;
	
//alertx("moreTablesBtn tapped: STfirstDataNameTdListener = " + STfirstDataNameTdListener);
	STfirstDataNameTd.setAttribute('class','stHeadRow');
	
}//end if(STfirstDataNameTdListener)

//CODE TO RESET BLINK IF TELEPHONE OR EMAIL HAD BEEN ACTIVATED
if(telephoneActive || eMailActive) {
resetActiveFieldHeaders();
}//end if(telephoneActive || eMailActive) {

}//end function resetFixedFieldActivity () {

// function sumAcross (i,c) {
// 	for (let c=4;c<numberOfFields;c++) {
// 	rowSum = tableArray[i][c] + rowSum;
// 	return rowSum;
// 	}//end for (let i=4;i<fieldNames.length;i++) {
	
// }//end function sumAcross

function sumAcross (i,c) {

//this function totals only entries that are straight numbers .i.e 100 BUT NOT 100%. This allows adding non number literals to a number so the value in the cell is NOT INCLUDED in the sum.
rowSUM = 0;//reset for each run of this function
	for (let c=4;c<numberOfFields;c++) {
	
	if ( isNaN( Number(tableArray[i][c])) || Number(tableArray[i][c]) === 0) {
	c++;
	//	}//end if(i<tableTitle.length)	{
		//break;
		//continue;//breaking out of the for loop skipping this iteration
		}//end if ( isNaN( Number(tableArray[i][c]) )) {
		
	//alertx("before addition fieldSUM = "+ fieldSUM);
	
	if(isNaN(Number(tableArray[i][c])) ) {
		continue;
	}//end if
		
	rowSUM = rowSUM + Number(tableArray[i][c]);
	
//alertx("i = " + i + " fieldSUM =  " + fieldSUM);	

	}//end for loop
	
	//alertxy("In sumAcross function: rowSUm =  " + rowSUM);
	
	return rowSUM.toFixed(2);//

}//end function sumAcross




//function isolateNumber used by summing()
function XisolateNumber () {
//there is a scenario where some entries in column are string  number and other entries are already a number!



for (i =0;i <tableTitle.length;i++) {
	let parseString = tableArray[i][totalFieldNameIndex];
//TypeError: undefined is not an object (evaluating 'parseString.length')
	
	let deleteCount = tableArray[i][0].length + 2 + sumRowTxt.length;
	let start = deleteCount;
	let removeNumber = parseString.length - deleteCount;
	
let strippedOff = parseString.slice(start)

	
	if ( isNaN( Number(strippedOff) )) {
    

		alert("Addition column in record " + (i+1) + " contains a non number!");
		i++;
		//break;
		}//end if ( isNaN( Number(tableArray[i][totalFieldNameIndex])) || Number(tableArray[i][totalFieldNameIndex]) === 0) {
		
	fieldSUM = fieldSUM + Number(strippedOff);
}//end for loop			
}//end function isolateNumber

//function isolateNumber used by summing() called if last column and it contains rowSumTxt in otherwords if rowSum is enabled and you want to total the last column
function isolateNumber () {
//there is a scenario where some entries in column are string  number and other entries are already a number!
for (i =0;i <tableTitle.length;i++) {
if(!isNaN(tableArray[i][totalFieldNameIndex])) {
//this scenario won't happen here because function is only called if in last coloumn and it contains rowSumTxt
	strippedOff = tableArray[i][totalFieldNameIndex];
	
	//alertxy("this entry is a number so we use it! strippedOff = " + strippedOff);

	} else if (tableArray[i][totalFieldNameIndex] === undefined) {
		strippedOff = 0;
	
	} else {

//for (i =0;i <tableTitle.length;i++) {
	let parseString = tableArray[i][totalFieldNameIndex];
//TypeError: undefined is not an object (evaluating 'parseString.length')
//?need to adjust tableArray[i][0].length for a load fronTableOptions db??	
//In simple contacts a space is added at end of tableArray[i][totalFieldNameIndex] that I don't think .length takes into account so maybe need to strip tableArray[i][totalFieldNameIndex] of spaces?
//let trimElement = tableArray[i][0].trim();

let deleteCount = tableArray[i][0].length + 2 + sumRowTxt.length;
//a main table and a new table have record field 0 formatted with spacing differently by 1 space - not sure why? Probably something to do with adding the #> to the first record field ? because to display the data in the td cell I added a space after #> ???.Should be able to use trim() to fix but so far not successful so line below is temporary fudged fix!
//alertxy("loadFromTableOptions = " + loadFromTableOptions);

if(makeContactsTable || loadFromTableOptions) { 
	 deleteCount = tableArray[i][0].length + 1 + sumRowTxt.length;
	}//end if(makeContactsTable || loadFromTableOptions) { 
	//let deleteCount = trimElement.length + 2 + sumRowTxt.length;
	
	let start = deleteCount;
	
	//alertxy("tableArray[i][0] = " + tableArray[i][0] + " tableArray[i][0].length = " + tableArray[i][0].length + " deleteCount = " + deleteCount);
	
	//alertxy("sumRowTxt = " + sumRowTxt + " sumRowTxt.length = " + sumRowTxt.length);
	
	//alertxy("totalFieldNameIndex = " + totalFieldNameIndex + " tableArray[i][" +totalFieldNameIndex +"] = " + tableArray[i][totalFieldNameIndex] + " parseString = " + parseString + " start = " + start);
	
	let removeNumber = parseString.length - deleteCount;
	
 strippedOff = parseString.slice(start);
 
//alertxy("After isolating number strippedOff =  " + strippedOff);
	
	if ( isNaN( Number(strippedOff) )) {
    
		if(calculationAlerts) {
		alert("Addition column in record " + (i+1) + " contains a non number!");
		}//end if(calculationAlerts) 
		
		
		i++;
		//break;
		continue;//should this be here????
		}//end if ( isNaN( Number(tableArray[i][totalFieldNameIndex])) || Number(tableArray[i][totalFieldNameIndex]) === 0) {
	}//end if else
		
	fieldSUM = fieldSUM + Number(strippedOff);
	
	//alertxy("fieldSUM = "  + fieldSUM);
	//fieldSUM = fieldSUM.toFixed(2);
	//TypeError: fieldSUM.toFixed is not a function. (In 'fieldSUM.toFixed(2)', 'fieldSUM.toFixed' is undefined)
	//ReferenceError: Can't find variable: strippedOff
}//end for loop			
}//end function isolateNumber

//this function not ever called ?
function justAddNumbers () {
	for (i =0;i <tableTitle.length;i++) {
	
	if ( isNaN( Number(tableArray[i][totalFieldNameIndex]) )) {
    
//  if ( isNaN( Number(tableArray[i][totalFieldNameIndex])) || Number(tableArray[i][totalFieldNameIndex]) === 0) {
	
    //Number(tableArray[i][totalFieldNameIndex] if = Edit will be made a number = 0 which is NaN so condition not met. Therefore added || Number(tableArray[i][totalFieldNameIndex]) === 0 to cover EDIT entries
	
	
		//i++;
		if(calculationAlerts) {
		alert("Addition column in record " + (i+1) + " contains a non number!");
		}//end if(calculationAlerts) 
		
		i++;
		//break;
		}//end if ( isNaN( Number(tableArray[i][totalFieldNameIndex])) || Number(tableArray[i][totalFieldNameIndex]) === 0) {
	if(isNaN(Number(tableArray[i][totalFieldNameIndex])) ) {
		continue;
	}
		
	fieldSUM = fieldSUM + Number(tableArray[i][totalFieldNameIndex]);
	
	//alertxy("i = " + i + " fieldSUM = " + fieldSUM);
	
}//end for loop	
	//alertx("i = " +i + " fieldSUM = " + fieldSUM);
	//totalFieldNameIndex replaced with k
//if (fieldSUM === NaN) {
//alert("The array contains a non number so unable to complete sum!");	
//}
//alert("fieldSUM = " + fieldSUM);
//alert("typeof fieldSUM = " + typeof(fieldSUM));
//fieldNamesArray[totalFieldNameIndex].textContent = " TOTAL = " + fieldSUM;
// fieldNamesArray[totalFieldNameIndex].textContent = " TOTAL = ";
//alertxy("rowSummed false or rowSummed true but not last field : fieldSUM = " + fieldSUM);

}//end function just add numbers

//RENAME DATABASE FILENAME FUNCTION
function renameDataBaseFileName(dataBaseName) {
//to avoid error:TypeError: undefined is not an object (evaluating 'db.transaction')..objectStore not there?
//alertrnf("tableTitle.length = " +tableTitle.length + " tableTitle[0] = " +tableTitle[0]);
if(tableTitle.length === 0) {
		alert('This database has not been previously loaded. View or create a database first to make the RENAME function available.');
		getFileNames();
		return;
	} //end if dbName===undefined
	
// alert("dbName = " + dbName + " DTBtnTappedOnce = " + DTBtnTappedOnce + " data.variable1 = " + data.variable1);

// 	if(dbName === undefined && !newDBflag && !newDBGuidance) {
// 		alert('No database has been previously loaded. View or create a database first to make the RENAME function available.');
		
// 		return;
// 	} //end if dbName===undefined
//should I clear old newDBFileName?TypeError: Attempted to assign to readonly property.
//newDBFileName.value = "";//because it caused TypeError: undefined is not an object (evaluating 'db.transaction')..objectStore not there?
	reNameDBWin.setAttribute('class','showing');
	//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	reNameDBWin.style.backgroundColor = "black";
	reNameDBWin.style.color = "white";
	dbFileName.style.color = "white";
} else {
	reNameDBWin.style.backgroundColor = "#eee";
	reNameDBWin.style.color = "black";
	dbFileName.style.color = "black";
}//end if else screenDark 
	 //alertrnf("dbFileName = " + dbFileName + " dataBaseName = " + dataBaseName);
	 //dbTableName.value set to 'Notes' at top of code
	//dbName.textContent = newDBName.value;
	dbFileName.textContent = dataBaseName;
	//alert("budgetSheet = " + budgetSheet);
if(budgetSheet) {
	// dbFileName.textContent = dataBaseName.slice(-2);//trim off .bs
//myString = myString.Substring(0, myString.Length-3);
//alertcm("in if budgetSheet");

dbFileName.textContent = dataBaseName.substring(0, dataBaseName.length-3);//trim off .bs
//alertcm
//alert("In renameDataBaseFileName(). dataBaseName = " + dataBaseName + " dataBaseName.substring(0, dataBaseName.length-3) = " + dataBaseName.substring(0, dataBaseName.length-3));

}//end if(budgetSheet) {
//alertrnf("dbFileName.textContent = " + dbFileName.textContent);
	// dbTitle.textContent = 'Notes';
	 let newDBFileNamePara = document.createElement('p');
	// newTitlePara.textContent = "⚠️ After entering new title, follow the flashing button prompts to register the new table title!"
	 //get new title
	 
	//CODE TO CLEAR DATABASE NAME ENTRY
let clearDataBaseNameBtn = document.createElement('button');	
clearDataBaseNameBtn.textContent = "Clear DataBase Name";
	//clear edit ewFieldInput
clearDataBaseNameBtn.onclick = function () {
	newDBFileName.value = '';
	}//end clearDataBaseNameBtn.onclick
//}//end function editNewField
 
 
 
  
	 
	 newDBFileName.addEventListener('input', function () {dbFileName.textContent = newDBFileName.value;
		 //dbTableName variable declared as global on line 16? removed this line 16 because it caused error: 'attempting to assign to a readonly property? then code worked. so where is this variable declared?'maybe getElementByID takes care of it??
		 
		// !!!REMOVE .textContent fron dbTableName
	 dbFileName.value = newDBFileName.value;
	 newDBFileNamePara.textContent = 'The database is now renamed : ' + dbFileName.textContent; 
	 renamedFileName = dbFileName.textContent; 
	// alertrnf("renamedFileName = " + renamedFileName);
	 saveRenamedFileNameBtn.setAttribute('class','borderBlink');
	 
	 });//end newTitle.addEventListener CHANGED dbTableName to dbTitle.textContent
	// renamedFileName = dbFileName.textContent; 
	// alert("renamedFileName = " + renamedFileName);
	// alert(dbTitle.textContent);
	 //dbTitleName = newTitle.value;
	 
	 reNameDBWin.appendChild(newDBFileNamePara);
	 reNameDBWin.appendChild(clearDataBaseNameBtn);
	saveRenamedFileNameBtn.textContent = "Save the new filename";
	//saveRenamedFileNameBtn.setAttribute('class','borderBlink');
	 reNameDBWin.appendChild(saveRenamedFileNameBtn);
	reNamedDBFileName = true;
	
	saveRenamedFileNameBtn.onclick = function () {
	saveRenamedFileNameBtn.setAttribute('class','tdEdit');
	reNameDBWin.removeChild(newDBFileNamePara);
	reNameDBWin.removeChild(clearDataBaseNameBtn);
	
reNameDBWin.removeChild(saveRenamedFileNameBtn);
reNameDBWin.setAttribute('class','hidden');

//IF YOU RENAME ANY DATABASE SHOULD NOT THE TABLE NAME REFLECT THE FILENAME? Whether its a budget sheet or not?? So remove condition if(budgetSheet || changeMonth).

if(budgetSheet || changeMonth) {dbTitle.textContent = renamedFileName}//end if(budgetSheet)

dbTableName.value = renamedFileName//dbTableName is stored in variable1 and represents the variable in view settings that reflects the table name ? Is this saved at any time?? Do I need a save() call here??
//alertblk("At rename fileName: dbTableName.value = " + dbTableName.value);

saveVariables();//ADDED DEC9 so new budget sheet from TEMPLATE SAVES THE CHANGES I.E NEW MONTH HEADINGS


		backupDataBase(dataBaseName);//go to backup with original name!! And new filename is now in variable 	 renamedFileName = dbFileName.textContent;REMEMBER TOADD .bs back on for save
		
	}//end saveRenamedFileNameBtn.onclick function
	//backupDataBase(dataBaseName);
	mustTapRestore = true;//flag forces getFileNames window to scroll to flashing RESTOREbtn date:Mar17 2023
	}//end function renameDataBaseFileName(dataBaseName) {


//function to manipulate backup string after rename fiename
function manipulateString(string) {
	//alertrnf("from backup in manipulateString(): string received = " + string);
	//alertrnf("renamedFileName = " + renamedFileName);
if(budgetSheet && !(renamedFileName.includes("bs"))) {
//restore.bs to filename //if backing up a budgetsheet after edit renamedFileName might already end in .bs
renamedFileName = renamedFileName + ".bs";
//protocolFileName = renamedFileName + ".bs";
//protocolFileName = renamedFileName + ".bs";
}//end if(budgetSheet) {
	position = string.indexOf("_os");
	//alertrnf("position = " + position);
	part = string.slice(position);
	//alertrnf("part = " + part);
	//newPartString = "{\"" + protocolFileName;
	newPartString = "{\"" + renamedFileName;
	//alertrnf("newPartString = " + newPartString);
	//string.splice position = 17
	//string = "This is a test of rename db filename!"
	string = newPartString+part;
	//alertrnf("Now string = " + string);
	// dbTitle.textContent = renamedFileName;
	 return string;
}//end function manipulateString

// code for changing month of budget sheet
function changeMonthBudgetSheet() {
//changeMonthBtn1.setAttribute('class', 'tdEdit');
//changeMonthBtn2.setAttribute('class', 'tdEdit');
changeMonthBtn1.style.display = "none";
changeMonthBtn2.style.display = "none";
//alertcm("numberOfDynamicFields  = " + numberOfDynamicFields + " fieldNamesArray = " + fieldNamesArray + " fieldNamesArray.length = " + fieldNamesArray.length);
changeMonth = true;
const monthSelectWin = document.querySelector('#monthSelectWin');
let date ="";
// let month = "";
// let year = "";	

let bs31FieldNamesArray = [];
let bs30FieldNamesArray = [];
let febFieldsNamesArray = [];
let leapYearFieldNamesArray = [];

let fixedFieldsBS = [];

//CODE TO GET MONTH AND YEAR
//let addToMonthsArray = fieldNamesArray.splice(startIndex, deleteCount, replacingItem1, ...)
let addToMonthsArray = fieldNamesArray.splice(fieldNamesArray.length - 2,2);
//alert("addToMonthsArray = " + addToMonthsArray);
//Check if screenDark mode
checkScreenMode();
if(screenDark) {
	monthSelectWin.style.backgroundColor = "black";
	monthSelectWin.style.color = "white";
	dbFileName.style.color = "white";
} else {
	monthSelectWin.style.backgroundColor = "#eee";
	monthSelectWin.style.color = "black";
	dbFileName.style.color = "black";
}//end if else screenDark 
	 //alertrnf("dbFileName = " + dbFileName + " dataBaseName = " + dataBaseName);
showTable.setAttribute('class', 'hidden'); 
monthSelectWin.setAttribute('class', 'showing');

//from renameDB maybremove all this?
//dbFileName.textContent = dataBaseName;
//alertrnf("dbFileName.textContent = " + dbFileName.textContent);
	// dbTitle.textContent = 'Notes';
	// let newDBFileNamePara = document.createElement('p');
	// newTitlePara.textContent = "⚠️ After entering new title, follow the flashing button prompts to register the new table title!"
	 //get new title
	//newDBFileNamePara.textContent = dbFileName.textContent; monthSelectWin.appendChild(newDBFileNamePara);
	// newDBFileName.addEventListener('input', function () {dbFileName.textContent = newDBFileName.value;
		 //dbTableName variable declared as global on line 16? removed this line 16 because it caused error: 'attempting to assign to a readonly property? then code worked. so where is this variable declared?'maybe getElementByID takes care of it??
		 
		// !!!REMOVE .textContent fron dbTableName
	// dbFileName.value = newDBFileName.value;
	// newDBFileNamePara.textContent = 'The database is now renamed : ' + dbFileName.textContent; 
	// renamedFileName = dbFileName.textContent; 
	// alertrnf("renamedFileName = " + renamedFileName);
	 //saveRenamedFileNameBtn.setAttribute('class','borderBlink');
	 
	// });//end newTitle.addEventListener CHANGED dbTableName to dbTitle.textContent
//FROM RENAME FILE NAME MAY REMOVE ALL THIS???
	 
 var monthSelect = document.createElement("input");
 monthSelect.setAttribute('class','borderBlink');
		//for just the date use type 'date' instead of date time-local
	monthSelect.style.color = "black";	
	monthSelect.value = "Tap HERE first!"	
const monthSelectInfoP = document.createElement("p");
const yearAndMonthInfoP = document.createElement("p");
	monthSelect.setAttribute('type','date');//this creates the datePicker API
	monthSelectWin.appendChild(monthSelect);
	
	
//monthSelect.value = monthSelect.value.slice(0,16);
// alert(" dataBaseName = " + dataBaseName + "Month selected is " + monthSelect.value);
const gotMonthBtn = document.createElement("button");
gotMonthBtn.textContent = "Tap to SELECT THIS MONTH AND YEAR";
const doneDateBtn = document.createElement('button');
doneDateBtn.textContent = " Tap HERE to GENERATE NEW BUDGET SHEET ";
monthSelect.onchange = function () { 
	monthSelect.setAttribute('class','tdEdit');	gotMonthBtn.setAttribute('class','borderBlink');
	}//end monthSelect.onchange 
	
monthSelectWin.appendChild(gotMonthBtn);
gotMonthBtn.onclick = function () {
//code below added Sept26 to scroll to bottom of element with id = 'id of element'
//why doesn't this scroll??? Should it be a section???		
	const scrollDownToBottom = (id) => {
	 const elementToScroll = document.getElementById(id);
   elementToScroll.scrollTop = elementToScroll.scrollHeight;
}	
scrollDownToBottom('monthSelectWin');//this is a function expression..element id is passed as a parameter to the scrollToBottom function expression.
date = monthSelect.value.toString();
monthSelectWin.appendChild(monthSelectInfoP);
monthSelectInfoP.textContent = "The month and year selected are: " + date;
monthSelectWin.appendChild(yearAndMonthInfoP);
gotMonthBtn.setAttribute('class','tdEdit');
let dateWord = date.toString();

function splitDate(dateWord){
  var result = date.split('-');
  return result;
  
}

var splittedDate = splitDate(dateWord);

console.log ("splittedDate = " +splittedDate);
var year = splittedDate[0];
var month = splittedDate[1];
var day = splittedDate[2];
console.log(year);
console.log(month);
console.log(day);
// year = date.slice(0, 3);
// console.log("year = " + year);
// month = date.slice(5,7);
// yearAndMonthInfoP.textContent = "Year : " + year + "\n month = " + month;

switch(Number(month)) {
case 01 : month = "Jan"; //alertcm("month = " + month);
	break;
case 02 : month = "Feb"; //alertcm("month = " + month);
	break;
case 03 : month = "Mar"; //alertcm("month = " + month);
	break;
case 04 : month = "Apr"; //alertcm("month = " + month);
	break;
case 05 : month = "May"; //alertcm("month = " + month);
	break;
case 06 : month = "Jun"; //alertcm("month = " + month);
	break;
case 07 : month = "Jul"; //alertcm("month = " + month);
	break;
case 08 : month = "Aug"; //alertcm("month = " + month);
	break;
case 09 : month = "Sep"; //alertcm("month = " + month);
	break;
case 10 : month = "Oct"; //alertcm("month = " + month);
	break;
case 11 : month = "Nov"; //alertcm("month = " + month);
	break;
case 12 : month = "Dec"; //alertcm("month = " + month);
	break;
	
}
//check numbers to select month	nameOfMonthSelectWin.appendChild(dateSelect);
// }//end gotMonthBtn.onclick = function () 	
yearAndMonthInfoP.textContent = "Year : " + year + "\n  Month: " + month;	
//CODE TO GET MONTH AND YEAR

fixedFieldsBS[0] = "ITEM";
fixedFieldsBS[1] = "Date";
fixedFieldsBS[2] = "Cost to Date";
fixedFieldsBS[3] = "Comments";


// //for 31 day month
// for (var i = 0; i < 31; i++) {
// 	bs31FieldNamesArray[i] = month + " " + (i+1).toString();
// }//end for loop
// fieldNamesArray = fixedFieldsBS + bs31FieldNamesArray;
// //for 31 day month

//for 30 day month
if(month === "Sep" || month === "Apr" || month === "Jun" || month === "Nov") {
for (var i = 00; i < 30; i++) {
	bs30FieldNamesArray[i] = month + " " + (i+1).toString();
}//end for loop
//alertcm("fixedFieldsBS = " + fixedFieldsBS);
//alertcm("bs30FieldNamesArray = " + bs30FieldNamesArray);

//fieldNamesArray = fixedFieldsBS + bs30FieldNamesArray;
//const children = arr1.concat(arr2);
fieldNamesArray = fixedFieldsBS.concat(bs30FieldNamesArray);
fieldNamesArray = fieldNamesArray.concat(addToMonthsArray);
//alertcm("fieldNamesArray = " + fieldNamesArray);
// numberOfFields = fieldNamesArray.length;
// refreshed = 0;
// displayedTable = 0;
// resetFields = true;
} else if (month === "Feb") {
//for Feb month
	for (var i = 00; i < 28; i++) {
	febFieldsNamesArray[i] = month + " " + (i+1).toString();
	}//end for loop
fieldNamesArray = fixedFieldsBS.concat(febFieldsNamesArray);
fieldNamesArray = fieldNamesArray.concat(addToMonthsArray);
//alertcm("fieldNamesArray = " + fieldNamesArray);
//for Feb month	

//for feb leap year month
} else if (month === "Feb" && year === 2024 ||month === "Feb" && year === 2028 || month === "Feb" && year === 2032 || month === "Feb" && year === 2036 || month === "Feb" && year === 2040) {
for (var i = 0; i < 29; i++) {
	leapYearFieldNamesArray[i] = month + " " + (i+1).toString();
}//end for loop
fieldNamesArray = fixedFieldsBS.concat(leapYearFieldNamesArray);
fieldNamesArray = fieldNamesArray.concat(addToMonthsArray);
//alertcm("fieldNamesArray = " + fieldNamesArray);

//for feb leap year month

//for 31 day month
} else {
for (var i = 00; i < 31; i++) {
	bs31FieldNamesArray[i] = month + " " + (i+1).toString();
}//end for loop
fieldNamesArray = fixedFieldsBS.concat(bs31FieldNamesArray);
fieldNamesArray = fieldNamesArray.concat(addToMonthsArray);
//alertcm("fieldNamesArray = " + fieldNamesArray);
}//end if else else (month)

monthSelectWin.appendChild(doneDateBtn);
}//end gotMonthBtn.onclick = function () 
	
doneDateBtn.onclick = function () {
doneDateBtn.textContent = "Working…..please be patient!";
	monthSelectWin.removeChild(monthSelect);
	monthSelectWin.removeChild(gotMonthBtn);
monthSelectWin.removeChild(monthSelectInfoP);
monthSelectWin.removeChild(yearAndMonthInfoP);
monthSelectWin.removeChild(doneDateBtn);

	monthSelectWin.setAttribute('class', 'hidden');
numberOfFields = fieldNamesArray.length;
//DO I NEED TO CALCULATE numberOfDynamicFields FOR BUDGET SHEET HERE? DATE: FEB 6 2023
numberOfDynamicFields = numberOfFields -4;
//DO I NEED TO CALCULATE numberOfDynamicFields FOR BUDGET SHEET HERE? DATE: FEB 6 2023
refreshed = 0;
displayedTable = 0;
resetFields = true;
//update date in tableArray[i][1]
for(i=0;i<tableTitle.length;i++) {//took out -1 because date was not updated in last record
//alert("todayString = " + todayString);
	tableArray[i][1] = todayString;
	//tableArray[i][fieldNamesArray.length-1] = "sumAcross";//sumRowTxt
	tableArray[i][fieldNamesArray.length-1] = sumRowTxt;//displayTable has code saying .includes(sumRowTxt) rowSummed = true which triggers sumAcoss function
}//end for i <numberOfRecords
//alertcm("tableArray = " + tableArray);
//update date in tableArray[i][1]
//data.created = todayString;//hopefully will update creation date in Notes section?

clearTableRows();
displayTable();
//FLASH RETURN TO HOME SCREEN BTN?
//DON'T THINK YOU NEED THIS!!Mar3 2023
//homeScreenBtn.setAttribute('class','borderBlink');
//homeScreenBtn2.setAttribute('class','borderBlink');
firstManageBtn.setAttribute('class','borderBlink');
manageBtn.setAttribute('class','borderBlink');
renameDbFileNameButton.setAttribute('class','borderBlink');
changeMonthBtn1.style.display = "none";
changeMonthBtn2.style.display = "none";
}//end doneDateBtn.onclick

}//end function changeMonthBudgetSheet()



//FUNCTION TO CLOSE DATABASE INNAID OF DELETING WITHOUT A BLOCK!
function closeDataBase (dataBaseName) {
var req = indexedDB.open(dataBaseName,1);

req.onblocked = function () {
        console.log('In req.onblocked of open(dataBaseName)…blocked');
		let db = e.target.result;
        // close the blocking connection:             
       //e.target.result.close();//SWITCH??
		db.close();//SWITCH??
};

req.onsuccess = function (e) {
		console.log('In onsuccess of open(dataBaseName. Will now db.close() via e.target.result.close.. and try to delete database');
        // close the formerly blocked connection:
       e.target.result.close();//SWITCH??
		//db.close();//SWITCH??

};
}//end function closeDataBase

function backMeUp (dataBaseName) {
	//alert("ln function backMeUp .. reNamedDBFileName = " + reNamedDBFileName);
	
	backupBtn1.style.display = "none";
	backupBtn2.style.display = "none";
	//dataBaseName = dbTableName.value;//added Feb25..THIS DOES NOT HAVE THE .BS EXTENSION SO A NEW FILE WITHOUT THE .BS IS CREATED AND WHEN YOU LOAD IT IN FROM THE FILENAMES LIST AND THE NAME GOES TO GETFILENAMES FUNCTION ONUPGRADENEEDED IS TRIGGERED AN WE ARE IN THE CREATE NEW DB PROCESS,!! So do I need to set dataBaseName to anything? YES dataBaseName lost its .bs extension before getting here if coming from an EDIT and backup unsaved data request ..a new budget sheet just created which involves renamedb code and backup ..still not sure where dataBaseName looses its .bs extension.??Date:Mar 10 2023
	if(budgetSheet && !(dataBaseName.includes("bs"))) {
		dataBaseName = dataBaseName + ".bs";
	}//end if(budgetSheet && !(dataBaseName.includes("bs")))
	if (window.confirm("BACKUP RECENTLY SAVED DATA ? : \n" + "  CANCEL will continue without backup.")) {
	//alertbkup("dataBaseName = " + dataBaseName + " dbTableName = " + dbTableName);
	
	prefWindow.setAttribute('class','hidden');
	showTable.setAttribute('class','hidden');
	
	selectedDBinfoP.textContent = "FIRST Tap on filename above to select - "
	//experimental code
	selectedDBNameP.textContent = "BACKINGUP database ...";
			
		dbNameInfo.textContent = dataBaseName;
		selectedDBinfoP.appendChild(dbNameInfo);
reNamedDBFileName = false;//this flag prevents backup routine from going to manipulateString Mar9 2023
backingMeUp = true;//flag prevents unwanted creation of a new db if backing up after an edit to a new budget sheet
//backupFileButton.setAttribute('class','borderBlink');//don't need this with timeout method timeout used so backup code does not run before getting value of database variable…asynchronous vrs synchronous stuff!

const f2 = () => {
setTimeout(() => {
backupDataBase(dataBaseName);
},1000);//was 2000
}
f2();

//manageDataBases(dataBaseName);//this works so keep it
//backupFileButton.click();
//manageFilesWindow.setAttribute('class','showing');	
//backupFileButton.click();	
	//backupDataBase(dataBaseName);
	dataNotBackedUp = false;
	
	} else {
		dataNotBackedUp = true;//keep as true so second warning comes when changing databases..if false here no point in code at changeDBBtn.onclick
		dataBaseName = dbTableName.value;//SHOULD THIS ALSO HAVE .BS ADDED????
		//return;//removed Feb24 test glitch
	}//end confirm backup prompt


}//end function backMeUp

function jumpTo (id) {
var targetElement = document.getElementById(id);
var position = targetElement.getBoundingClientRect();
var x = position.left;
var y = position.top;

window.scrollTo(x,y);
return;	
}//end function jumpTo (targetElement) 

//function to determine if a dataBase is locked .. from Bing AI
//Here’s an example code to determine if an IndexedDB file is locked using navigator.locks.query() method:
/*
async function isLocked(dataBaseName) {
  const query = await navigator.locks.query(fileName);
  alert("query.mode = " + query.mode);
  return query.mode === "exclusive" || query.mode === "shared";
}//end isLocked This function returns a promise that resolves to true if the file is locked and false otherwise.
//I hope that helps! Let me know if you have any other questions.


//function to determine if a dataBase is locked .. from Bing AI
*/

//function to delete originalDB after renaming
//now this function is never called because I just went direct see DONE btn .onclick
// function deleteOriginalDB(originalDBName) {
// deleteDataBase(originalDBName);
// }//end function deleteOriginalDB(originalDBName)SHOULD REMOVE THIS AND JUST USE deleteDataBase(originalDBName);
// function scrollToBottom (id) {
// 	const element = document.getElementById(id);
//    element.scrollTop = element.scrollHeight;
// }	
//}
//readFile(input) function called in HTML when tapping on the input element. The function below is not found I think because traditiona functions can not be hoisted? This function works when called from the script in HTML

// function readFile(input) {
//   let file = input.files[0];
// alert(`File name: ${file.name}`);
//   let reader = new FileReader();

//   reader.readAsText(file);

//   reader.onload = function() {
//     //alertx(reader.result);
//     console.log(reader.result)
//    fileData.textContent = reader.result; 
//    json = reader.result;
//    selectedFileData = reader.result;
//   };

//   reader.onerror = function() {
//     console.log(reader.error);
//   };
// const continueFromFileSelectionBtn = document.createElement('button');
// restoreFromFilesWin.appendChild(continueFromFileSelectionBtn);
// continueFromFileSelectionBtn.onclick = function () {
// restoreFromFilesWin.removeChild(continueFromFileSelectionBtn);
// restoreFromFilesWin.setAttribute('class','hidden');
// }//end function continueFromFileSelectionBtn.onclick
// }//end function readFile


//experimental function to print element disabled its use May20 2022..did not work well and caused bugs..so this function is not currently called
function print_this(elem) {
  document.body.classList.add('print-element')
  elem.classList.add('print')
  window.print()
  document.body.classList.remove('print-element')
  elem.classList.remove('print')
}




 /* DISABLED/ENABLED SERVICE WORKER CODE FOR TESTING NEW CODE IN THIS VERSION !!!!*/
 
 /* should code read : if('serviceWorker' in navigator) {
    navigator.serviceWorker
             .register('./TableNotesVer29sw.js')
             .then(function()*/
/*add the '.' before the slash? Same in start url in manifest…'./index.html' DID NOT CHANGE THIS BECAUSE AS OF AUG 1 app seems to be working off line and after a reboot…not sure what is going on??? REMOVED '.' Aug 3 in both js and manifest*/


//AS OF FEB27 2023 I am using original service worker
//NEW SERVICE WORKER!! Feb6 2023 This is published on github but I know new js is loaded in but I don't think the new service worker registered and I have not seen any newWorker button? It must still be using original service worker?? Will see what happens next?

/*   DISABLED THIS VERSION OF SW vv BECAUSE IT DID NOT SEEM TO REGISTER PROPERLY!

function invokeServiceWorkerUpdateFlow(registration) {
    // TODO implement your own UI notification element
    //safari does not support notifications
    const newWorkerBtn = document.querySelector('#newSW');
    const skipNewWorkerBtn = document.querySelector('#skip');
    newWorkerBtn.textContent = "New version of the app is available. Refresh now?";
    skipNewWorkerBtn.textContent ="SKIP";
	newWorkerBtn.style.display = "unset";
   skipNewWorkerBtn.style.display = "unset";
   // document.appendChild(newWorkerBtn);
    //document.appendChild(skipNewWorkerBtn);
  // notification.show("New version of the app is available. Refresh now?");
    newWorkerBtn.addEventListener('click', () => {
	newWorkerBtn.style.display = "none";
	skipNewWorkerBtn.style.display = "none";
   // document.removeChild(newWorkerBtn);
    //document.removeChild(skipNewWorkerBtn);
        if (registration.waiting) {
            // let waiting Service Worker know it should became active
            registration.waiting.postMessage('SKIP_WAITING');
        }
    })


skipNewWorkerBtn.addEventListener('click', () => {
newWorkerBtn.style.display = "none";
	skipNewWorkerBtn.style.display = "none";
	//document.removeChild(newWorkerBtn);
   //  document.removeChild(skipNewWorkerBtn);
    return;	
});

}//end function invokeServiceWorkerUpdateFlow(registration) 

// check if the browser supports serviceWorker at all
if ('serviceWorker' in navigator) {
alert("Checking for service worker in navigator");
    // wait for the page to load
    window.addEventListener('load', async () => {
        // register the service worker from the file specified
        const registration = await navigator.serviceWorker.register('/swDougieBaseVer48sw.js')

        // ensure the case when the updatefound event was missed is also handled
        // by re-invoking the prompt when there's a waiting Service Worker
      
        if (registration.waiting) {
            invokeServiceWorkerUpdateFlow(registration)
        }

        // detect Service Worker update available and wait for it to become installed
        registration.addEventListener('updatefound', () => {
            if (registration.installing) {
                // wait until the new Service worker is actually installed (ready to take over)
                registration.installing.addEventListener('statechange', () => {
                    if (registration.waiting) {
                        // if there's an existing controller (previous Service Worker), show the prompt
                        if (navigator.serviceWorker.controller) {
                            invokeServiceWorkerUpdateFlow(registration)
                        } else {
                            // otherwise it's the first install, nothing to do
                            console.log('Service Worker initialized for the first time')
                           // alert("Service Worker initialized for the first time");
                        }
                    }
                })
            }
        })

        let refreshing = false;

        // detect controller change and refresh the page
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (!refreshing) {
                window.location.reload()
                refreshing = true
            }
        })
    })
}



//DISABLED ENABLED SERVICE WORKER
//END NEW SERVICE WORKER FEB6 2023
//AS OF FEB 27 2023 , April 25 2023 I am using original service worker

*/ //DISABLED THIS VERSION ^^ OF SW BECAUSE IT DID NOT SEEM TO REGISTER PROPERLY!



//DISABLED ENABLED SERVICE WORKER

//ORIGINAL SERVICE WORKER BELOW v

   if('serviceWorker' in navigator) {
     navigator.serviceWorker
              .register('/DougieBaseVer48sw.js')
              .then(function() { console.log('Service Worker Registered'); });
 			alert('Service Worker Registered!');
		
  
 		 } else {//end if service worker
// 	//StorageManager.estimate()..https://developer.mozilla.org/en-US/docs/Web/API/StorageManager/estimate
	
 	console.log('No Service worker installed!');
 	alert("No Service worker installed!");
// 	document.getElementById("percent").value = '(No Service Worker installed! )';
 }//end if else service worker

//ORIGINAL SERVICE WORKER ABOVE ^

	//what about the manifest file? triggered by oninstall? A2HS?	 
//If the service worker API is supported in the browser, it is registered against the site using the ServiceWorkerContainer.register() method. Its contents reside in the sw.js file, and can be executed after the registration is successful. It's the only piece of Service Worker code that sits inside the app.js file; everything else that is Service Worker-specific is written in the sw.js file itself.

//END OF DISABLED SERVICE WORKER !!!


};//end window.onload function
//}//end if(!newDBGuidance) {
